Brainstorm -> Outline -> Code -> Write -> Edit -> Publish -> Promote

Brainstorming: What is the post about? What does it prove or illustrate?

    Effective patterns for organizing / structuring the layout of Go web applications
Why is it important to write it?
    Because it's a really common problem/question that people have. It's not clear what the best is.
What's unique about my angle?
    I'll be providing some clear recommendations for different types of project.
What are the main elements of the post?
    Samples for small/medium/large and multi-executable
What are the gotchas?
What are the condraditions?
    Decoupling your mindset from MVC and using filesytem for code organization. Using modular reusable
What are the extensions?
What could be the title of the post?
    How to structure Go web applications

> Packages help you organize related Go source files together into a single unit, making them modular, reusable, and maintainable.

===

## Introduction

## Small Web Applications

```plain
.
├── main.go
├── handlers.go
├── models.go
├── assets
│   ├── static
│   ├── sql
│   └── templates
├── go.mod
├── go.sum
└── Makefile
```

It's immediately clear, understandable, there's no unnecessary structure. There's not much cognitive overhead. No circular dependencies.


## Larger Web Applications

Large number of handlers, such that having all the handlers in a single file becomes difficult to work with? And the project has multiple backends (for example, a SQL database containing book details, and a Redis instance for recommendations).

If you're coming from an MVC background, your first instinct might be break out your code into two new `handlers` and `models` packages, similar to this:

```plain
// NOT RECOMMENDED
.
├── main.go
├── routes.go
├── handlers
│   ├── books.go
│   └── recommendations.go
├── models
│    ├── books
│    │   └── books.go
│    └── recommendations
│        └── recommendations.go
├── assets
│   ├── static
│   ├── sql
│   └── templates
├── go.mod
├── go.sum
└── Makefile
```

It's important to bear in mind the purpose of packages in Go: they help you organise related Go source files together into single modular, reusable, units.

In the general case, I would argue that HTTP handlers are a central, integral, part of your web application. A web application without any handlers doesn't make sense. They are also are unlikely to be reused by. It makes sense for them to live in the same package as your `http.Server` and route declarations.

Remember: it's perfectly OK for a single Go package to contain a large number of large files, if it makes sense to (net/http contains about XXX lines of code!).

Instead, consider a structure like this:

```plain
.
├── cmd
│   └── web
│       ├── main.go
│       ├── routes.go
│       ├── books.go
│       └── recommendations.go
├── pkg
│   ├── books
│   │   └── books.go
│   └── recommendations
│       └── recommendations.go
├── assets
│   ├── static
│   ├── sql
│   └── templates
├── go.mod
├── go.sum
└── Makefile
```

So why is this better?

The first thing is that there is a really clear separation of assets. All the Go code for the project lives under the `app` directory.

Having them in the same package also makes it much easier to pass configuration settings and dependencies to your handlers.



## Multi-executable Projects

Another nice thing about the pattern described above is that it extends really nicely to supporting additional executables. For example, you might decide to add a command-line application to the project, so that administrators can easily carry out a specific task.

```plain
.
├── cmd
│   ├── cli
│   │   └── main.go
│   └── web
│       ├── main.go
│       ├── books.go
│       └── recommendations.go
├── pkg
│   ├── books
│   │   └── books.go
│   └── recommendations
│       └── recommendations.go
├── assets
│   └── web
│       ├── static
│       ├── sql
│       └── templates
├── go.mod
├── go.sum
└── Makefile
```