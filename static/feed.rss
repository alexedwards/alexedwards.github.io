<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0">
<channel>
  <title>Alex Edwards</title>
  <link>https://www.alexedwards.net/blog</link>
  <language>en-us</language>
  <lastBuildDate>Mon, 8 Mar 2021 16:00:00 GMT</lastBuildDate>
<item>
    <pubDate>Mon, 8 Mar 2021 16:00:00 GMT</pubDate>
    <link>https://www.alexedwards.net/blog/custom-command-line-flags</link>
    <guid>https://www.alexedwards.net/blog/custom-command-line-flags</guid>
    <title>Custom command-line flags with flag.Func</title>
    <description><![CDATA[
<p>One of my favorite things about the recent <a href="https://golang.org/doc/go1.16">Go 1.16 release</a> is a small &mdash; but very welcome &mdash; addition to the <code>flag</code> package: the <a href="https://golang.org/pkg/flag/#Func"><code>flag.Func()</code></a> function. This makes it much easier to define and use custom command-line flags in your application.</p>

<p>For example, if you want to parse a flag like <code>--pause=10s</code> directly into a <code>time.Duration</code> type,  or parse <code>--urls="http://example.com http://example.org"</code> directly into a <code>[]string</code> slice, then previously you had two options. You could either create a custom type to <a href="http://blog.ralch.com/tutorial/golang-custom-flags/">implement the <code>flag.Value</code> interface</a>, or use a third-party package like <a href="https://github.com/spf13/pflag"><code>pflag</code></a>.</p>

<p>But now the <code>flag.Func()</code> function gives you a simple and lightweight alternative. In this short post we're going to take a look at a few examples of how you can use it in your own code.</p>

<h2 id="parsing-custom-flag-types">Parsing custom flag types</h2>

<p>To demonstrate how this works, let's start with the two examples I gave above and create a sample application which accepts a list of URLs and then prints them out with a pause between them. Similar to this:</p>

<figure class="shell"><code><pre>$ go run . --pause=3s --urls="http://example.com http://example.org http://example.net"
<samp>2021/03/08 08:16:04 http://example.com
2021/03/08 08:16:07 http://example.org
2021/03/08 08:16:10 http://example.net</samp></pre></code></figure>

<p>To make this work, we'll need to do two things:</p>

<ul>
<li>Convert the <code>--pause</code> flag value from a 'human-readable' string like <code>200ms</code>, <code>5s</code> or <code>10m</code> into a native Go <code>time.Duration</code> type. We can do this using the <a href="https://golang.org/pkg/time/#ParseDuration"><code>time.ParseDuration()</code></a> function.</li>

<li>Split the values in the <code>--urls</code> flag into a slice, so we can loop through them. The <a href="https://golang.org/pkg/strings/#Fields"><code>strings.Fields</code></a> function is a good fit for this task.</li>
</ul>

<p>We can use those together with <code>flag.Func()</code> like so:</p>

<figure class="file"><code><pre>package main

import (
    "flag"
    "log"
    "strings"
    "time"
)

func main() {
    // First we need to declare variables to hold the values from the
    // command-line flags. Notice that we also need to set any defaults,
    // which will be used if the relevant flag is not provided at runtime.
    var (
        urls  []string                    // Default of the empty slice
        pause time.Duration = time.Second // Default of one second
    )

    // The flag.Func() function takes three parameters: the flag name, 
    // descriptive help text, and a function with the signature 
    // `func(string) error` which is called to process the string value 
    // from the command-line flag at runtime and assign it to the necessary 
    // variable. In this case, we use strings.Fields() to split the string 
    // based on whitespace and store the resulting slice in the urls  
    // variable that we declared above. We then return nil from the 
    // function to indicate that the flag was parsed without any errors.
    flag.Func("urls", "List of URLs to print", func(flagValue string) error {
        urls = strings.Fields(flagValue)
        return nil
    })

    // Likewise we can do the same thing to parse the pause duration. The 
    // time.ParseDuration() function may throw an error here, so we make 
    // sure to return that from our function.
    flag.Func("pause", "Duration to pause between printing URLs", func(flagValue string) error {
        var err error
        pause, err = time.ParseDuration(flagValue)
        return err
    })

    // Importantly, call flag.Parse() to trigger actual parsing of the 
    // flags.
    flag.Parse()

    // Print out the URLs, pausing between each iteration.
    for _, u := range urls {
        log.Println(u)
        time.Sleep(pause)
    }
}
</pre></code></figure>

<p>If you try to run this application, you should find that the flags are parsed and work just like you would expect. For example:</p>

<figure class="shell"><code><pre>$ go run . --pause=500ms --urls="http://example.com http://example.org http://example.net"
<samp>2021/03/08 08:22:33 http://example.com
2021/03/08 08:22:34 http://example.org
2021/03/08 08:22:34 http://example.net</samp>
</pre></code></figure>

<p>Whereas if you provide an invalid flag value that triggers an error in one of the <code>flag.Func()</code> functions, Go will automatically display the corresponding error message and exit. For example:</p>

<figure class="shell"><code><pre>$ go run . --pause=500xx --urls="http://example.com http://example.org http://example.net"
<samp>invalid value "500xx" for flag -pause: time: unknown unit "xx" in duration "500xx"
Usage of /tmp/go-build3141872390/b001/exe/example.text:
  -pause value
        Duration to pause between printing URLs
  -urls value
        List of URLs to print
exit status 2</samp>
</pre></code></figure>

<p>It's really important to point out here that if a flag isn't provided, the corresponding <code>flag.Func()</code> function <em>will not be called at all</em>. This means that you <strong>cannot</strong> set a default value inside a <code>flag.Func()</code> function, so trying to do something like this won't work:</p>

<figure class="file"><code><pre>flag.Func("pause", "Duration to pause between printing URLs (default 1s)", func(flagValue string) error {
    // DON'T DO THIS! This function wont' be called if the flag value is "".
    if flagValue == "" {
        pause = time.Second
        return nil
    }

    var err error
    pause, err = time.ParseDuration(flagValue)
    return err
})
</pre></code></figure>

<p>On the plus side though, there are no restrictions on the code that can be contained in a <code>flag.Func()</code> function, so if you want, you could get even fancier with this and parse the URLs into a <code>[]*url.URL</code> slice instead of a <code>[]string</code>. Like so:</p>

<figure class="file"><code><pre>var (
    urls  []*url.URL                 
    pause time.Duration = time.Second
)

flag.Func("urls", "List of URLs to print", func(flagValue string) error {
    for _, u := range strings.Fields(flagValue) {
        parsedURL, err := url.Parse(u)
        if err != nil {
            return err
        }
        urls = append(urls, parsedURL)
    }
    return nil
})</pre></code></figure>

<h2 id="validating-flag-values">Validating flag values</h2>

<p>The <code>flag.Func()</code> function also opens up some new opportunities for validating input data from command-line flags. For example, let's say that your application has an <code>--environment</code> flag and you want to restrict the possible values to <code>development</code>, <code>staging</code> or <code>production</code>. </p>

<p>To do that, you can implement a <code>flag.Func()</code> function similar to this:</p>

<figure class="file"><code><pre>package main

import (
    "errors"
    "flag"
    "fmt"
)

func main() {
    var (
        environment string = "development"
    )

    flag.Func("environment", "Operating environment", func(flagValue string) error {
        for _, allowedValue := range []string{"development", "staging", "production"} {
            if flagValue == allowedValue {
                environment = flagValue
                return nil
            }
        }
        return errors.New(`must be one of "development", "staging" or "production"`)
    })

    flag.Parse()

    fmt.Printf("The operating environment is: %s\n", environment)
}</pre></code></figure>

<h3 id="making-reusable-helpers">Making reusable helpers</h3>

<p>If you find yourself repeating the same code in your <code>flag.Func()</code> functions, or the logic is getting too complex, it's possible to break it out into a reusable helper. For example, we could rewrite the example above to process our <code>--environment</code> flag via a generic <code>enumFlag()</code> function, like so:</p>

<figure class="file"><code><pre>package main

import (
    "flag"
    "fmt"
)

func main() {
    var (
        environment string = "development"
    )

    enumFlag(&environment, "environment", []string{"development", "staging", "production"}, "Operating environment")

    flag.Parse()

    fmt.Printf("The operating environment is: %s\n", environment)
}

func enumFlag(target *string, name string, safelist []string, usage string) {
    flag.Func(name, usage, func(flagValue string) error {
        for _, allowedValue := range safelist {
            if flagValue == allowedValue {
                *target = flagValue
                return nil
            }
        }

        return fmt.Errorf("must be one of %v", safelist)
    })
}</pre></code></figure>
   ]]></description>
</item>
<item>
    <pubDate>Wed, 24 Sep 2020 16:00:00 GMT</pubDate>
    <link>https://www.alexedwards.net/blog/json-surprises-and-gotchas</link>
    <guid>https://www.alexedwards.net/blog/json-surprises-and-gotchas</guid>
    <title>Surprises and Gotchas When Working With JSON</title>
    <description><![CDATA[
<p>This is a list of things about Go's <a href="https://golang.org/pkg/encoding/json">encoding/json</a> package which, over the years, have either confused or surprised me when I first encountered them.</p>
<p>Many of these things are mentioned in the official package documentation if you read it carefully enough, so in theory they <em>shouldn't</em> come as a surprise. But a few of them aren't mentioned in the documentation at all &mdash; or at least, they aren't pointed out explicitly &mdash; and are worth being aware of!</p>

<ol style="padding-left: 1.5em;">
    <li><a href="#1">Map entries are sorted alphabetically</a></li>
    <li><a href="#2">Byte slices are encoded as base-64 strings</a></li>
    <li><a href="#3">Nil and empty slices are encoded differently</a></li>
    <li><a href="#4">Integer, time.Time and net.IP values can be used as map keys</a></li>
    <li><a href="#5">Angle brackets and ampersands in strings are escaped</a></li>
    <li><a href="#6">Trailing zeroes are removed from floats</a></li>
    <li><a href="#7">Using omitempty on an zero-valued struct doesn't work</a></li>
    <li><a href="#8">Using omitempty on a zero-value time.Time doesn't work</a></li>
    <li><a href="#9">There is a 'string' struct tag</a></li>
    <li><a href="#10">Non-ASCII punctuation characters aren't supported in struct tags</a></li>
    <li><a href="#11">Decoding a JSON number into an interface{} yields a float64</a></li>
    <li><a href="#12">Don't use More() to check if there are remaining JSON objects in a stream</a></li>
    <li><a href="#13">String values returned by custom MarshalJSON() methods must be quoted</a></li>
</ol>

<h2 id="1">Map entries are sorted alphabetically</h2>

<p>When encoding a Go map to JSON, the entries will be sorted alphabetically based on the map key. For example, the following map:</p>

<figure class="go"><code>
        <pre>
m := map[string]int{
    "z": 123,
    "0": 123,
    "a": 123,
    "_": 123,
}
</pre></code></figure>

<p>Will be encoded to the JSON:</p>

<figure class="plain"><code>
        <pre>
{"0":123,"_":123,"a":123,"z":123}
</pre></code></figure>

<h2 id="2">Byte slices are encoded as base-64 strings</h2>

<p>Any <code>[]byte</code> slices will be converted to a base64-encoded string when encoding them to JSON. The base64 string uses padding and the <a href="https://tools.ietf.org/html/rfc4648#section-4">standard encoding</a> characters, as defined in RFC 4648. For example, the following map:</p>

<figure class="go"><code>
        <pre>
m := map[string][]byte{
    "foo": []byte("bar baz"),
}
</pre></code></figure>

<p>Will be encoded to the JSON:</p>

<figure class="plain"><code>
        <pre>
{"foo":"YmFyIGJheg=="}
</pre></code></figure>

<h2 id="3">Nil and empty slices are encoded differently</h2>

<p>Nil slices in Go will be encoded to the <code>null</code> JSON value. In contrast, an empty (but not nil) slice will be encoded as an empty JSON array. For example:</p>

<figure class="go"><code>
        <pre>
var nilSlice []string
emptySlice := []string{}

m := map[string][]string{
    "nilSlice":   nilSlice,
    "emptySlice": emptySlice,
}
</pre></code></figure>

<p>Will be encoded to the JSON:</p>

<figure class="plain"><code>
        <pre>
{"emptySlice":[],"nilSlice":null}
</pre></code></figure>


<h2 id="4">Integer, time.Time and net.IP values can be used as map keys</h2>

<p>It's possible to encode a map which has integer values as the map keys. These integers will be automatically converted to strings in the resulting JSON (because the keys in a JSON object <a href="https://tools.ietf.org/html/rfc8259#section-4">must always be strings</a>). For example:</p>

<figure class="go"><code>
        <pre>
m := map[int]string{
    123: "foo",
    456_000: "bar",
}
</pre></code></figure>

<p>Will be encoded to the JSON:</p>

<figure class="plain"><code>
        <pre>
{"123":"foo","456000":"bar"}
</pre></code></figure>


<p>In addition, Go allows you to encode maps with keys that implement the <a href="https://golang.org/pkg/encoding/#TextMarshaler">encoding.TextMarshaler</a> interface. This means that you can also use <code>time.Time</code> and <code>net.IP</code> values as map keys out-of-the-box. For example:</p>

<figure class="go"><code>
        <pre>
t1 := time.Now()
t2 := t1.Add(24 * time.Hour)

m := map[time.Time]string{
    t1: "foo",
    t2: "bar",
}
</pre></code></figure>

<p>Will be encoded to the JSON:</p>

<figure class="plain"><code>
        <pre>
{"2009-11-10T23:00:00Z":"foo","2009-11-11T23:00:00Z":"bar"}
</pre></code></figure>


<p>Note that trying to encode a map with any other type of key will result in a <a href="https://golang.org/pkg/encoding/json/#UnsupportedTypeError"><code>json.UnsupportedTypeError</code></a> error.</p>

<h2 id="5">Angle brackets and ampersands in strings are escaped</h2>

<p>If a string contains angle brackets<code>&lt;&gt;</code> these will be escaped to <code>\u003c</code> and <code>\u003e</code> in the JSON output. Likewise the <code>&amp;</code> character will be escaped to <code>\u0026</code>. This is to prevent some web browsers from accidentally interpreting the JSON as HTML. For example:</p>

<figure class="go"><code>
        <pre>
s := []string{
    "&lt;foo&gt;",
    "bar &amp; baz",
}
</pre></code></figure>

<p>Will be encoded to the JSON:</p>

<figure class="plain"><code>
        <pre>
["\u003cfoo\u003e","bar \u0026 baz"]
</pre></code></figure>


<p>If you need to prevent these characters being escaped, you should use a <code>json.Encoder</code> instance and call <a href="https://golang.org/pkg/encoding/json/#Encoder.SetEscapeHTML"><code>SetEscapeHTML(false)</code></a>. An example <a href="https://play.golang.org/p/h1-J5VHtLKq">is here</a>.</p>

<h2 id="6">Trailing zeroes are removed from floats</h2>

<p>When encoding a floating-point number with a fractional part that ends in zero(es), any trailing zeroes will not appear in the JSON. For example:</p>

<figure class="go"><code>
        <pre>
s := []float64{
    123.0,
    456.100,
    789.990,
}
</pre></code></figure>

<p>Will be encoded to the JSON:</p>

<figure class="plain"><code>
        <pre>
[123,456.1,789.99]
</pre></code></figure>


<h2 id="7">Using omitempty on an zero-valued struct doesn't work</h2>

<p>The <code>omitempty</code> directive <em>never considers a struct type to be empty</em> &mdash; even if all the struct fields have their zero value, and you use <code>omitempty</code> on those fields too. It will always appear as an object in the encoded JSON. For example:</p>

<figure class="go"><code>
        <pre>
s := struct {
    Foo struct {
        Bar string `json:",omitempty"`
    } `json:",omitempty"`
}{}
</pre></code></figure>

<p>Will be encoded to the JSON:</p>

<figure class="plain"><code>
        <pre>
{"Foo":{}}
</pre></code></figure>


<p>There’s a long-standing <a href="https://github.com/golang/go/issues/11939">proposal</a> which discusses changing this behavior, but the Go 1 compatibility promise means that it's unlikely to happen any time soon. Instead, you can get around this by making the field a pointer to a struct, which works because <code>omitempty</code> considers <code>nil</code> pointers to be empty. For example:</p>

<figure class="go"><code>
        <pre>
s := struct {
    Foo *struct {
        Bar string `json:",omitempty"`
    } `json:",omitempty"`
}{}
</pre></code></figure>

<h2 id="8">Using omitempty on a zero-value time.Time doesn't work</h2>

<p>Using <code>omitempty</code> on a zero-value <code>time.Time</code> field won't hide it in the encoded JSON. This is because the <code>time.Time</code> type is a struct behind the scenes and, as mentioned above, <code>omitempty</code> <em>never considers a struct type to be empty</em>. Instead, the string <code>"0001-01-01T00:00:00Z"</code> will appear in the JSON (which is the value returned by calling the <a href="https://golang.org/pkg/time/#Time.MarshalJSON"><code>MarshalJSON()</code></a> method on an zero-value <code>time.Time</code>. For example:</p>

<figure class="go"><code>
        <pre>
s := struct {
    Foo time.Time `json:",omitempty"`
}{}
</pre></code></figure>

<p>Will be encoded to the JSON:</p>

<figure class="plain"><code>
        <pre>
{"Foo":"0001-01-01T00:00:00Z"}
</pre></code></figure>


<h2 id="9">There is a 'string' struct tag</h2>

<p>Go provides a <code>string</code> struct tag directive which forces the data in an individual field to be encoded as a string in the resulting JSON. For example, if you want to force an integer to be represented as a string instead of an JSON number you can use the <code>string</code> directive like so:</p>

<figure class="go"><code>
        <pre>
s := struct {
    Foo int `json:",string"`
}{
    Foo: 123,
}
</pre></code></figure>

<p>And this will be encoded to the JSON:</p>

<figure class="plain"><code>
        <pre>
{"Foo":"123"}
</pre></code></figure>


<p>Note that the <code>string</code> struct tag directive will only work on fields which contain float, integer or <code>bool</code> types. For any other type it will have no effect.</p>

<h2 id="10">Non-ASCII punctuation characters aren't supported in struct tags</h2>

<p>When using struct tags to change key names in JSON, any tags containing non-ASCII punctuation characters will be ignored. Notably this means that you can't use en or em dashes, or most currency signs, in struct tags. For example:</p>

<figure class="go"><code>
        <pre>
s := struct {
    CostUSD string `json:"cost $"` // OK
    CostEUR string `json:"cost €"` // Contains the non-ASCII punctuation character €. Will be ignored.
}{
    CostUSD: "100.00",
    CostEUR: "100.00",
}
</pre></code></figure>

<p>Will be encoded to the following JSON (notice that the struct tag renaming the <code>CostEUR</code> field has been ignored):</p>

<figure class="plain"><code>
        <pre>
{"cost $":"100.00","CostEUR":"100.00"}
</pre></code></figure>


<p>Likewise, any struct tags containing non-ASCII punctuation characters will be ignored when <em>decoding</em> values from a JSON object into a struct, and the struct field will be left with its zero value. For example the following code:</p>

<figure class="go"><code>
        <pre>
js := []byte(`{"cost $":"100.00","cost €":"100.00"}`)

s := struct {
    CostUSD string `json:"cost $"`
    CostEUR string `json:"cost €"`
}{}

err := json.Unmarshal(js, &amp;s)
if err != nil {
    log.Fatal(err)
}

fmt.Printf("%+v", s)
</pre></code></figure>

<p>Will print out: </p>

<figure class="plain"><code>
        <pre>
{CostUSD:100.00 CostEUR:}
</pre></code></figure>


<p>This can be annoying in situations where you need to decode a JSON object that has keys containing non-ASCII characters, and you can't change the JSON. To work around this limitation, you can decode to a map as an intermediary step, and then copy the data from the map to the struct. For example the following code:</p>

<figure class="go"><code>
        <pre>
js := []byte(`{"cost $":"100.00","cost €":"100.00"}`)

var aux map[string]string

err := json.Unmarshal([]byte(js), &amp;aux)
if err != nil {
    log.Fatal(err)
}

s := struct {
    CostUSD string `json:"cost $"`
    CostEUR string `json:"cost €"`
}{
    CostUSD: aux["cost $"],
    CostEUR: aux["cost €"],
}

fmt.Printf("%+v", s)
</pre></code></figure>

<p>Will print out:</p>

<figure class="plain"><code>
        <pre>
{CostUSD:100.00 CostEUR:100.00}
</pre></code></figure>


<h2 id="11">Decoding a JSON number into an interface{} yields a float64</h2>

<p>When decoding a JSON number into an <code>interface{}</code>, the value will have the underlying type <code>float64</code> &mdash; even if it is an integer in the original JSON.</p>

<p>If you want to get the value as an integer (instead of a <code>float64</code>) the most robust approach is to decode the JSON using a <code>json.Decoder</code> instance with the <a href="https://golang.org/pkg/encoding/json/#Decoder.UseNumber"><code>UseNumber()</code></a> method set on it. This will decode all JSON numbers to the underlying type <code>json.Number</code> instead of <code>float64</code>, and you can then access the number as an integer using its <code>Int64()</code> method. For example:</p>

<figure class="go"><code>
        <pre>
js := `{"foo": 123, "bar": true}`

var m map[string]interface{}

dec := json.NewDecoder(strings.NewReader(js))
dec.UseNumber()

err := dec.Decode(&amp;m)
if err != nil {
    log.Fatal(err)
}

i, err := m["foo"].(json.Number).Int64()
if err != nil {
    log.Fatal(err)
}

fmt.Printf("foo: %d", i)
</pre></code></figure>

<p>Will print:</p>

<figure class="plain"><code>
        <pre>
foo: 123
</pre></code></figure>


<h2 id="12">Don't use More() to check if there are remaining JSON objects in a stream</h2>

<p>When processing a stream of JSON objects with <code>json.Decoder</code>, don't use the <code>More()</code> method to check if there is a remaining object in the stream. Depsite its name, <code>More()</code> is not designed for this purpose<sup>†</sup>, and trying to use it in this way may cause some subtle problems. </p>

<p><sup>†</sup><em>The <a href="https://golang.org/pkg/encoding/json/#Decoder.More"><code>More()</code></a> method is intended to be used in conjunction with <a href="https://golang.org/pkg/encoding/json/#Decoder.Token"><code>Token()</code></a>, and exists specifically to check if there is another element in the array or object currently being parsed</em>.</p>

<p>For example, if you use it when decoding an invalid JSON stream like <code>{"name": "alice"}{"name": "bob"}]</code> (notice the additional square bracket at the end) it <em>won't</em> result in an error (when it should!). Like so:</p>

<figure class="go"><code>
        <pre>
js := `{"name": "alice"}{"name": "bob"}]`

dec := json.NewDecoder(strings.NewReader(js))
for {
    var user map[string]string

    err := dec.Decode(&amp;user)
    if err != nil {
        log.Fatal(err)
    }

    fmt.Printf("%v\n", user)

    // Don't do this!
    if !dec.More() {
        break
    }
}
</pre></code></figure>

<p>This code will run without error and output: </p>

<figure class="plain"><code>
        <pre>
map[name:alice]
map[name:bob]
</pre></code></figure>


<p>The correct technique to see if a stream contains another JSON object is to check for an <code>io.EOF</code> error, which will be returned when there are no more objects to process in the stream. Like so: </p>

<figure class="go"><code>
        <pre>
js := `{"name": "alice"}{"name": "bob"}]`

dec := json.NewDecoder(strings.NewReader(js))
for {
    var user map[string]string

    err := dec.Decode(&amp;user)
    if err != nil {
        if errors.Is(err, io.EOF) {
            break
        }
        log.Fatal(err)
    }

    fmt.Printf("%v\n", user)
}
</pre></code></figure>

<p>Running this will correctly result in an error, as we would expect given the invalid input:</p>

<figure class="plain"><code>
        <pre>
map[name:alice]
map[name:bob]
2009/11/10 23:00:00 invalid character ']' looking for beginning of value
</pre></code></figure>


<h2 id="13">String values returned by custom MarshalJSON() methods must be quoted</h2>

<p>If you are creating a custom <code>MarshalJSON()</code> method which returns a string value, you must wrap the string in double quotes before returning it, otherwise it won't be interpreted as a JSON string and will result in a runtime error. For example:</p>

<figure class="go"><code>
        <pre>
type Age int

func (age Age) MarshalJSON() ([]byte, error) {
    encodedAge := fmt.Sprintf("%d years", age)
    encodedAge = strconv.Quote(encodedAge) // Wrap the string in quotes before returning.
    return []byte(encodedAge), nil
}

func main() {
    users := map[string]Age{
        "alice": 21,
        "bob":   84,
    }

    js, err := json.Marshal(users)
    if err != nil {
        log.Fatal(err)
    }

    fmt.Printf("%s", js)
}
</pre></code></figure>

<p>Will result in the following JSON being printed:</p>

<figure class="plain"><code>
        <pre>
{"alice":"21 years","bob":"84 years"}
</pre></code></figure>


<p>If, in the code above, you didn't quote the return value from <code>MarshalJSON()</code> you will get the error:</p>

<figure class="plain"><code>
        <pre>
2009/11/10 23:00:00 json: error calling MarshalJSON for type main.Age: invalid character 'y' after top-level value
</pre></code></figure>
   ]]></description>
</item>
<item>
    <pubDate>Mon, 20 Apr 2020 12:00:00 GMT</pubDate>
    <link>https://www.alexedwards.net/blog/how-to-manage-database-timeouts-and-cancellations-in-go</link>
    <guid>https://www.alexedwards.net/blog/how-to-manage-database-timeouts-and-cancellations-in-go</guid>
    <title>How to Manage Database Timeouts and Cancellations in Go</title>
    <description><![CDATA[
<p>One of the great features of Go's <code>database/sql</code> package is that it's possible to cancel database queries <em>while they are still running</em> via a <code>context.Context</code> instance.</p>

<p>On the face of it, usage of this functionality is quite straightforward (here's a <a href="https://golang.org/pkg/database/sql/#example_DB_ExecContext">basic example</a>). But once you start digging into the details there's a lot a nuance and quite a few gotchas... especially if you are using this functionality in the context of a web application or API. </p>

<p>So in this post I want to explain <em>how</em> to cancel database queries in a web application, what <em>behavioral quirks and edge cases</em> it is important to be aware of, and try to provide answers to the questions that you might have when working through all this.</p>

<p>But first off, <em>why would you want to cancel a database query?</em> Two scenarios spring to mind:</p>

<ol>
<li><p><strong>When a query is taking a lot longer to complete than expected.</strong> If this happens, it suggests a problem &mdash; either with that particular query or your database or application more generally. In this scenario, you would probably want to cancel the query after a set period of time (so that resources are freed-up and the database connection is returned to the <code>sql.DB</code> connection pool for reuse), log an error for further investigation, and return a <code>500 Internal Server Error</code> response to the client.</p></li>

<li><p><strong>When a client goes away unexpectedly before the query completes.</strong>  This could happen for a number of reasons, such as a user closing a browser tab or terminating a process. In this scenario, nothing has really gone 'wrong', but there is no client left to return a response to so you may as well cancel the query and free-up the resources.</p></li>
</ol>

<h2 id="mimicking-a-long-running-query">Mimicking a long-running query</h2>

<p>Let's start with the first scenario. To demonstrate this, I'll make a very basic web application with a handler that executes a <code>SELECT pg_sleep(10)</code> SQL query against a PostgreSQL database using the <a href="https://github.com/lib/pq"><code>pq</code></a> driver. The <a href="https://www.postgresql.org/docs/current/functions-datetime.html#FUNCTIONS-DATETIME-DELAY"><code>pg_sleep(10)</code></a> function will make the query sleep for 10 seconds before returning, essentially mimicking a slow-running query.</p>

<figure class="file"><code><pre>
package main

import (
    "database/sql"
    "fmt"
    "log"
    "net/http"

    _ "github.com/lib/pq"
)

var db *sql.DB

func slowQuery() error {
    _, err := db.Exec("SELECT pg_sleep(10)")
    return err
}

func main() {
    var err error

    db, err = sql.Open("postgres", "postgres://user:pa$$word@localhost/example_db")
    if err != nil {
        log.Fatal(err)
    }

    if err = db.Ping(); err != nil {
        log.Fatal(err)
    }

    mux := http.NewServeMux()
    mux.HandleFunc("/", exampleHandler)

    log.Println("Listening...")
    err = http.ListenAndServe(":5000", mux)
    if err != nil {
        log.Fatal(err)
    }
}

func exampleHandler(w http.ResponseWriter, r *http.Request) {
    err := slowQuery()
    if err != nil {
        serverError(w, err)
        return
    }

    fmt.Fprintln(w, "OK")
}

func serverError(w http.ResponseWriter, err error) {
    log.Printf("ERROR: %s", err.Error())
    http.Error(w, "Sorry, something went wrong", http.StatusInternalServerError)
}
</pre></code></figure>

<p>If you were to run this code, then make a <code>GET /</code> request to the application you should find that the request hangs for 10 seconds before you finally get an <code>"OK"</code> response. Like so:</p>

<figure class="shell"><code><pre>
$ curl -i localhost:5000/
<samp>HTTP/1.1 200 OK
Date: Fri, 17 Apr 2020 07:46:40 GMT
Content-Length: 3
Content-Type: text/plain; charset=utf-8

OK</samp>
</pre></code></figure>

<aside class="note">
<strong>Note:</strong> The structure of the application code above is deliberately over-simplified. In a real project I would recommend using <a href="https://www.alexedwards.net/blog/organising-database-access#dependency-injection">dependency injection</a> to make the <code>sql.DB</code> connection pool and logger available to your handlers, instead of using global variables.
</aside>

<h2 id="adding-a-context-timeout">Adding a context timeout</h2>

<p>OK, now that we've got some code that mimics a long-running query, let's enforce a <em>timeout</em> on the query so it is automatically canceled if it doesn't complete within 5 seconds.</p>

<p></p>To do this we need to:</p>

<ol>
<li>Use the <a href="https://golang.org/pkg/context/#WithTimeout"><code>context.WithTimeout()</code></a> function to create a <code>context.Context</code> instance with a 5-second timeout duration.</li>

<li>Execute the SQL query using the <a href="https://golang.org/pkg/database/sql/#DB.ExecContext"><code>ExecContext()</code></a> method, passing the <code>context.Context</code> instance as a parameter.</li>
</ol>

<p>I'll demonstrate:</p>

<figure class="file"><code><pre>
package main

import (
    "context" // New import
    "database/sql"
    "fmt"
    "log"
    "net/http"
    "time" // New import

    _ "github.com/lib/pq"
)

var db *sql.DB

func slowQuery(ctx context.Context) error {
    // Create a new child context with a 5-second timeout, using the
    // provided ctx parameter as the parent.
    ctx, cancel := context.WithTimeout(ctx, 5*time.Second)
    defer cancel()

    // Pass the child context (the one with the timeout) as the first
    // parameter to ExecContext().
    _, err := db.ExecContext(ctx, "SELECT pg_sleep(10)")
    return err
}

...

func exampleHandler(w http.ResponseWriter, r *http.Request) {
    // Pass the request context to slowQuery(), so it can be used as the 
    // parent context.
    err := slowQuery(r.Context())
    if err != nil {
        serverError(w, err)
        return
    }

    fmt.Fprintln(w, "OK")
}

...
</pre></code></figure>

<p>There are a few things about this that I'd like to emphasize and explain:</p>

<ul>
<li><p>Note that we pass <code>r.Context()</code> (the <em>request context</em>) to <code>slowQuery()</code> to use as the parent context. As we'll see in the next section, this is important because it means that any cancellation signal on the request context will be able to 'bubble down' to the context that we use in <code>ExecContext()</code>.
</p></li>

<li><p>The <code>defer cancel()</code> line is important because it ensures that the resources associated with our child context (the one with the timeout) will be released before the <code>slowQuery()</code> function returns. If we don't call <code>cancel()</code> it may cause a memory leak: the resources won't be released until either the parent <code>r.Context()</code> is canceled or the 5-second timeout is hit (whichever happens first).</p></li>

<li><p>The timeout countdown begins from the moment that the child context is created using <code>context.WithTimeout()</code>. If you want more control over this you could use the alternative  <a href="https://golang.org/pkg/context/#WithDeadline"><code>context.WithDeadline()</code></a> function, which allows you to set an explicit <code>time.Time</code> value for when the context should timeout instead.</p></li>
</ul>

<p>OK, let's try this out. If you run the application again and make a <code>GET /</code> request, after a 5-second delay you should get a response like this:</p>

<figure class="shell"><code><pre>
$ curl -i localhost:5000/
<samp>HTTP/1.1 500 Internal Server Error
Content-Type: text/plain; charset=utf-8
X-Content-Type-Options: nosniff
Date: Fri, 17 Apr 2020 08:21:14 GMT
Content-Length: 28

Sorry, something went wrong</samp>
</pre></code></figure>

<p>And if you go back to the terminal window running the application you should see a log message similar to this:</p>

<figure class="shell"><code><pre>
$ go run .
<samp>2020/04/17 10:21:07 Listening...
2020/04/17 10:21:14 ERROR: pq: canceling statement due to user request</samp>
</pre></code></figure>

<p>That log message might seem a bit odd... until you realize that the error message is actually coming from PostgreSQL. In that light it makes sense: <em>our web application</em> is the user and we're canceling the query after 5 seconds.</p>

<p>So this is actually really good; things are working as we want.</p>

<p>Specifically, after 5 seconds the context timeout is reached and the <code>pq</code> driver sends a cancellation signal to PostgreSQL<sup>†</sup>. PostgreSQL then terminates the running query (thereby freeing-up resources). The client is sent a <code>500 Internal Server Error</code> response, and the error message is logged so we know that something has gone wrong.</p>

<p><em>† More precisely, our child context (the one with the 5-second timeout) has a <code>Done</code> channel, and when the timeout is reached it will close the <code>Done</code> channel. While the SQL query is running, our database driver <code>pq</code> is also running a background goroutine which  listens on this <code>Done</code> channel. If the channel is closed, then it sends a cancellation signal to PostgreSQL. PostgreSQL terminates the query, and then sends the error message that we see above as a response to the original <code>pq</code> goroutine. That error message is then returned to our <code>slowQuery()</code> function.</em></p>

<h2 id="closed-connections">Dealing with closed connections</h2>

<p>OK, let's try one more thing. Let's use curl to make a <code>GET /</code> request and then very quickly (within 5 seconds) press <code>Ctrl+C</code> to cancel the request.</p>

<p>If you look at the logs for the application again, you should see another log line with exactly the same error message that we saw before.</p>

<figure class="shell"><code><pre>
$ go run .
<samp>2020/04/17 10:21:07 Listening...
2020/04/17 10:21:14 ERROR: pq: canceling statement due to user request
2020/04/17 10:41:18 ERROR: pq: canceling statement due to user request</samp>
</pre></code></figure>

<p><em>So what's happening here?</em></p>

<p>In this case, the request context (which we use as the parent in our code above) is <em>canceled</em> because the client closed the connection. From the <a href="https://golang.org/pkg/net/http/#Request.Context"><code>net/http</code></a> docs:</p>

<blockquote>
  <p>For incoming server requests, the [request] context is canceled when the client's connection closes, the request is canceled (with HTTP/2), or when the ServeHTTP method returns. </p>
</blockquote>

<p>This cancellation signal bubbles down to our child context, it's <code>Done</code> channel is closed, and the <code>pq</code> driver terminates the running query in exactly the same way as before.</p>

<p>With that in mind, it's not surprising that we see the same error message... From a PostgreSQL point of view exactly the same thing is happening as when the timeout was reached. </p>

<p><strong>But from the perspective of our web application the scenario is very different.</strong> A client connection being closed  can happen for many different, innocuous, reasons. It's not really an error from our application's point of view, although it is probably sensible to log it as a warning (if we start to see elevated rates, it could be a sign that something is wrong).</p>

<p>Fortunately, it's possible to tell these two scenarios apart by calling the <a href="https://golang.org/pkg/context/#Context"><code>ctx.Err()</code></a> method on our child context. If the context was canceled (due to a client closing the connection), then <code>ctx.Err()</code> will return <code>context.Canceled</code>. If the timeout was reached, then it will return <code>context.DeadlineExceeded</code>.  If <em>both</em> the deadline is reached and the context is canceled, then <code>ctx.Err()</code> will surface whichever happened first.</p>

<p>There's another important thing to point out here: <strong>it's possible that a timeout/cancellation will happen before the PostgreSQL query even starts.</strong> For example you might have set <a href="https://golang.org/pkg/database/sql/#DB.SetMaxOpenConns"><code>MaxOpenConns()</code></a> on your <code>sql.DB</code> connection pool, and if that open connection limit is reached and all connections are in-use, then the query will be 'queued' by <code>sql.DB</code> until a connection becomes available. In this scenario &mdash; or any other which causes a delay &mdash; it's quite possible that the timeout/cancellation will occur before a free database connection even becomes available. In this case <code>ExecContext()</code> will directly return the <code>ctx.Err()</code> value as the error response (instead of the <code style="white-space: normal;">"pq: canceling statement due to user request"</code> error that we see above). </p>

<p>If you're using the <a href="https://golang.org/pkg/database/sql/#DB.QueryContext"><code>QueryContext()</code></a> method then<strong> it's also possible that the timeout/cancellation will occur when processing the data</strong> with <code>Scan()</code>. If this happens, then <code>Scan()</code> will directly return the <code>ctx.Err()</code> value as an error. As far as I can see this behavior isn't mentioned in the <code>database/sql</code> docs, but I can confirm that this is the case with Go 1.14 and the comments on <a href="https://github.com/golang/go/issues/28842">issue #28842</a> suggest that it is intentional.</p>

<p>Putting all that together, a sensible approach is to check for the error <code style="white-space: normal;">"pq: canceling statement due to user request"</code> and then <a href="https://blog.golang.org/go1.13-errors#TOC_3.3.">wrap this</a> with the error from <code>ctx.Err()</code> before returning from our <code>slowQuery()</code> function.</p>
<p>Then in our handler, we can use the <a href="https://blog.golang.org/go1.13-errors#TOC_3.2."><code>errors.Is()</code></a> function to check if the error from <code>slowQuery()</code> is equal to (or wraps) <code>context.Canceled</code> and manage it accordingly. Like so:</p>

<figure class="file"><code><pre>
package main

import (
	"context"
	"database/sql"
	"errors" // New import
	"fmt"
	"log"
	"net/http"
	"time"

	_ "github.com/lib/pq"
)

var db *sql.DB

func slowQuery(ctx context.Context) error {
	ctx, cancel := context.WithTimeout(ctx, 5*time.Second)
	defer cancel()

	_, err := db.ExecContext(ctx, "SELECT pg_sleep(10)")
    // If we get a "pq: canceling statement..." error wrap it with the 
    // context error before returning.
    if err != nil && err.Error() == "pq: canceling statement due to user request" {
		return fmt.Errorf("%w: %v", ctx.Err(), err)
	}

	return err
}

...

func exampleHandler(w http.ResponseWriter, r *http.Request) {
	err := slowQuery(r.Context())
	if err != nil {
        // Check if the returned error equals or wraps context.Canceled and 
        // record a warning if it does.
		switch {
		case errors.Is(err, context.Canceled):
			serverWarning(err)
		default:
			serverError(w, err)
		}
		return
	}

	fmt.Fprintln(w, "OK")
}

func serverWarning(err error) {
	log.Printf("WARNING: %s", err.Error())
}

...
</pre></code></figure>

<p>If you were to run this application again now and make two different <code>GET /</code> requests &mdash; one that times out, and the other that you cancel &mdash; you should see clearly different messages in the application log, like so:</p>

<figure class="shell"><code><pre>
$ go run .
<samp>2020/04/17 13:09:25 Listening...
2020/04/17 13:09:45 ERROR: context deadline exceeded: pq: canceling statement due to user request
2020/04/17 13:09:47 WARNING: context canceled: pq: canceling statement due to user request</samp>
</pre></code></figure>

<h3 id="other-context-aware-methods">Other context-aware methods</h3>

<p>The <code>database/sql</code> package provides context-aware variants for most actions on <code>sql.DB</code>, including <code>PingContext()</code>, <code>QueryContext()</code>, and <code>QueryRowContext()</code>. We can (and should!) update the <code>main()</code> function in the code above to use <code>PingContext()</code> instead of <code>Ping()</code>.</p>

<p>In this case there is no request context to use as the parent, so we need to create an empty parent context with <code>context.Background()</code> instead. Like so:</p>

<figure class="file"><code><pre>
...

func main() {
	var err error

	db, err = sql.Open("postgres", "postgres://user:pa$$word@localhost/example_db")
	if err != nil {
		log.Fatal(err)
	}

    // Create a context with a 10-second timeout, using the empty 
    // context.Background() as the parent.
	ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
	defer cancel()

    // Use this when testing the connection pool.
	if err = db.PingContext(ctx); err != nil {
		log.Fatal(err)
	}

	mux := http.NewServeMux()
	mux.HandleFunc("/", exampleHandler)

	log.Println("Listening...")
	err = http.ListenAndServe(":5000", mux)
	if err != nil {
		log.Fatal(err)
	}
}

...
</pre></code></figure>

<h3 id="can-i-set-a-global-timeout-for-all-requests">Can I set a global timeout for all requests?</h3>

<p>Sure, you could create and use some middleware on your routes which adds a timeout to the current request context, similar to this:</p>

<figure class="file"><code><pre>
func setTimeout(next http.Handler) http.Handler {
    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        ctx, cancel := context.WithTimeout(r.Context(), 5*time.Second)
        defer cancel()

        // This gives you a copy of the request with a the request context 
        // changed to the new context with the 5-second timeout created 
        // above.
        r = r.WithContext(ctx)
        next.ServeHTTP(w, r)
    })
}
</pre></code></figure>

<p>If you take this approach there are a few of things to be aware of:</p>

<ul>
<li>The timeout starts from the moment the context is created, so any code running in your handlers before the database query counts towards the timeout.</li>

<li>If you have multiple queries being executed in a handler, then they <em>all</em> have to complete within that one time. </li>

<li>The timeout will continue to apply <em>even if you derive a child context</em> with a different timeout duration.  So while you can enforce an earlier timeout in a child context, <strong>you can't make it longer</strong>.</li>
</ul>

<h3 id="what-about-http-timeouthandler">What about http.TimeoutHandler?</h3>

<p>Go provides a <a href="https://golang.org/pkg/net/http/#TimeoutHandler"><code>http.TimeoutHandler()</code></a> middleware function which you can use to wrap your handlers or router/servemux. This works similar to the middleware above in the sense that it  sets a timeout on the request context... so the warnings above also apply when using this. </p>

<p>However, <code>http.TimeoutHandler()</code> also sends the client a <code>503 Service Unavailable</code> response and a HTML error message. So, if you're using this in your application, you shouldn't (or at least, you don't need to) send the client an error response yourself when encountering a <code>context.DeadlineExceeded</code> error.</p>

<h3 id="how-about-transactions">How about transactions? How does context work in those?</h3>

<p>The <code>database/sql</code> package provides a <code>BeginTx()</code> method which you can use to initiate a context-aware transaction. A code example <a href="https://golang.org/pkg/database/sql/#example_Tx_ExecContext">can be seen here</a>.</p>

<p>It's important to understand that the context you provide  to <code>BeginTx()</code> applies to the whole transaction. In the event of a timeout/cancellation on the context, then the queries in the transaction will automatically be rolled-back.</p>

<p>It's perfectly fine to pass the same context as a parameter for all the queries in the transaction, in which case it ensures that they all (<em>as a whole</em>) complete before any timeout/cancellation . Alternatively, if you want per-query timeouts you can create different child contexts with different timeouts for each in the queries in the transaction. <strong>But you must derive these child contexts from the context you passed to <code>BeginTX()</code></strong>. Otherwise there is a risk that the <code>BeginTX()</code> context timeout/cancellation occurs and the automatic rollback happens, but your code still may try to execute the query with a still-live context. If that happened you would receive the error <code style="white-space: normal;">"sql: transaction has already been committed or rolled back"</code>.</p>

<h3 id="background-processing">What about background processing?</h3>

<p>When doing background-processing in a different goroutine, bear in mind that if a parent context is canceled, the cancellation signal 'bubbles down' to its children. And also bear in mind what I quoted earlier about request context cancellation:</p>

<blockquote>
<p>For incoming server requests, the [request] context is canceled ... <strong>when the ServeHTTP method returns</strong>.</p>
</blockquote>

<p>Combine those two things, and it means that if you use a context which is a child of the request context in the background-process, the background-process will get a cancellation signal when the HTTP response is sent for the initial request. If you don't want that to be the case (and you probably don't), then you should create a brand-new context for the background-process using <code>context.Background()</code> and copy over any values that you need... or just pass them as regular parameters instead.<p>

<h3 id="if-a-context-is-canceled">If a context is canceled, can I be confident that it's due to a closed connection?</h3>

<p>Yes &mdash; so long as it's within the main goroutine for the request, it's a child of the request context, and you haven't manually canceled it yourself yet using <code>defer cancel()</code>. Otherwise, no.</p>

<h3 id="other-dbs">Is the behavior the same with other databases and drivers?</h3>

<p>I'm not sure. I've only used these features extensively with PostgreSQL and the <code>pq</code> driver. I imagine that things will be roughly the same with other databases and drivers, but you'll need to check.</p>

<h3 id="anything-else">Anything else I should know?</h3>

<p>Yep. This is a strange one and it's <a href="https://github.com/golang/go/issues/33340">not officially documented yet</a>, but if a client makes a request with a non-empty request body then closes the connection, the context won't be canceled <em>until after</em> you have read the request body. </p>

<p>This doesn’t apply to requests without a request body, where the cancellation signal will be received immediately.</p>

<p>You should also be aware of the <code>WriteTimeout</code> setting on your <code>http.Server</code> (if you have set one). Your context timeouts should always be shorter than your <code>WriteTimeout</code> value, otherwise the <code>WriteTimeout</code> will be hit first, the connection will be closed, and the client won’t get any response.</p>
   ]]></description>
 </item>
  <item>
    <pubDate>Mon, 21 Oct 2019 20:00:00 GMT</pubDate>
    <link>https://www.alexedwards.net/blog/how-to-properly-parse-a-json-request-body</link>
    <guid>https://www.alexedwards.net/blog/how-to-properly-parse-a-json-request-body</guid>
    <title>How to Parse a JSON Request Body in Go</title>
    <description><![CDATA[
<p>Let's say that you're building a JSON API with Go. And in some of the handlers &mdash; probably as part of a POST or PUT request &mdash; you want to read a JSON object from the request body and assign it to a struct in your code.</p>

<p>After a bit of research, there's a good chance that you'll end up with some code that looks similar to the <code>personCreate</code> handler here:</p>

<figure class="file"><code class="go"><pre>
// File: main.go
package main

import (
    "encoding/json"
    "fmt"
    "log"
    "net/http"
)

type Person struct {
    Name string
    Age  int
}

func personCreate(w http.ResponseWriter, r *http.Request) {
    // Declare a new Person struct.
    var p Person

    // Try to decode the request body into the struct. If there is an error,
    // respond to the client with the error message and a 400 status code.
    err := json.NewDecoder(r.Body).Decode(&amp;p)
    if err != nil {
        http.Error(w, err.Error(), http.StatusBadRequest)
        return
    }

    // Do something with the Person struct...
    fmt.Fprintf(w, "Person: %+v", p)
}

func main() {
    mux := http.NewServeMux()
    mux.HandleFunc("/person/create", personCreate)

    err := http.ListenAndServe(":4000", mux)
    log.Fatal(err)
}
</pre></code></figure>

<p>If you're putting together a quick prototype, or building an API for personal/internal use only, then the code in the <code>personCreate</code> handler is probably OK.</p>

<p>But if you're building an API for public use in production then there are a few issues with this to be aware of, and things that can be improved.</p>

<ol>
<li><p>Not all errors returned by <a href="https://golang.org/pkg/encoding/json/#Decoder.Decode"><code>Decode()</code></a> are caused by a bad request from the client. Specifically, <code>Decode()</code> can return a <a href="https://golang.org/pkg/encoding/json/#InvalidUnmarshalError"><code>json.InvalidUnmarshalError</code></a> error &mdash; which is caused by an unmarshalable target destination being passed to <code>Decode()</code>. If that happens, then it indicates a problem with our application &mdash; not the client request &mdash; so really the error should be logged and a <code>500 Internal Server Error</code> response sent to the client instead.</p></li>

<li><p>The error messages returned by <code>Decode()</code> aren't ideal for sending to a client. Some are arguably too detailed and expose information about the underlying program (like <code style="white-space: normal;">"json: cannot unmarshal number into Go struct field Person.Name of type string"</code>). Others aren't descriptive enough (like <code style="white-space: normal;">"unexpected EOF"</code>) and some are just plain confusing (like <code style="white-space: normal;">"invalid character 'A' looking for beginning of object key string"</code>). There also isn't consistency in the formatting or language used.</p></li>

<li><p>A client can include extra unexpected fields in their JSON, and these fields will be silently ignored without the client receiving any error. We can fix this by using the decoder's <a href="https://golang.org/pkg/encoding/json/#Decoder.DisallowUnknownFields"><code>DisallowUnknownFields()</code></a> method.</p></li>

<li><p>There's no upper limit on the size of the request body that will be read by the <code>Decode()</code> method. Limiting this would help prevent our server resources being wasted if a malcious client sends a very large request body, and it's something we can easily do by using the <a href="https://golang.org/pkg/net/http/#MaxBytesReader"><code>http.MaxBytesReader()</code></a> function.</p></li>

<li><p>There's no check for a <code>Content-Type: application/json</code> header in the request. Of course, this header may not always be present, and mistakes and malicious clients mean that it isn't a guarantee of the <em>actual</em> content type. But checking for an incorrect <code>Content-Type</code> header would allow us to 'fail fast' and send a helpful error message without spending unnecessary resources on parsing the body.</p></li>

<li><p>The <code>Decode()</code> method is designed to decode streams of JSON objects. This means a request body like <code>'{"Name": "Bob"}{"Name": "Carol": "Age": 54}'</code> or <code>'{"Name": "Dave"}{}'</code> is considered valid and won't result in the client receiving an error message. But in each case, only the first JSON object in the request body will actually be parsed.</p>
<p>There are two solutions here. We can either check the decoder's <a href="https://golang.org/pkg/encoding/json/#Decoder.More"><code>More()</code></a> method after decoding to see if there any any other JSON objects in the request body. Or we could avoid using <code>Decode()</code> altogether and read the body into a byte slice and pass it to <a href="https://golang.org/pkg/encoding/json/#Unmarshal"></a><code>json.Unmarshal()</code></a>, which <em>would</em> return an error if the body contains multiple JSON objects. The downside of using <code>json.Unmarshal()</code> is that there is no way to disallow extra unexpected fields in the JSON, so we can't address point 3 above.</p></li>
</ol>

<h2 id="an-improved-handler">An Improved Handler</h2>

<p>Let's implement an alternative version of the <code>personCreate</code> handler which addresses all of these issues.</p>

<p>You'll notice here that we're using the new <a href="https://golang.org/pkg/errors/#Is"><code>errors.Is()</code></a> and <a href="https://golang.org/pkg/errors/#As"><code>errors.As()</code></a> functions, which have been introduced in Go 1.13, to help intercept the errors from <code>Decode()</code>.</p>

<figure class="file"><code class="go"><pre>
// File: main.go
package main

import (
    "encoding/json"
    "errors"
    "fmt"
    "io"
    "log"
    "net/http"
    "strings"

    "github.com/golang/gddo/httputil/header"
)

type Person struct {
    Name string
    Age  int
}

func personCreate(w http.ResponseWriter, r *http.Request) {
    // If the Content-Type header is present, check that it has the value
    // application/json. Note that we are using the gddo/httputil/header
    // package to parse and extract the value here, so the check works
    // even if the client includes additional charset or boundary
    // information in the header.
    if r.Header.Get("Content-Type") != "" {
        value, _ := header.ParseValueAndParams(r.Header, "Content-Type")
        if value != "application/json" {
            msg := "Content-Type header is not application/json"
            http.Error(w, msg, http.StatusUnsupportedMediaType)
            return
        }
    }

    // Use http.MaxBytesReader to enforce a maximum read of 1MB from the
    // response body. A request body larger than that will now result in
    // Decode() returning a "http: request body too large" error.
    r.Body = http.MaxBytesReader(w, r.Body, 1048576)

    // Setup the decoder and call the DisallowUnknownFields() method on it.
    // This will cause Decode() to return a "json: unknown field ..." error
    // if it encounters any extra unexpected fields in the JSON. Strictly
    // speaking, it returns an error for "keys which do not match any
    // non-ignored, exported fields in the destination".
    dec := json.NewDecoder(r.Body)
    dec.DisallowUnknownFields()

    var p Person
    err := dec.Decode(&amp;p)
    if err != nil {
        var syntaxError *json.SyntaxError
        var unmarshalTypeError *json.UnmarshalTypeError

        switch {
        // Catch any syntax errors in the JSON and send an error message
        // which interpolates the location of the problem to make it
        // easier for the client to fix.
        case errors.As(err, &amp;syntaxError):
            msg := fmt.Sprintf("Request body contains badly-formed JSON (at position %d)", syntaxError.Offset)
            http.Error(w, msg, http.StatusBadRequest)

        // In some circumstances Decode() may also return an
        // io.ErrUnexpectedEOF error for syntax errors in the JSON. There
        // is an open issue regarding this at
        // https://github.com/golang/go/issues/25956.
        case errors.Is(err, io.ErrUnexpectedEOF):
            msg := fmt.Sprintf("Request body contains badly-formed JSON")
            http.Error(w, msg, http.StatusBadRequest)

        // Catch any type errors, like trying to assign a string in the
        // JSON request body to a int field in our Person struct. We can
        // interpolate the relevant field name and position into the error
        // message to make it easier for the client to fix.
        case errors.As(err, &amp;unmarshalTypeError):
            msg := fmt.Sprintf("Request body contains an invalid value for the %q field (at position %d)", unmarshalTypeError.Field, unmarshalTypeError.Offset)
            http.Error(w, msg, http.StatusBadRequest)

        // Catch the error caused by extra unexpected fields in the request
        // body. We extract the field name from the error message and
        // interpolate it in our custom error message. There is an open
        // issue at https://github.com/golang/go/issues/29035 regarding
        // turning this into a sentinel error.
        case strings.HasPrefix(err.Error(), "json: unknown field "):
            fieldName := strings.TrimPrefix(err.Error(), "json: unknown field ")
            msg := fmt.Sprintf("Request body contains unknown field %s", fieldName)
            http.Error(w, msg, http.StatusBadRequest)

        // An io.EOF error is returned by Decode() if the request body is
        // empty.
        case errors.Is(err, io.EOF):
            msg := "Request body must not be empty"
            http.Error(w, msg, http.StatusBadRequest)

        // Catch the error caused by the request body being too large. Again
        // there is an open issue regarding turning this into a sentinel
        // error at https://github.com/golang/go/issues/30715.
        case err.Error() == "http: request body too large":
            msg := "Request body must not be larger than 1MB"
            http.Error(w, msg, http.StatusRequestEntityTooLarge)

        // Otherwise default to logging the error and sending a 500 Internal
        // Server Error response.
        default:
            log.Println(err.Error())
            http.Error(w, http.StatusText(http.StatusInternalServerError), http.StatusInternalServerError)
        }
        return
    }

    // Check that the request body only contained a single JSON object.
    if dec.More() {
        msg := "Request body must only contain a single JSON object"
        http.Error(w, msg, http.StatusBadRequest)
        return
    }

    fmt.Fprintf(w, "Person: %+v", p)
}

func main() {
    mux := http.NewServeMux()
    mux.HandleFunc("/person/create", personCreate)

    err := http.ListenAndServe(":4000", mux)
    log.Fatal(err)
}
</pre></code></figure>

<p>The clear downside here is that this code is a lot more verbose, and IMO, a little bit ugly. Things aren't helped by the fact that there are quite a few open issues with <code>json/encoding</code> which are on hold pending <a href="https://github.com/golang/go/issues/29035#issuecomment-444598621">a wider review</a> of the package.</p>

<p>But from a security and client perspective it's a lot better : )</p>

<p>The handler is now stricter about the content it will accept; we're reducing the amount of server resources used unnecessarily; and the client gets clear and consistent error messages that provide a decent amount of information without over-sharing.</p>

<p>As a side note, you might have noticed that the <code>json/encoding</code> package contains some other error types (like <a href="https://golang.org/pkg/encoding/json/#UnmarshalFieldError"><code>json.UnmarshalFieldError</code></a>) which aren't checked in the code above &mdash; but these have been deprecated and not used by Go 1.13.</p>

<h2 id="makingahelperfunction">Making a Helper Function</h2>

<p>If you've got a few handlers that need to to process JSON request bodies, you probably don't want to repeat this code in all of them.</p>

<p>A solution which I've found works  well is to create a <code>decodeJSONBody</code> helper function, and have this return a custom <code>malformedRequest</code> error type which wraps the errors and relevant status codes.</p>

<p>For example:</p>

<figure class="file"><code class="go"><pre>
// File: helpers.go
package main

import (
    "encoding/json"
    "errors"
    "fmt"
    "io"
    "net/http"
    "strings"

    "github.com/golang/gddo/httputil/header"
)

type malformedRequest struct {
    status int
    msg    string
}

func (mr *malformedRequest) Error() string {
    return mr.msg
}

func decodeJSONBody(w http.ResponseWriter, r *http.Request, dst interface{}) error {
    if r.Header.Get("Content-Type") != "" {
        value, _ := header.ParseValueAndParams(r.Header, "Content-Type")
        if value != "application/json" {
            msg := "Content-Type header is not application/json"
            return &amp;malformedRequest{status: http.StatusUnsupportedMediaType, msg: msg}
        }
    }

    r.Body = http.MaxBytesReader(w, r.Body, 1048576)

    dec := json.NewDecoder(r.Body)
    dec.DisallowUnknownFields()

    err := dec.Decode(&amp;dst)
    if err != nil {
        var syntaxError *json.SyntaxError
        var unmarshalTypeError *json.UnmarshalTypeError

        switch {
        case errors.As(err, &amp;syntaxError):
            msg := fmt.Sprintf("Request body contains badly-formed JSON (at position %d)", syntaxError.Offset)
            return &amp;malformedRequest{status: http.StatusBadRequest, msg: msg}

        case errors.Is(err, io.ErrUnexpectedEOF):
            msg := fmt.Sprintf("Request body contains badly-formed JSON")
            return &amp;malformedRequest{status: http.StatusBadRequest, msg: msg}

        case errors.As(err, &amp;unmarshalTypeError):
            msg := fmt.Sprintf("Request body contains an invalid value for the %q field (at position %d)", unmarshalTypeError.Field, unmarshalTypeError.Offset)
            return &amp;malformedRequest{status: http.StatusBadRequest, msg: msg}

        case strings.HasPrefix(err.Error(), "json: unknown field "):
            fieldName := strings.TrimPrefix(err.Error(), "json: unknown field ")
            msg := fmt.Sprintf("Request body contains unknown field %s", fieldName)
            return &amp;malformedRequest{status: http.StatusBadRequest, msg: msg}

        case errors.Is(err, io.EOF):
            msg := "Request body must not be empty"
            return &amp;malformedRequest{status: http.StatusBadRequest, msg: msg}

        case err.Error() == "http: request body too large":
            msg := "Request body must not be larger than 1MB"
            return &amp;malformedRequest{status: http.StatusRequestEntityTooLarge, msg: msg}

        default:
            return err
        }
    }

    if dec.More() {
        msg := "Request body must only contain a single JSON object"
        return &amp;malformedRequest{status: http.StatusBadRequest, msg: msg}
    }

    return nil
}
</pre></code></figure>

<p>Once that's written, the code in your handlers can be kept really nice and compact:</p>

<figure class="file"><code class="go"><pre>
// File: main.go
package main

import (
    "errors"
    "fmt"
    "log"
    "net/http"
)

type Person struct {
    Name string
    Age  int
}

func personCreate(w http.ResponseWriter, r *http.Request) {
    var p Person

    err := decodeJSONBody(w, r, &amp;p)
    if err != nil {
        var mr *malformedRequest
        if errors.As(err, &amp;mr) {
            http.Error(w, mr.msg, mr.status)
        } else {
            log.Println(err.Error())
            http.Error(w, http.StatusText(http.StatusInternalServerError), http.StatusInternalServerError)
        }
        return
    }

    fmt.Fprintf(w, "Person: %+v", p)
}

func main() {
    mux := http.NewServeMux()
    mux.HandleFunc("/person/create", personCreate)

    log.Println("Starting server on :4000...")
    err := http.ListenAndServe(":4000", mux)
    log.Fatal(err)
}
</pre></code></figure>
   ]]></description>
 </item>
 <item>
    <pubDate>Tue, 7 Aug 2019 14:00:00 GMT</pubDate>
    <link>https://www.alexedwards.net/blog/interfaces-explained</link>
    <guid>https://www.alexedwards.net/blog/interfaces-explained</guid>
    <title>Golang Interfaces Explained</title>
    <description><![CDATA[
<p>For the past few months I've been running <a href="https://goo.gl/forms/Wvh42OXhvCHco5cw2">a survey</a> which asks people what they're finding difficult about learning Go. And something that keeps coming up in the responses is the concept of <em>interfaces</em>.</p>

<p>I get that. Go was the first language I ever used that had interfaces, and I remember at the time that the whole concept felt pretty confusing. So in this tutorial I want to do a few things:</p>

<ol>
<li>Provide a plain-English explanation of what interfaces are;</li>

<li>Explain why they are useful and how you might want to use them in your code;</li>

<li>Talk about what <code>interface{}</code> (the empty interface) is;</li>

<li>And run through some of the helpful interface types that you'll find in the standard library.</li>
</ol>

<h2 id="what-is-an-interface">So what is an interface?</h2>

<p>An interface type in Go is kind of like a <em>definition</em>. It defines and describes the exact methods that <em>some other type</em> must have.</p>

<p>One example of an interface type from the standard library is the <a href="https://golang.org/pkg/fmt/#Stringer"><code>fmt.Stringer</code></a> interface, which looks like this:</p>

<figure><code class="go"><pre>
type Stringer interface {
    String() string
}
</pre></code></figure>

<p>We say that something <em>satisfies this interface</em> (or <em>implements this interface</em>) if it has a method with the exact signature <code>String() string</code>.</p>

<p>For example, the following <code>Book</code> type satisfies the interface because it has a <code>String() string</code> method:</p>

<figure><code class="go"><pre>
type Book struct {
    Title  string
    Author string
}

func (b Book) String() string {
    return fmt.Sprintf("Book: %s - %s", b.Title, b.Author)
}
</pre></code></figure>

<p>It's not really important what this <code>Book</code> type is or does. The only thing that matters is that is has a method called <code>String()</code> which returns a <code>string</code> value.</p>

<p>Or, as another example, the following <code>Count</code> type <em>also</em> satisfies the <code>fmt.Stringer</code> interface &mdash; again because it has a method with the exact signature <code>String() string</code>.</p>

<figure><code class="go"><pre>
type Count int

func (c Count) String() string {
    return strconv.Itoa(int(c))
}
</pre></code></figure>

<p>The important thing to grasp is that we have two different types, <code>Book</code> and <code>Count</code>, which do different things. But the thing they have in common is that they both satisfy the <code>fmt.Stringer</code> interface.</p>

<p>You can think of this the other way around too. If you know that an object satisfies the <code>fmt.Stringer</code> interface, you can rely on it having a method with the exact signature <code>String() string</code> that you can call.</p>

<p>Now for the important part.</p>

<p><em>Wherever you see declaration in Go (such as a variable, function parameter or struct field) which has an interface type, you can use an object of any type <strong>so long as it satisfies the interface</em></strong>.</p>

<p>For example, let's say that you have the following function:</p>

<figure><code class="go"><pre>
func WriteLog(s fmt.Stringer) {
    log.Println(s.String())
}
</pre></code></figure>

<p>Because this <code>WriteLog()</code> function uses the <code>fmt.Stringer</code> interface type in its parameter declaration, we can pass in any object that satisfies the <code>fmt.Stringer</code> interface. For example, we could pass either of the <code>Book</code> and <code>Count</code> types that we made earlier to the <code>WriteLog()</code> method, and the code would work OK.</p>

<p>Additionally, because the object being passed in satisfies the <code>fmt.Stringer</code> interface, we <em>know</em> that it has a <code>String() string</code> method that the <code>WriteLog()</code> function can safely call.</p>

<p>Let's put this together in an example, which gives us a peek into the power of interfaces.</p>

<figure><code class="go"><pre>
package main

import (
    "fmt"
    "strconv"
    "log"
)

// Declare a Book type which satisfies the fmt.Stringer interface.
type Book struct {
    Title  string
    Author string
}

func (b Book) String() string {
    return fmt.Sprintf("Book: %s - %s", b.Title, b.Author)
}

// Declare a Count type which satisfies the fmt.Stringer interface.
type Count int

func (c Count) String() string {
    return strconv.Itoa(int(c))
}

// Declare a WriteLog() function which takes any object that satisfies
// the fmt.Stringer interface as a parameter.
func WriteLog(s fmt.Stringer) {
    log.Println(s.String())
}

func main() {
    // Initialize a Count object and pass it to WriteLog().
    book := Book{"Alice in Wonderland", "Lewis Carrol"}
    WriteLog(book)

    // Initialize a Count object and pass it to WriteLog().
    count := Count(3)
    WriteLog(count)
}
</pre></code></figure>

<p>This is pretty cool. In the <code>main</code> function we've created different <code>Book</code> and <code>Count</code> types, but passed both of them to the <em>same</em> <code>WriteLog()</code> function. In turn, that calls their relevant <code>String()</code> functions and logs the result.</p>

<p>If you <a href="https://play.golang.org/p/DDQOFHxfOF8">run the code</a>, you should get some output which looks like this:</p>

<figure class="shell"><code><pre>
2009/11/10 23:00:00 Book: Alice in Wonderland - Lewis Carrol
2009/11/10 23:00:00 3
</pre></code></figure>

<p>I don't want to labor the point here too much. But the key thing to take away is that by using a interface type in our <code>WriteLog()</code> function declaration, we have made the function agnostic (or flexible) about the exact <em>type</em> of object it receives. All that matters is <em>what methods it has</em>. </p>

<h2 id="why-are-interfaces-useful">Why are they useful?</h2>

<p>There are all sorts of reasons that you might end up using a interface in Go, but in my experience the three most common are:</p>

<ol>
<li>To help reduce duplication or boilerplate code.</li>
<li>To make it easier to use mocks instead of real objects in unit tests.</li>
<li>As an architectural tool, to help enforce decoupling between parts of your codebase.</li>
</ol>

<p>Let's step through these three use-cases and explore them in a bit more detail.</p>

<h3 id="reducing-boilerplate-code">Reducing boilerplate code</h3>

<p>OK, imagine that we have a <code>Customer</code> struct containing some data about a customer. In one part of our codebase we want to write the customer information to a <a href="https://golang.org/pkg/bytes/#Buffer"><code>bytes.Buffer</code></a>, and in another part of our codebase we want to write the customer information to an <a href="https://golang.org/pkg/os/#File"><code>os.File</code></a> on disk. But in both cases, we want to serialize the customer struct to JSON first.</p>

<p>This is a scenario where we can use Go's interfaces to help reduce boilerplate code. </p>

<p>The first thing you need to know is that Go has an <a href="https://golang.org/pkg/io/#Writer"><code>io.Writer</code></a> interface type which looks like this:</p>

<figure><code class="go"><pre>
type Writer interface {
        Write(p []byte) (n int, err error)
}
</pre></code></figure>
<p>And we can leverage the fact that both <a href="https://golang.org/pkg/os/#pkg-variables"><code>bytes.Buffer</code></a> and the <a href="https://golang.org/pkg/os/#File"><code>os.File</code></a> type satisfy this interface, due to them having the <a href="https://golang.org/pkg/bytes/#Buffer.Write"><code>bytes.Buffer.Write()</code></a> and <a href="https://golang.org/pkg/bytes/#Buffer.Write"><code>os.File.Write()</code></a> methods respectively. </p>

<p>Let's take a look at a simple implementation:</p>

<figure><code class="go"><pre>
package main

import (
    "bytes"
    "encoding/json"
    "io"
    "log"
    "os"
)

// Create a Customer type
type Customer struct {
    Name string
    Age  int
}

// Implement a WriteJSON method that takes an io.Writer as the parameter.
// It marshals the customer struct to JSON, and if the marshal worked
// successfully, then calls the relevant io.Writer's Write() method.
func (c *Customer) WriteJSON(w io.Writer) error {
    js, err := json.Marshal(c)
    if err != nil {
        return err
    }

    _, err = w.Write(js)
    return err
}

func main() {
    // Initialize a customer struct.
    c := &Customer{Name: "Alice", Age: 21}

    // We can then call the WriteJSON method using a buffer...
    var buf bytes.Buffer
    err := c.WriteJSON(&buf)
    if err != nil {
        log.Fatal(err)
    }

    // Or using a file.
    f, err := os.Create("/tmp/customer")
    if err != nil {
        log.Fatal(err)
    }
    defer f.Close()


    err = c.WriteJSON(f)
    if err != nil {
        log.Fatal(err)
    }
}
</pre></code></figure>

<p>Of course, this is just a toy example (and there are other ways we could structure the code to achieve the same end result). But it nicely illustrates the benefit of using an interface &mdash; we can create the <code>Customer.WriteJSON()</code> method once, and we can call that method any time that we want to write to something that satisfies the <code>io.Writer</code> interface. </p>

<p>But if you're new to Go, this still begs a couple of questions: <em>How do you know that the <code>io.Writer</code> interface even exists? And how do you know in advance that <code>bytes.Buffer</code> and <code>os.File</code> both satisfy it?</em></p>

<p>There's no easy shortcut here I'm afraid &mdash; you simply need to build up experience and familiarity with the interfaces and different types in the standard library. Spending time thoroughly reading the standard library documentation, and looking at other people's code will help here. But as a quick-start I've included a list of some of the most useful interface types at the <a href="#useful-interface-types">end of this post</a>.</p>

<p>But even if you don't use the interfaces from the standard library, there's nothing to stop you from creating and using <em>your own interface types</em>. We'll cover how to do that next.</p>

<h3 id="unit-testing-and-mocking">Unit testing and mocking</h3>

<p>To help illustrate how interfaces can be used to assist in unit testing, let's take a look at a slightly more complex example.</p>

<p>Let's say you run a shop, and you store information about the number of customers and sales in a PostgreSQL database. You want to write some code that calculates the sales rate (i.e. sales per customer) for the past 24 hours, rounded to 2 decimal places.</p>

<p>A minimal implementation of the code for that could look something like this: </p>

<figure class="file"><code class="go"><pre>
// File: main.go
package main

import (
    "fmt"
    "log"
    "time"
    "database/sql"
    _ "github.com/lib/pq"
)

type ShopDB struct {
    *sql.DB
}

func (sdb *ShopDB) CountCustomers(since time.Time) (int, error) {
    var count int
    err := sdb.QueryRow("SELECT count(*) FROM customers WHERE timestamp > $1", since).Scan(&count)
    return count, err
}

func (sdb *ShopDB) CountSales(since time.Time) (int, error) {
    var count int
    err := sdb.QueryRow("SELECT count(*) FROM sales WHERE timestamp > $1", since).Scan(&count)
    return count, err
}

func main() {
    db, err := sql.Open("postgres", "postgres://user:pass@localhost/db")
    if err != nil {
        log.Fatal(err)
    }
    defer db.Close()

    shopDB := &ShopDB{db}
    sr, err := calculateSalesRate(shopDB)
    if err != nil {
        log.Fatal(err)
    }
    fmt.Printf(sr)
}

func calculateSalesRate(sdb *ShopDB) (string, error) {
    since := time.Now().Add(-24 * time.Hour)

    sales, err := sdb.CountSales(since)
    if err != nil {
        return "", err
    }

    customers, err := sdb.CountCustomers(since)
    if err != nil {
        return "", err
    }

    rate := float64(sales) / float64(customers)
    return fmt.Sprintf("%.2f", rate), nil
}
</pre></code></figure>

<p>Now, what if we want to create a unit test for the <code>calculateSalesRate()</code> function to make sure that the math logic in it is working correctly?</p>

<p>Currently this is a bit of a pain. We would need to set up a test instance of our PostgreSQL database, along with setup and teardown scripts to scaffold the database with dummy data. That's quite lot of work when all we really want to do is test our math logic.</p>

<p>So what can we do? You guessed it &mdash; interfaces to the rescue!</p>

<p>A solution here is to create our own interface type which describes the <code>CountSales()</code> and <code>CountCustomers()</code> methods that the <code>calculateSalesRate()</code> function relies on. Then we can update the signature of <code>calculateSalesRate()</code> to use this custom interface type as a parameter, instead of the concrete <code>*ShopDB</code> type.</p>

<p>Like so:</p>

<figure class="file"><code class="go"><pre>
// File: main.go
package main

import (
	"database/sql"
	"fmt"
	"log"
	"time"

	_ "github.com/lib/pq"
)

// Create our own custom ShopModel interface. Notice that it is perfectly
// fine for an interface to describe multiple methods, and that it should
// describe input parameter types as well as return value types.
type ShopModel interface {
	CountCustomers(time.Time) (int, error)
	CountSales(time.Time) (int, error)
}

// The ShopDB type satisfies our new custom ShopModel interface, because it
// has the two necessary methods -- CountCustomers() and CountSales().
type ShopDB struct {
	*sql.DB
}

func (sdb *ShopDB) CountCustomers(since time.Time) (int, error) {
	var count int
	err := sdb.QueryRow("SELECT count(*) FROM customers WHERE timestamp > $1", since).Scan(&count)
	return count, err
}

func (sdb *ShopDB) CountSales(since time.Time) (int, error) {
	var count int
	err := sdb.QueryRow("SELECT count(*) FROM sales WHERE timestamp > $1", since).Scan(&count)
	return count, err
}

func main() {
	db, err := sql.Open("postgres", "postgres://user:pass@localhost/db")
	if err != nil {
		log.Fatal(err)
	}
	defer db.Close()

	shopDB := &ShopDB{db}
	sr, err := calculateSalesRate(shopDB)
	if err != nil {
		log.Fatal(err)
	}
	fmt.Printf(sr)
}

// Swap this to use the ShopModel interface type as the parameter, instead of the
// concrete *ShopDB type.
func calculateSalesRate(sm ShopModel) (string, error) {
	since := time.Now().Add(-24 * time.Hour)

	sales, err := sm.CountSales(since)
	if err != nil {
		return "", err
	}

	customers, err := sm.CountCustomers(since)
	if err != nil {
		return "", err
	}

	rate := float64(sales) / float64(customers)
	return fmt.Sprintf("%.2f", rate), nil
}
</pre></code></figure>

<p>With that done, it's straightforward for us to create a mock which satisfies our <code>ShopModel</code> interface. We can then use that mock during unit tests to test that the math logic in our <code>calculateSalesRate()</code> function works correctly. Like so:</p>

<figure class="file"><code class="go"><pre>
// File: main_test.go
package main

import (
    "testing"
    "time"
)

type MockShopDB struct{}

func (m *MockShopDB) CountCustomers(_ time.Time) (int, error) {
    return 1000, nil
}

func (m *MockShopDB) CountSales(_ time.Time) (int, error) {
    return 333, nil
}

func TestCalculateSalesRate(t *testing.T) {
    // Initialize the mock.
    m := &MockShopDB{}
    // Pass the mock to the calculateSalesRate() function.
    sr, err := calculateSalesRate(m)
    if err != nil {
        t.Fatal(err)
    }

    // Check that the return value is as expected, based on the mocked
    // inputs.
    exp := "0.33"
    if sr != exp {
        t.Fatalf("got %v; expected %v", sr, exp)
    }
}
</pre></code></figure>

<p>You could run that test now, everything should work fine.</p>

<h3 id="application-architecture">Application architecture</h3>

<p>In the previous examples, we've seen how interfaces can be used to decouple certain parts of your code from relying on concrete types. For instance, the <code>calculateSalesRate()</code> function is totally flexible about what you pass to it &mdash; the only thing that matters is that it satisfies the <code>ShopModel</code> interface.</p>

<p>You can extend this idea to create decoupled 'layers' in larger projects. </p>

<p>Let's say that you are building a web application which interacts with a database. If you create an interface that describes the exact methods for interacting with the database, you can refer to the interface throughout your HTTP handlers instead of a concrete type. Because the HTTP handlers only refer to an interface, this helps to decouple the HTTP layer and database-interaction layer. It makes it easier to work on the layers independently, and to swap out one layer in the future without affecting the other.</p>

<p>I've written about this pattern in <a href="https://www.alexedwards.net/blog/organising-database-access">this previous blog post</a>, which goes into more detail and provides some practical example code.</p>

<h2 id="what-is-the-empty-interface">What is the empty interface?</h2>

<p>If you've been programming with Go for a while, you've probably come across the <em>empty interface type</em>: <code>interface{}</code>. This can be a bit confusing, but I'll try to explain it here.</p>

<p>At the start of this blog post I said:</p>

<blockquote>
  <p>An interface type in Go is kind of like a <em>definition</em>. It defines and describes the exact methods that <em>some other type</em> must have.</p>
</blockquote>

<p>The empty interface type essentially <em>describes no methods</em>. It has no rules. And because of that, it follows that any and every object satisfies the empty interface.</p>

<p>Or to put it in a more plain-English way, the empty interface type <code>interface{}</code> is kind of like a wildcard. Wherever you see it in a declaration (such as a variable, function parameter or struct field) you can use an object <em>of any type</em>.</p>

<p>Take a look at the following code:</p>

<figure><code class="go"><pre>
package main

import "fmt"


func main() {
    person := make(map[string]interface{}, 0)

    person["name"] = "Alice"
    person["age"] = 21
    person["height"] = 167.64

    fmt.Printf("%+v", person)
}
</pre></code></figure>

<p>In this code snippet we initialize a <code>person</code> map, which uses the <code>string</code> type for keys and the empty interface type <code>interface{}</code> for values. We've assigned three different types as the map values (a <code>string</code>, <code>int</code> and <code>float32</code>) &mdash; and that's OK. Because objects of any and every type satisfy the empty interface, the code will work just fine.</p>

<p>You can <a href="https://play.golang.org/p/GwxCQkLYNrq">give it a try here</a>, and when you run it you should see some output which looks like this:</p>

<figure class="shell"><code><pre>
map[age:21 height:167.64 name:Alice]
</pre></code></figure>

<p>But there's an important thing to point out when it comes to retrieving and using a value from this map.</p>

<p>For example, let's say that we want to get the <code>"age"</code> value and increment it by 1. If you write something like the following code, it will fail to compile:</p>

<figure><code class="go"><pre>
package main

import "log"

func main() {
    person := make(map[string]interface{}, 0)

    person["name"] = "Alice"
    person["age"] = 21
    person["height"] = 167.64

    person["age"] = person["age"] + 1

    fmt.Printf("%+v", person)
}
</pre></code></figure>

<p>And you'll get the following error message:</p>

<figure class="shell"><code><pre>
invalid operation: person["age"] + 1 (mismatched types interface {} and int)
</pre></code></figure>

<p>This happens because the value stored in the map takes on the type <code>interface{}</code>, and ceases to have it's original, underlying, type of <code>int</code>. Because it's no longer an <code>int</code> type we cannot add 1 to it.</p>

<p>To get around this this, you need to type assert the value back to an <code>int</code> before using it. Like so:</p>

<figure><code class="go"><pre>
package main

import "log"

func main() {
    person := make(map[string]interface{}, 0)

    person["name"] = "Alice"
    person["age"] = 21
    person["height"] = 167.64

    age, ok := person["age"].(int)
    if !ok {
        log.Fatal("could not assert value to int")
        return
    }

    person["age"] = age + 1

    log.Printf("%+v", person)
}
</pre></code></figure>

<p>If you <a href="https://play.golang.org/p/3cB9emSdcRX">run this now</a>, everything should work as expected:</p>

<figure class="shell"><code><pre>
2009/11/10 23:00:00 map[age:22 height:167.64 name:Alice]
</pre></code></figure>

<p>So when should you use the empty interface type in your own code?</p>

<p>The answer is <em>probably not that often</em>. If you find yourself reaching for it, pause and consider whether using <code>interface{}</code> is really the right option. As a general rule it's clearer, safer and more performant to use concrete types &mdash; or non-empty interface types &mdash; instead. In the code snippet above, it would have been more appropriate to define a <code>Person</code> struct with relevant typed fields similar to this:</p>

<figure><code class="go"><pre>
type Person struct {
    Name   string
    Age    int
    Height float32
}
</pre></code></figure>

<p>But that said, the empty interface is useful in situations where you need to accept and work with unpredictable or user-defined types. You'll see it used in a a number of places throughout the standard library for that exact reason, such as in the <a href="https://golang.org/pkg/encoding/gob/#Encoder.Encode"><code>gob.Encode</code></a>, <a href="https://golang.org/pkg/fmt/#Print"><code>fmt.Print</code></a> and <a href="https://golang.org/pkg/text/template/#Template.Execute"><code>template.Execute</code></a> functions.</p>

<h2 id="useful-interface-types">Comman and useful types</h2>

<p>Lastly, here's a short list of some of the most common and useful interfaces in the standard library. If you're not familiar with them already, then I recommend taking out a bit of time to look at the relevant documentation for them.</p>

<ul>
<li><a href="https://golang.org/pkg/builtin/#error">builtin.Error</a></li>
<li><a href="https://golang.org/pkg/fmt/#Stringer">fmt.Stringer</a></li>
<li><a href="https://golang.org/pkg/io/#Reader">io.Reader</a></li>
<li><a href="https://golang.org/pkg/io/#Writer">io.Writer</a></li>
<li><a href="https://golang.org/pkg/io/#ReadWriteCloser">io.ReadWriteCloser</a></li>
<li><a href="https://golang.org/pkg/net/http/#ResponseWriter">http.ResponseWriter</a></li>
<li><a href="https://golang.org/pkg/net/http/#Handler">http.Handler</a></li>
</ul>

<p>There is also a longer and more comprehensive listing of standard libraries available in <a href="https://gist.github.com/asukakenji/ac8a05644a2e98f1d5ea8c299541fce9">this gist</a>.</p>
    ]]></description>
 </item>
 <item>
    <pubDate>Tue, 14 May 2019 12:00:00 GMT</pubDate>
    <link>https://www.alexedwards.net/blog/using-postgresql-jsonb</link>
    <guid>https://www.alexedwards.net/blog/using-postgresql-jsonb</guid>
    <title>Using PostgreSQL JSONB with Go</title>
    <description><![CDATA[
<p>PostgreSQL provides two JSON-related data types that you can use &mdash; <code>JSON</code> and <code>JSONB</code>. The principal differences are:</p>

<ul>
<li><code>JSON</code> stores an <em>exact copy</em> of the JSON input.</li>

<li><code>JSONB</code> stores a <em>binary representation</em> of the JSON input. This makes it slower to insert but faster to query. It may change the key order, and will remove whitespace and delete duplicate keys. <code>JSONB</code> also supports the <code>?</code> (existence) and <code>@&gt;</code> (containment) operators, whereas <code>JSON</code> doesn't.</li>
</ul>

<p>The <a href="https://www.postgresql.org/docs/9.4/datatype-json.html">PostgreSQL documentation</a> recommends that you should generally use <code>JSONB</code>, unless you have a specific reason not too (like needing to preserve key order).</p>

<p>Here's a cribsheet for the essential commands:</p>

<figure class="plain"><code class="sql"><pre>
-- Create a table with a JSONB column.
CREATE TABLE items (
    id SERIAL PRIMARY KEY,
    attrs JSONB
);

-- You can insert any well-formed json input into the column. Note that only
-- lowercase `true` and `false` spellings are accepted.
INSERT INTO items (attrs) VALUES ('{
   "name": "Pasta",
   "ingredients": ["Flour", "Eggs", "Salt", "Water"],
   "organic": true,
   "dimensions": {
      "weight": 500.00
   }
}');

-- Create an index on all key/value pairs in the JSONB column.
CREATE INDEX idx_items_attrs ON items USING gin (attrs);

-- Create an index on a specific key/value pair in the JSONB column.
CREATE INDEX idx_items_attrs_organic ON items USING gin ((attrs-&gt;'organic'));

-- The -&gt; operator is used to get the value for a key. The returned value has
-- the type JSONB.
SELECT attrs-&gt;'dimensions' FROM items;
SELECT attrs-&gt;'dimensions'-&gt;'weight' FROM items;

-- Or you can use -&gt;&gt; to do the same thing, but this returns a TEXT value
-- instead.
SELECT attrs-&gt;&gt;'dimensions' FROM items;

-- You can use the returned values as normal, although you may need to type
-- cast them first.
SELECT * FROM items WHERE attrs-&gt;&gt;'name' ILIKE 'p%';
SELECT * FROM items WHERE (attrs-&gt;'dimensions'-&gt;&gt;'weight')::numeric &lt; 100.00;

-- Use ? to check for the existence of a specific key.
SELECT * FROM items WHERE attrs ? 'ingredients';

-- The ? operator only works at the top level. If you want to check for the
-- existence of a nested key you can do this:
SELECT * FROM items WHERE attrs-&gt;'dimensions' ? 'weight';

-- The ? operator can also be used to check for the existence of a specific
-- text value in json arrays.
SELECT * FROM items WHERE attrs-&gt;'ingredients' ? 'Salt';

-- Use @&gt; to check if the JSONB column contains some specific json. This can
-- be useful to filter for a specific key/value pair like so:
SELECT * FROM items WHERE attrs @&gt; '{"organic": true}'::jsonb;
SELECT * FROM items WHERE attrs @&gt; '{"dimensions": {"weight": 10}}'::jsonb;

-- Note that @&gt; looks for *containment*, not for an exact match. The
-- followingquery will return records which have both "Flour" and "Water"
-- as ingredients, rather than *only* "Flour" and "Water" as the ingredients.
SELECT * FROM items WHERE attrs @&gt; '{"ingredients": ["Flour", "Water"]}'::jsonb;
</pre></code></figure>

<p>For a full description of all available operators please see the official <a href="https://www.postgresql.org/docs/9.4/functions-json.html">JSON Functions and Operators</a> documentation.</p>

<h2 id="usingwithgo">Using with Go</h2>

<p>If your not familiar with the general patterns for working with SQL databases in Go, you might want to read my <a href="https://www.alexedwards.net/blog/practical-persistence-sql">introduction to the <code>database/sql</code></a> package before continuing.</p>

<h3 id="knownjsonfields">Known JSON fields</h3>

<p>When the fields in a JSON/JSONB column are known in advance, you can map the contents of the JSON/JSONB column to and from a struct. To do this, you'll need make sure the struct implements:</p>

<ul>
<li><p>The <a href="https://golang.org/pkg/database/sql/driver/#Valuer"><code>driver.Valuer</code></a> interface, such that it marshals the object into a JSON byte slice that can be understood by the database.</p></li>

<li><p>The <a href="https://golang.org/pkg/database/sql/#Scanner"><code>sql.Scanner</code></a> interface, such that it unmarshals a JSON byte slice from the database into the struct fields.</p></li>
</ul>

<p>Here's a demonstration:</p>

<figure class="file"><code class="go"><pre>
package main

import (
    "database/sql"
    "database/sql/driver"
    "encoding/json"
    "errors"
    "log"

    _ "github.com/lib/pq"
)

type Item struct {
    ID    int
    Attrs Attrs
}

// The Attrs struct represents the data in the JSON/JSONB column. We can use
// struct tags to control how each field is encoded.
type Attrs struct {
    Name        string   `json:"name,omitempty"`
    Ingredients []string `json:"ingredients,omitempty"`
    Organic     bool     `json:"organic,omitempty"`
    Dimensions  struct {
        Weight float64 `json:"weight,omitempty"`
    } `json:"dimensions,omitempty"`
}

// Make the Attrs struct implement the driver.Valuer interface. This method
// simply returns the JSON-encoded representation of the struct.
func (a Attrs) Value() (driver.Value, error) {
    return json.Marshal(a)
}

// Make the Attrs struct implement the sql.Scanner interface. This method
// simply decodes a JSON-encoded value into the struct fields.
func (a *Attrs) Scan(value interface{}) error {
    b, ok := value.([]byte)
    if !ok {
        return errors.New("type assertion to []byte failed")
    }

    return json.Unmarshal(b, &amp;a)
}

func main() {
    db, err := sql.Open("postgres", "postgres://user:pass@localhost/db")
    if err != nil {
        log.Fatal(err)
    }

    // Initialize a new Attrs struct and add some values.
    attrs := new(Attrs)
    attrs.Name = "Pesto"
    attrs.Ingredients = []string{"Basil", "Garlic", "Parmesan", "Pine nuts", "Olive oil"}
    attrs.Organic = false
    attrs.Dimensions.Weight = 100.00

    // The database driver will call the Value() method and and marshall the
    // attrs struct to JSON before the INSERT.
    _, err = db.Exec("INSERT INTO items (attrs) VALUES($1)", attrs)
    if err != nil {
        log.Fatal(err)
    }

    // Similarly, we can also fetch data from the database, and the driver
    // will call the Scan() method to unmarshal the data to an Attr struct.
    item := new(Item)
    err = db.QueryRow("SELECT id, attrs FROM items ORDER BY id DESC LIMIT 1").Scan(&amp;item.ID, &amp;item.Attrs)
    if err != nil {
        log.Fatal(err)
    }

    // You can then use the struct fields as normal...
    weightKg := item.Attrs.Dimensions.Weight / 1000
    log.Printf("Item: %d, Name: %s, Weight: %.2fkg", item.ID, item.Attrs.Name, weightKg)
}
</pre></code></figure>

<h3 id="unknownjsonfields">Unknown JSON fields</h3>

<p>The above pattern works great if you know in advance what keys and values your JSON/JSONB data will contain. And it has the major advantage of being <em>type safe</em>.</p>

<p>For the times that you don't know this in advance (for example, the data contains user-generated keys and values) you can map the contents of the JSON/JSONB column to and from a <code>map[string]interface{}</code> instead. The big downside of this is that you will need to type assert any values that you retrieve from the database in order to use them.</p>

<p>Here's the same example, but re-written to use a <code>map[string]interface{}</code>:</p>

<figure class="file"><code class="go"><pre>
package main

import (
    "database/sql"
    "database/sql/driver"
    "encoding/json"
    "errors"
    "log"

    _ "github.com/lib/pq"
)

type Item struct {
    ID    int
    Attrs Attrs
}

type Attrs map[string]interface{}

func (a Attrs) Value() (driver.Value, error) {
    return json.Marshal(a)
}

func (a *Attrs) Scan(value interface{}) error {
    b, ok := value.([]byte)
    if !ok {
        return errors.New("type assertion to []byte failed")
    }

    return json.Unmarshal(b, &amp;a)
}

func main() {
    db, err := sql.Open("postgres", "postgres://user:pass@localhost/db")
    if err != nil {
        log.Fatal(err)
    }

    item := new(Item)
    item.Attrs = Attrs{
        "name":        "Passata",
        "ingredients": []string{"Tomatoes", "Onion", "Olive oil", "Garlic"},
        "organic":     true,
        "dimensions": map[string]interface{}{
            "weight": 250.00,
        },
    }

    _, err = db.Exec("INSERT INTO items (attrs) VALUES($1)", item.Attrs)
    if err != nil {
        log.Fatal(err)
    }

    item = new(Item)
    err = db.QueryRow("SELECT id, attrs FROM items ORDER BY id DESC LIMIT 1").Scan(&amp;item.ID, &amp;item.Attrs)
    if err != nil {
        log.Fatal(err)
    }

    name, ok := item.Attrs["name"].(string)
    if !ok {
        log.Fatal("unexpected type for name")
    }
    dimensions, ok := item.Attrs["dimensions"].(map[string]interface{})
    if !ok {
        log.Fatal("unexpected type for dimensions")
    }
    weight, ok := dimensions["weight"].(float64)
    if !ok {
        log.Fatal("unexpected type for weight")
    }
    weightKg := weight / 1000
    log.Printf("%s: %.2fkg", name, weightKg)
}
</pre></code></figure>
    ]]></description>
  </item>
  <item>
    <pubDate>Mon, 15 Apr 2019 18:00:00 GMT</pubDate>
    <link>https://www.alexedwards.net/blog/an-overview-of-go-tooling</link>
    <guid>https://www.alexedwards.net/blog/an-overview-of-go-tooling</guid>
    <title>An Overview of Go's Tooling</title>
    <description><![CDATA[
<p>Occasionally I get asked <em>&ldquo;why do you like using Go?&rdquo;</em> And one of the things I often mention is the thoughtful tooling that exists alongside the language as part of the <code>go</code> command. There are some tools that I use everyday &mdash; like <code>go fmt</code> and <code>go build</code> &mdash; and others like <code>go tool pprof</code> that I only use to help solve a specific issue. But in all cases I appreciate the fact that they make managing and maintaining my projects easier.</p>

<p>In this post I hope to provide a little background and context about the tools I find most useful, and importantly, explain how they can fit into the workflow of a typical project. I hope it'll give you a good start if you're new to Go.</p>

<p>Or if you've been working with Go for a while, and that stuff's not applicable to you, hopefully you'll still discover a command or flag that you didn't know existed before : )</p>

<p>The information in this post is written for Go 1.12 and assumes that you're working on a project which has <a href="https://github.com/golang/go/wiki/Modules#quick-start">modules enabled</a>.</p>

<ol class="toc">
<li><strong><a href="#installing-tooling">Installing Tooling</a></strong></li>
<li><strong><a href="#viewing-environment-information">Viewing Environment Information</a></strong></li>
<li><strong><a href="#development">Development</a></strong></li>
<ul>
<li><a href="#running-code">Running Code</a></li>
<li><a href="#fetching-dependencies">Fetching Dependencies</a></li>
<li><a href="#refactoring-code">Refactoring Code</a></li>
<li><a href="#viewing-go-documentation">Viewing Go Documentation</a></li>
</ul></li>
<li><strong><a href="#testing">Testing</a></strong></li>
<ul>
<li><a href="#running-tests">Running Tests</a></li>
<li><a href="#profiling-test-coverage">Profiling Test Coverage</a></li>
<li><a href="#stress-testing">Stress Testing</a></li>
<li><a href="#testing-all-dependencies">Testing all Dependencies</a></li>
</ul></li>
<li><strong><a href="#pre-commit-checks">Pre-Commit Checks</a></strong></li>
<ul>
<li><a href="#formatting-code">Formatting Code</a></li>
<li><a href="#performing-static-analysis">Performing Static Analysis</a></li>
<li><a href="#linting-code">Linting Code</a></li>
<li><a href="#tidying-and-verifying-your-dependencies">Tidying and Verifying your Dependencies</a></li>
</ul></li>
<li><strong><a href="#build-and-deployment">Build and Deployment</a></strong></li>
<ul>
<li><a href="#building-an-executable">Building an Executable</a></li>
<li><a href="#cross-compilation">Cross-Compilation</a></li>
<li><a href="#using-compiler-and-linker-flags">Using Compiler and Linker Flags</a></li>
</ul></li>
<li><strong><a href="#diagnosing-problems-and-making-optimizations">Diagnosing Problems and Making Optimizations</a></strong></li>
<ul>
<li><a href="#running-and-comparing-benchmarks">Running and Comparing Benchmarks</a></li>
<li><a href="#profiling-and-tracing">Profiling and Tracing</a></li>
<li><a href="#checking-for-race-conditions">Checking for Race Conditions</a></li>
</ul></li>
<li><strong><a href="#managing-dependencies">Managing Dependencies</a></strong></li>
<li><strong><a href="#upgrading-to-a-new-go-release">Upgrading to a New Go Release</a></strong></li>
<li><strong><a href="#reporting-bugs">Reporting Bugs</a></strong></li>
</ol>

<h2 id="installing-tooling">Installing Tooling</h2>

<p>In this post I'll mainly be focusing on tools that are a part of the <code>go</code> command. But there are a few I'll be mentioning which aren't part of the standard Go 1.12 release.</p>

<p>To install these while using Go 1.12 you'll first need to make sure that you're <em>outside</em> of a module-enabled directory (I usually just change into <code>/tmp</code>). Then you can use the <code>GO111MODULE=on go get</code> command to install the tool. For example:</p>

<figure class="shell"><code><pre>
$ cd /tmp
$ GO111MODULE=on go get golang.org/x/tools/cmd/stress
</pre></code></figure>

<p>This will download the relevant package and dependencies, build the executable and add it to your <code>GOBIN</code> directory. If you haven't explicitly set a <code>GOBIN</code> directory, then the executable will be added to your <code>GOPATH/bin</code> folder. Either way, you should make sure that the appropriate directory is on your system path.</p>

<p>Note: This process is a bit clunky and will hopefully improve in future versions of Go. <a href="https://github.com/golang/go/issues/30515">Issue 30515</a> is tracking the discussion about this.</p>

<h2 id="viewing-environment-information">Viewing Environment Information</h2>

<p>You can use the <code>go env</code> tool to display information about your current Go operating environment. This can be particularly useful if you're working on an unfamiliar machine.</p>

<figure class="shell"><code><pre>
$ go env
<samp>GOARCH="amd64"
GOBIN=""
GOCACHE="/home/alex/.cache/go-build"
GOEXE=""
GOFLAGS=""
GOHOSTARCH="amd64"
GOHOSTOS="linux"
GOOS="linux"
GOPATH="/home/alex/go"
GOPROXY=""
GORACE=""
GOROOT="/usr/local/go"
GOTMPDIR=""
GOTOOLDIR="/usr/local/go/pkg/tool/linux_amd64"
GCCGO="gccgo"
CC="gcc"
CXX="g++"
CGO_ENABLED="1"
GOMOD=""
CGO_CFLAGS="-g -O2"
CGO_CPPFLAGS=""
CGO_CXXFLAGS="-g -O2"
CGO_FFLAGS="-g -O2"
CGO_LDFLAGS="-g -O2"
PKG_CONFIG="pkg-config"
GOGCCFLAGS="-fPIC -m64 -pthread -fmessage-length=0 -fdebug-prefix-map=/tmp/go-build245740092=/tmp/go-build -gno-record-gcc-switches"</samp>
</pre></code></figure>

<p>If there are specific values that you're interested in, you can pass them as arguments to <code>go env</code>. For example:</p>

<figure class="shell"><code><pre>
$ go env GOPATH GOOS GOARCH
<samp>/home/alex/go
linux
amd64</samp>
</pre></code></figure>

<p>To show documentation for all <code>go env</code> variables and values you can run:</p>
<figure class="shell"><code><pre>
$ go help environment
</pre></code></figure>

<h2 id="development">Development</h2>

<h3 id="running-code">Running Code</h3>

<p>During development the <code>go run</code> tool is a convenient way to try out your code. It's essentially a shortcut that compiles your code, creates an executable binary in your <code>/tmp</code> directory, and then runs this binary in one step.</p>

<figure class="shell"><code><pre>
$ go run .          # Run the package in the current directory
$ go run ./cmd/foo  # Run the package in the ./cmd/foo directory
</pre></code></figure>

<p>Note: As of Go 1.11 you can pass the <a href="https://golang.org/doc/go1.11#run">path of a package</a> to <code>go run</code>, like we have above. This means that you no longer have to use workarounds like <code>go run *.go</code> wildcard expansion to run multiple files. I like this improvement a lot!</p>

<h3 id="fetching-dependencies">Fetching Dependencies</h3>

<p>Assuming that you've got <a href="https://github.com/golang/go/wiki/Modules#quick-start">modules enabled</a>, when you use <code>go run</code> (or <code>go test</code> or <code>go build</code> for that matter) any external dependencies will automatically (and recursively) be downloaded to fulfill the <code>import</code> statements in your code. By default the latest tagged release of the dependency will be downloaded, or if no tagged releases are available, then the dependency at the latest commit.</p>

<p>If you know in advance that you need a specific version of a dependency (instead of the one that Go would fetch by default) you can use <code>go get</code> with the relevant version number or commit hash. For example:</p>

<figure class="shell"><code><pre>
$ go get github.com/foo/bar@v1.2.3
$ go get github.com/foo/bar@8e1b8d3
</pre></code></figure>

<p>If the dependency being fetched has a <code>go.mod</code> file, then <em>its dependencies</em> won't be listed in <em>your</em> <code>go.mod</code> file. In contrast, if the dependency you're downloading doesn't have a <code>go.mod</code> file, then it's dependencies <em>will</em> be listed in your <code>go.mod</code> file with an <code>// indirect</code> comment next to them.</p>

<p>So that means your <code>go.mod</code> file doesn't necessarily show all the dependencies for your project in one place. Instead, you can view them all using the <code>go list</code> tool like so:</p>

<figure class="shell"><code><pre>
$ go list -m all
</pre></code></figure>

<p>Sometimes you might wonder <em>why is <u>that</u> a dependency?</em> You can answer this with the <code>go mod why</code> command, which will show you the shortest path from a package in your main module to a given dependency. For example:</p>

<figure class="shell"><code><pre>
$ go mod why -m golang.org/x/sys
<samp># golang.org/x/sys
github.com/alexedwards/argon2id
golang.org/x/crypto/argon2
golang.org/x/sys/cpu</samp>
</pre></code></figure>

<p>Note: The <code>go mod why</code> command will return an answer for most, but not all, dependencies. <a href="https://github.com/golang/go/issues/27900">Issue 27900</a> is tracking this.</p>

<p>If you're interested in analyzing or visualizing the dependencies for your application, then you might want to also check out the <code>go mod graph</code> tool. There's a great tutorial and example code for generating visualizations <a href="https://github.com/go-modules-by-example/index/tree/master/018_go_list_mod_graph_why">here</a>.</p>

<p>Lastly, downloaded dependencies are stored in the <em>module cache</em> located at <code>GOPATH/pkg/mod</code>. If you ever need to clear the module cache you can use the <code>go clean</code> tool. But be aware: this will remove the downloaded dependencies for <em>all projects</em> on your machine.</p>

<figure class="shell"><code><pre>
$ go clean -modcache
</pre></code></figure>

<h3 id="refactoring-code">Refactoring Code</h3>

<p>Chances are you're probably familiar with using the <code>gofmt</code> tool to automatically format your code. But it also supports <em>rewrite rules</em> that you can use to help refactor your code. I'll demonstrate.</p>

<p>Let's say that you have the following code and you want to change the <code>foo</code> variable to <code>Foo</code> so it is exported.</p>

<figure class="file"><code><pre>var foo int

func bar() {
    foo = 1
	fmt.Println(&#34;foo&#34;)
}
</pre></code></figure>

<p>To do this you can use <code>gofmt</code>  with the <code>-r</code> flag to implement a rewrite rule, the <code>-d</code> flag to display a diff of the changes, and the <code>-w</code> flag to make the changes <em>in place</em>,  like so:</p>

<figure class="shell"><code><pre>
$ gofmt -d -w -r &#39;foo -&gt; Foo&#39; .
<samp>-var foo int
+var Foo int

 func bar() {
-	foo = 1
+	Foo = 1
 	fmt.Println(&#34;foo&#34;)
 }</samp>
</pre></code></figure>

<p>Notice how this is smarter than a find-and-replace? The <code>foo</code> variable has been changed, but the <code>&quot;foo&quot;</code> string in the <code>fmt.Println()</code> statement has been left unchanged. Another thing to note is that the <code>gofmt</code> command works recursively, so the above command will run on all <code>*.go</code> files in your current directory and subdirectories.</p>

<p>If you want to use this functionality, I recommend running rewrite rules <em>without</em> the <code>-w</code> flag first, and checking the diff first to make sure that the changes to the code are what you expect.</p>

<p>Let's take a look at a slightly more complicated example. Say you want to update your code to use the new Go 1.12 <a href="https://golang.org/pkg/strings/#ReplaceAll">strings.ReplaceAll()</a> function instead of <a href="https://golang.org/pkg/strings/#Replace">strings.Replace()</a>. To make this change you can run:</p>

<figure class="shell"><code><pre>
$ gofmt -w -r &#39;strings.Replace(a, b, c, -1) -&gt; strings.ReplaceAll(a, b, c)&#39; .
</pre></code></figure>

<p>In rewrite rules, single lowercase characters act as wildcards matching arbitrary expressions, and those expressions will be substituted-in in the replacement.</p>

<h3 id="viewing-go-documentation">Viewing Go Documentation</h3>

<p>You can view documentation for the standard library packages via your terminal using the <code>go doc</code> tool. I often use this during development to quickly check something &mdash; like the name or signature of a specific function. I find it faster than navigating the <a href="https://golang.org/pkg">web-based documentation</a> and it's always available offline too.</p>

<figure class="shell"><code><pre>
$ go doc strings            # View simplified documentation for the strings package
$ go doc -all strings       # View full documentation for the strings package
$ go doc strings.Replace    # View documentation for the strings.Replace function
$ go doc sql.DB             # View documentation for the database/sql.DB type
$ go doc sql.DB.Query       # View documentation for the database/sql.DB.Query method
</pre></code></figure>

<p>You can also include the <code>-src</code> flag to display the relevant Go source code. For example:</p>

<figure class="shell"><code><pre>
$ go doc -src strings.Replace   # View the source code for the strings.Replace function
</pre></code></figure>

<h2 id="testing">Testing</h2>

<h3 id="running-tests">Running Tests</h3>

<p>You can use the <code>go test</code> tool to run tests in your project like so:</p>

<figure class="shell"><code><pre>
$ go test .          # Run all tests in the current directory
$ go test ./...      # Run all tests in the current directory and sub-directories
$ go test ./foo/bar  # Run all tests in the ./foo/bar directory
</pre></code></figure>

<p>Typically I run my tests with  Go's <a href="https://golang.org/doc/articles/race_detector.html">race detector</a> enabled, which can help pick up <em>some</em> of the data races that might occur in real-life usage. Like so:</p>

<figure class="shell"><code><pre>
$ go test -race ./...
</pre></code></figure>

<p>It's important to note that enabling the race detector will increase the overall running time of your tests. So if you're running tests very frequently part of a TDD workflow, you might prefer to save using this for a pre-commit test run only.</p>

<p>Since 1.10, Go <a href="https://golang.org/doc/go1.10#test">caches test results</a> at the package-level. If a package hasn't changed between test runs &mdash; and you're using the same, cachable, flags for <code>go test</code> &mdash; then the cached test result will be displayed with a <code>&quot;(cached)&quot;</code> next to it. This is hugely helpful in speeding up the test runtime for large codebases. If you want force your tests to run in full (and avoid the cache) you can use the <code>-count=1</code> flag, or clear all cached test results by using the <code>go clean</code> tool.</p>

<figure class="shell"><code><pre>
$ go test -count=1 ./...    # Bypass the test cache when running tests
$ go clean -testcache       # Delete all cached test results
</pre></code></figure>

<p>Note: Cached test results are stored alongside cached build results in your <code>GOCACHE</code> directory. Check <code>go env GOCACHE</code> if you're not sure where this is on your machine.</p>

<p>You can limit <code>go test</code> to running specific tests (and sub-tests) by using the <code>-run</code>  flag. This accepts a regular expression, and only tests which have names that match the regular expression will be run. I like to combine this with the <code>-v</code> flag to enable verbose mode, so the names of running tests and sub-tests are displayed. It's a useful way to make sure that I haven't screwed up the regexp and that the tests I expect are actually being run!</p>

<figure class="shell"><code><pre>
$ go test -v -run=^TestFooBar$ .          # Run the test with the exact name TestFooBar
$ go test -v -run=^TestFoo .              # Run tests whose names start with TestFoo
$ go test -v -run=^TestFooBar$/^Baz$ .    # Run the Baz subtest of the TestFooBar test only
</pre></code></figure>

<p>A couple more flags that it's good to be aware of are <code>-short</code> (which you can use to <a href="https://golang.org/pkg/testing/#hdr-Skipping">skip long-running tests</a>) and <code>-failfast</code> (which will stop running further tests after the first failure). Note that <code>-failfast</code> will prevent test results from being cached.</p>

<figure class="shell"><code><pre>
$ go test -short ./...      # Skip long running tests
$ go test -failfast ./...   # Don&#39;t run further tests after a failure.
</pre></code></figure>

<h3 id="profiling-test-coverage">Profiling Test Coverage</h3>

<p>You can enable coverage analysis when running tests by using the <code>-cover</code> flag. This will display the percentage of code covered by the tests in the output for each package, similar to this:</p>

<figure class="shell"><code><pre>
$ go test -cover ./...
<samp>ok  	github.com/alexedwards/argon2id	0.467s	coverage: 78.6% of statements</samp>
</pre></code></figure>

<p>You can also generate a <em>coverage profile</em> using the <code>-coverprofile</code> flag and view it in your web browser by using the <code>go tool cover -html</code> command like so:</p>

<figure class="shell"><code><pre>
$ go test -coverprofile=/tmp/profile.out ./...
$ go tool cover -html=/tmp/profile.out
</pre></code></figure>

<p><img src="/static/images/tooling-1.png"></p>

<p>This will gives you a navigable listing of all the test files, with code covered by the tests displayed in green, and uncovered code in red.</p>

<p>If you want you can go a step further and set the <code>-covermode=count</code> flag to make the coverage profile record the exact <em>number of times</em> that each statement is executed during the tests.</p>

<figure class="shell"><code><pre>
$ go test -covermode=count -coverprofile=/tmp/profile.out ./...
$ go tool cover -html=/tmp/profile.out
</pre></code></figure>

<p>When viewed in the browser, statements which are executed more frequently are shown in a more saturated shade of green, similar to this:</p>

<p><img src="/static/images/tooling-2.png"></p>

<p>Note: If you’re using the <code>t.Parallel()</code> command in any of your tests, then you should use the flag <code>-covermode=atomic</code> instead of <code>-covermode=count</code> instead to ensure an accurate count.</p>

<p>Lastly, if you don't have a web browser available to view a coverage profile, you can see a breakdown of test coverage by function/method in your terminal with the command:</p>

<figure class="shell"><code><pre>
$ go tool cover -func=/tmp/profile.out
<samp>github.com/alexedwards/argon2id/argon2id.go:77:		CreateHash		87.5%
github.com/alexedwards/argon2id/argon2id.go:96:		ComparePasswordAndHash	85.7%
...</samp>
</pre></code></figure>

<h3 id="stress-testing">Stress Testing</h3>

<p>You can use the <code>go test -count</code> command to run a test multiple times in succession, which can be useful if you want to check for sporadic or intermittent failures. For example:</p>

<figure class="shell"><code><pre>
$ go test -run=^TestFooBar$ -count=500 .
</pre></code></figure>

<p>In this example, the <code>TestFooBar</code> test will be repeated 500 times in a row. But it's important to note that the test will be repeated <em>in serial</em> &mdash; even if it contains a <code>t.Parallel()</code> instruction. So if your test is doing something relatively slow, like making a round trip to a database, hard disk or the internet, running a large number of tests can take quite a long time.</p>

<p>In that case you might want to use the <a href="golang.org/x/tools/cmd/stress"><code>stress</code></a> tool to repeat the same test multiple times <em>in parallel</em> instead. You can install it like so:</p>

<figure class="shell"><code><pre>
$ cd /tmp
$ GO111MODULE=on go get golang.org/x/tools/cmd/stress
</pre></code></figure>

<p>To use the <code>stress</code> tool, you'll first need to compile a <em>test binary</em> for the specific package you want to test. You can do using the <code>go test -c</code> command. For example, to create a test binary for the package in your current directory:</p>

<figure class="shell"><code><pre>
$ go test -c -o=/tmp/foo.test .
</pre></code></figure>

<p>In this example, the test binary will be outputted to <code>/tmp/foo.test</code>. You can then use the <code>stress</code> tool to execute a specific test in the test binary like so:</p>

<figure class="shell"><code><pre>
$ stress -p=4 /tmp/foo.test -test.run=^TestFooBar$
<samp>60 runs so far, 0 failures
120 runs so far, 0 failures
...</samp>
</pre></code></figure>

<p>Note: In the example above I've used the <code>-p</code> flag to restrict the number of parallel processes used by <code>stress</code> to 4. Without this flag, the tool will default to using a number of processes equal to <code>runtime.NumCPU()</code>.</p>

<h3 id="testing-all-dependencies">Testing all Dependencies</h3>

<p>Before you build an executable for release or deployment, or distribute your code publicly, you may want to run the <code>go test all</code> command:</p>

<figure class="shell"><code><pre>
$ go test all
</pre></code></figure>

<p>This will run tests on all packages in your module and all dependencies &mdash; include testing <em>test dependencies</em> and the necessary <em>standard library packages</em> &mdash; and it can help validate that the exact versions of the dependencies being used are compatible with each other. This can take quite a long time to run, but the results cache well so any subsequent tests should be faster in the future. If you want, you could also use <code>go test -short all</code> to skip any long-running tests.</p>

<h2 id="pre-commit-checks">Pre-Commit Checks</h2>

<h3 id="formatting-code">Formatting Code</h3>

<p>Go provides two tools to automatically format your code according to the Go conventions: <code>gofmt</code> and <code>go fmt</code>. Using these helps keep your code consistent across your files and projects, and &mdash; if you use them before committing code &mdash; helps reduce noise when examining a diff between file versions.</p>

<p>I like to use the <code>gofmt</code> tool with the following flags:</p>

<figure class="shell"><code><pre>
$ gofmt -w -s -d foo.go  # Format the foo.go file
$ gofmt -w -s -d .       # Recursively format all files in the current directory and sub-directories
</pre></code></figure>

<p>In these commands, the <code>-w</code> flag instructs the tool to rewrite files in place, the <code>-s</code> instructs the tool to apply <a href="https://golang.org/cmd/gofmt/#hdr-The_simplify_command">simplifications</a> to the code where possible, and the <code>-d</code> flag instructs the tool to output diffs of the changes (because I'm curious to see what is changed). If you want to only display the names of changed files, instead of diffs, you can swap this for the <code>-l</code> flag instead.</p>

<p>Note: The <code>gofmt</code> command works recursively. If you pass it a directory like <code>.</code> or <code>./cmd/foo</code> it'll format all <code>.go</code> files under the directory.</p>

<p>The other formatting tool &mdash; <code>go fmt</code> &mdash; tool is a wrapper which essentially calls <code>gofmt -l -w</code> on a specified file or directory. You can use it like this:</p>

<figure class="shell"><code><pre>
$ go fmt ./...
</pre></code></figure>

<h3 id="performing-static-analysis">Performing Static Analysis</h3>

<p>The <code>go vet</code> tool carries out static analysis of your code and warns you of things which <em>might</em> be wrong with your code but wouldn't be picked up by the compiler. Issues like unreachable code, unnecessary assignments and badly-formed build tags. You can use it like so:</p>

<figure class="shell"><code><pre>
$ go vet foo.go     # Vet the foo.go file
$ go vet .          # Vet all files in the current directory
$ go vet ./...      # Vet all files in the current directory and sub-directories
$ go vet ./foo/bar  # Vet all files in the ./foo/bar directory
</pre></code></figure>

<p>Behind the scenes, <code>go vet</code> runs a bunch of different analyzers which are <a href="https://golang.org/cmd/vet/">listed here</a> and you can disable specific ones on a case-by-case basis. For example to disable the <code>composite</code> analyzer you can use:</p>

<figure class="shell"><code><pre>
$ go vet -composites=false ./...
</pre></code></figure>

<p>There are a couple of experimental analyzers in <a href="https://godoc.org/golang.org/x/tools">golang.org/x/tools</a> which you might want to try: <a href="https://godoc.org/golang.org/x/tools/go/analysis/passes/nilness/cmd/nilness">nilness</a> (which checks for redundant or impossible nil comparisons) and <a href="https://godoc.org/golang.org/x/tools/go/analysis/passes/shadow/cmd/shadow">shadow</a> (which check for possible unintended shadowing of variables). If you want to use these, you'll need to install and run them separately. For example, to install <code>nilness</code> you would run:</p>

<figure class="shell"><code><pre>
$ cd /tmp
$ GO111MODULE=on go get golang.org/x/tools/go/analysis/passes/nilness/cmd/nilness
</pre></code></figure>

<p>And you can then use it like so:</p>

<figure class="shell"><code><pre>
$ go vet -vettool=$(which nilness) ./...
</pre></code></figure>

<p>Note: when the <code>-vettool</code>  flag is used it will <em>only</em> run the specified analyzer &mdash; all the other <code>go vet</code> analyzers won't be run.</p>

<p>As a side note, since Go 1.10 the <code>go test</code> tool automatically executes a small, high-confidence, subset of the <code>go vet</code> checks before running any tests. You can turn this behavior off when running tests like so:</p>

<figure class="shell"><code><pre>
$ go test -vet=off ./...
</pre></code></figure>

<h3 id="linting-code">Linting Code</h3>

<p>You can use the <code>golint</code> tool to identify <em>style mistakes</em> in your code. Unlike <code>go vet</code>, this isn't concerned with <em>correctness</em> of the code, but helps you to align your code with the style conventions in <a href="https://golang.org/doc/effective_go.html">Effective Go</a> and the Go <a href="https://golang.org/wiki/CodeReviewComments">CodeReviewComments</a>.</p>

<p>It's not part of the standard library, so you'll need to install it like so:</p>

<figure class="shell"><code><pre>
$ cd /tmp
$ GO111MODULE=on go get golang.org/x/lint/golint
</pre></code></figure>

<p>You can then run it as follows:</p>

<figure class="shell"><code><pre>
$ golint foo.go     # Lint the foo.go file
$ golint .          # Lint all files in the current directory
$ golint ./...      # Lint all files in the current directory and sub-directories
$ golint ./foo/bar  # Lint all files in the ./foo/bar directory
</pre></code></figure>

<h3 id="tidying-and-verifying-your-dependencies">Tidying and Verifying your Dependencies</h3>

<p>Before you commit any changes to your code I recommend running the following two commands to tidy and verify your dependencies:</p>

<figure class="shell"><code><pre>
$ go mod tidy
$ go mod verify
</pre></code></figure>

<p>The <code>go mod tidy</code> command will prune any unused dependencies from your <code>go.mod</code> and <code>go.sum</code> files, and update the files to include dependencies for all possible build tags/OS/architecture combinations (note: <code>go run</code>, <code>go test</code>, <code>go build</code> etc are &lsquo;lazy' and will only fetch packages needed for the current build tags/OS/architecture). Running this before each commit will make it easier to determine which of your code changes were responsible for adding or removing which dependencies when looking at the version control history.</p>

<p>I also recommend using the <code>go mod verify</code> command to check that the dependencies on your computer haven't accidentally (or purposely) been changed since they were downloaded and that they match the cryptographic hashes in your <code>go.sum</code> file. Running this helps ensure that the dependencies being used are the exact ones that you expect, and  any build for that commit will be reproducible at a later point.</p>

<h2 id="build-and-deployment">Build and Deployment</h2>

<h3 id="building-an-executable">Building an Executable</h3>

<p>To compile a <code>main</code> package and create an executable binary you can use the <code>go build</code> tool. Typically I use it in conjunction with the <code>-o</code> flag, which let's you explicitly set the output directory and name of the binary like so:</p>

<figure class="shell"><code><pre>
$ go build -o=/tmp/foo .            # Compile the package in the current directory
$ go build -o=/tmp/foo ./cmd/foo    # Compile the package in the ./cmd/foo directory
</pre></code></figure>

<p>In these examples, <code>go build</code> will <em>compile</em> the specified package (and any dependent packages), then invoke the <em>linker</em> to generate an executable binary, and output this to <code>/tmp/foo</code>.</p>

<p>It's important to note that, as of Go 1.10, the <code>go build</code> tool caches build output in the <em><a href="https://golang.org/cmd/go/#hdr-Build_and_test_caching">build cache</a></em>. This cached output will be reused again in future builds where appropriate, which can significantly speed up the overall build time. This new caching behavior means that the <a href="https://peter.bourgon.org/go-best-practices-2016/#build-and-deploy">old maxim</a> of &ldquo;prefer <code>go install</code> to <code>go build</code> to improve caching&rdquo; no longer applies.</p>

<p>If you're not sure where your build cache is, you can check by running the <code>go env GOCACHE</code> command:</p>

<figure class="shell"><code><pre>
$ go env GOCACHE
<samp>/home/alex/.cache/go-build</samp>
</pre></code></figure>

<p>Using the build cache comes with one <a href="https://golang.org/pkg/cmd/go/internal/help/">important caveat</a> &mdash; it does not detect changes to C libraries imported with <code>cgo</code>. So if your code imports a C library via <code>cgo</code> and you've made changes to it since the last build, you'll need to use the <code>-a</code> flag which forces all packages to be rebuilt. Alternatively, you could use <code>go clean</code> to purge the cache:</p>

<figure class="shell"><code><pre>
$ go build -a -o=/tmp/foo .     # Force all packages to be rebuilt
$ go clean -cache               # Remove everything from the build cache
</pre></code></figure>

<p>Note: Running <code>go clean -cache</code> will delete cached test results too.</p>

<p>If you're interested in what <code>go build</code> is doing behind the scenes, you might like to use the following commands:</p>

<figure class="shell"><code><pre>
$ go list -deps . | sort -u     # List all packages that are used to build the executable
$ go build -a -x -o=/tmp/foo .  # Rebuild everything and show the commands that are run
</pre></code></figure>

<p>Finally, if you run <code>go build</code> on a non-<code>main</code> package, it will be compiled in a temporary location and again, the result will be stored in the build cache. No executable is produced.</p>

<h3 id="cross-compilation">Cross-Compilation</h3>

<p>This is one of my favorite features of Go.</p>

<p>By default <code>go build</code> will output a binary suitable for use on your current operating system and architecture. But it also supports cross-compilation, so you can generate a binary suitable for use on a different machine. This is particularly useful if you're developing on one operating system and deploying on another.</p>

<p>You can specify the operating system and architecture that you want to create the binary for by setting the <code>GOOS</code> and <code>GOARCH</code> environment variables respectively. For example:</p>

<figure class="shell"><code><pre>
$ GOOS=linux GOARCH=amd64 go build -o=/tmp/linux_amd64/foo .
$ GOOS=windows GOARCH=amd64 go build -o=/tmp/windows_amd64/foo.exe .
</pre></code></figure>

<p>To see a list of all supported OS/architecture combinations you can run <code>go tool dist list</code>:</p>

<figure class="shell"><code><pre>
$ go tool dist list
<samp>aix/ppc64
android/386
android/amd64
android/arm
android/arm64
darwin/386
darwin/amd64
...</samp>
</pre></code></figure>

<p>Hint: You can use Go's cross-compilation to <a href="https://github.com/golang/go/wiki/WebAssembly">create WebAssembly binaries</a>.</p>

<p>For a bit more in-depth information about cross compilation I recommend reading <a href="https://rakyll.org/cross-compilation/">this excellent post</a>.</p>

<h3 id="using-compiler-and-linker-flags">Using Compiler and Linker Flags</h3>

<p>When building your executable you can use the <code>-gcflags</code> flag to change the behavior of the compiler and see more information about what it's doing. You can see a complete list of available compiler flags by running:</p>

<figure class="shell"><code><pre>
$ go tool compile -help
</pre></code></figure>

<p>One flag that you might find interesting is <code>-m</code>, which triggers the printing of information about optimization decisions made during compilation. You can use it like this:</p>

<figure class="shell"><code><pre>
$ go build -gcflags="-m -m" -o=/tmp/foo . # Print information about optimization decisions
</pre></code></figure>

<p>In the above example I used the <code>-m</code> flag twice to indicate that I want to print decision information two-levels deep. You can get simpler output by using just one.

<p>Also, as of Go 1.10, compiler flags only apply to the specific packages passed to <code>go build</code> &mdash; which in the example above is the package in the current directory (represented by <code>.</code>). If you want to print optimization decisions for all packages including dependencies can use this command instead:</p>

<figure class="shell"><code><pre>
$ go build -gcflags="all=-m" -o=/tmp/foo .
</pre></code></figure>

<p>As of Go 1.11, you should find it <a href="https://golang.org/doc/go1.11#debugging">easier to debug optimized binaries</a> than before. However, you can still use the flags <code>-N</code> to disable optimizations and <code>-l</code> to disable inlining if you need to. For example:</p>

<figure class="shell"><code><pre>
$ go build -gcflags="all=-N -l" -o=/tmp/foo .  # Disable optimizations and inlining
</pre></code></figure>

<p>You can see a list of available linker flags by running:</p>

<figure class="shell"><code><pre>
$ go tool link -help
</pre></code></figure>

<p>Probably the most well-known of these is the <code>-X</code> flag, which allows you to "burn in" a (string) value to a specific variable in your application. This is commonly used to <a href="https://blog.alexellis.io/inject-build-time-vars-golang/">add a version number or commit hash</a>. For example:</p>

<figure class="shell"><code><pre>
$ go build -ldflags="-X main.version=1.2.3" -o=/tmp/foo .
</pre></code></figure>

<p>For more information about the <code>-X</code> flag and some sample code see <a href="">this StackOverflow question</a> and this post and <a href="https://blog.alexellis.io/inject-build-time-vars-golang/">this post</a>.</p>

<p>You may also be interested in using the <code>-s</code> and <code>-w</code> flags to strip debugging information from the binary. This typically shaves about 25% off the final size. For example:</p>

<figure class="shell"><code><pre>
$ go build -ldflags="-s -w" -o=/tmp/foo .  # Strip debug information from the binary
</pre></code></figure>

<p>Note: If binary size is something that you need to optimize for you might want to use <a href="https://upx.github.io/">upx</a> to compress it. See <a href="https://blog.filippo.io/shrink-your-go-binaries-with-this-one-weird-trick/">this post</a> for more information.</p>


<h2 id="diagnosing-problems-and-making-optimizations">Diagnosing Problems and Making Optimizations</h2>

<h3 id="running-and-comparing-benchmarks">Running and Comparing Benchmarks</h3>

<p>A nice feature of Go is that it makes it easy to benchmark your code. If you're not familiar with the general process for writing benchmarks there are good guides <a href="https://dave.cheney.net/2013/06/30/how-to-write-benchmarks-in-go">here</a> and <a href="https://dave.cheney.net/2013/06/30/how-to-write-benchmarks-in-go">here</a>.</p>

<p>To run benchmarks you'll need to use the <code>go test</code> tool, with the <code>-bench</code> flag set to a regular expression that matches the benchmarks you want to execute. For example:</p>

<figure class="shell"><code><pre>
$ go test -bench=. ./...                        # Run all benchmarks and tests
$ go test -run=^$ -bench=. ./...                # Run all benchmarks (and no tests)
$ go test -run=^$ -bench=^BenchmarkFoo$ ./...   # Run only the BenchmarkFoo benchmark (and no tests)
</pre></code></figure>

<p>I almost always run benchmarks using the <code>-benchmem</code> flag, which forces memory allocation statistics to be included in the output.</p>

<figure class="shell"><code><pre>
$  go test -bench=. -benchmem ./...
</pre></code></figure>

<p>By default, each benchmark test will be run for <em>a minimum</em> of 1 second, once only. You can change this with the <code>-benchtime</code> and <code>-count</code> flags:</p>

<figure class="shell"><code><pre>
$ go test -bench=. -benchtime=5s ./...       # Run each benchmark test for at least 5 seconds
$ go test -bench=. -benchtime=500x /....     # Run each benchmark test for exactly 500 iterations
$ go test -bench=. -count=3 ./...            # Repeat each benchmark test 3 times over
</pre></code></figure>

<p>If the code that you're benchmarking uses concurrency, you can use the <code>-cpu</code> flag to see the performance impact of changing your <code>GOMAXPROCS</code> value (essentially, the number of OS threads that can execute your Go code simultaneously). For example, to run benchmarks with <code>GOMAXPROCS</code> set to 1, 4 and 8:</p>

<figure class="shell"><code><pre>
$ go test -bench=. -cpu=1,4,8 ./...
</pre></code></figure>

<p>To compare changes between benchmarks you might want to use the <a href="https://godoc.org/golang.org/x/tools/cmd/benchcmp">benchcmp</a> tool. This isn't part of the standard <code>go</code> command, so you'll need to install it like so:</p>

<figure class="shell"><code><pre>
$ cd /tmp
$ GO111MODULE=on go get golang.org/x/tools/cmd/benchcmp
</pre></code></figure>

<p>You can then use it like this:</p>

<figure class="shell"><code><pre>
$ go test -run=^$ -bench=. -benchmem ./... &gt; /tmp/old.txt
<samp># make changes</samp>
$ go test -run=^$ -bench=. -benchmem ./... &gt; /tmp/new.txt
$ benchcmp /tmp/old.txt /tmp/new.txt
<samp>benchmark              old ns/op     new ns/op     delta
BenchmarkExample-8     21234         5510          -74.05%

benchmark              old allocs     new allocs     delta
BenchmarkExample-8     17             11             -35.29%

benchmark              old bytes     new bytes     delta
BenchmarkExample-8     8240          3808          -53.79%</samp>
</pre></code></figure>

<h3 id="profiling-and-tracing">Profiling and Tracing</h3>

<p>Go makes it possible to create diagnostic <em>profiles</em> for CPU use, memory use, goroutine blocking and mutex contention. You can use these to dig a bit deeper and see exactly how your application is using (or waiting on) resources.</p>

<p>There are three ways to generate profiles:</p>

<ul>
	<li>If you have a web application you can import the <a href="https://golang.org/pkg/net/http/pprof/"><code>net/http/pprof</code></a> package. This will register some handlers with the <code>http.DefaultServeMux</code> which you can then use to generate and download profiles for your running application. <a href="https://artem.krylysov.com/blog/2017/03/13/profiling-and-optimizing-go-web-applications/">This post</a> provides a good explanation and some sample code.</li>
	<li>For other types of applications, you can profile your running application using the <code>pprof.StartCPUProfile()</code> and <code>pprof.WriteHeapProfile()</code> functions. See the <a href="https://golang.org/pkg/runtime/pprof/"><code>runtime/pprof</code></a> documentation for sample code.</li>
	<li>Or you can generate profiles while running benchmarks or tests by using the various <code>-***profile</code> flags like so:</li>
</ul>

<figure class="shell"><code><pre>
$ go test -run=^$ -bench=^BenchmarkFoo$ -cpuprofile=/tmp/cpuprofile.out .
$ go test -run=^$ -bench=^BenchmarkFoo$ -memprofile=/tmp/memprofile.out .
$ go test -run=^$ -bench=^BenchmarkFoo$ -blockprofile=/tmp/blockprofile.out .
$ go test -run=^$ -bench=^BenchmarkFoo$ -mutexprofile=/tmp/mutexprofile.out .
</pre></code></figure>

<p>Note: Using the <code>-***profile</code> flags when running benchmarks or tests will result in a test binary being outputted to your current directory. If you want to output this to an alternative location you should use the <code>-o</code> flag like so:</p>

<figure class="shell"><code><pre>
$ go test -run=^$ -bench=^BenchmarkFoo$ -o=/tmp/foo.test -cpuprofile=/tmp/cpuprofile.out .
</pre></code></figure>

<p>Whichever way you choose to create a profile, when profiling is enabled your Go program will stop about 100 times per second and take a snapshot at that moment in time. These <em>samples</em> are collected together to form a <em>profile</em> that you can analyze using the <code>pprof</code> tool.</p>

<p>My favourite way to inspect a profile is to use the <code>go tool pprof -http</code> command to open it in a web browser. For example:</p>

<figure class="shell"><code><pre>
$ go tool pprof -http=:5000 /tmp/cpuprofile.out
</pre></code></figure>

<p><img src="/static/images/tooling-3.png"></p>

<p>This will default to displaying a <em>graph</em> showing the execution tree for the sampled aspects of your application, which makes it possible to quickly get a feel for any resource usage 'hotspots'. In the graph above, we can see that the hotspots in terms of CPU usage are two system calls originating from <code>ioutil.ReadFile()</code>.</p>

<p>You can also navigate to other <em>views</em> of the profile including top usage by function and source code.</p>

<p><img src="/static/images/tooling-4.png"></p>

<p>If the amount of information is overwhelming, you might want to use the <code>--nodefraction</code> flag to ignore nodes that account for less than a certain percentage of samples. For example to ignore nodes that use appear in less than 10% of samples you can run <code>pprof</code> like so:</p>

<figure class="shell"><code><pre>
$ go tool pprof --nodefraction=0.1 -http=:5000 /tmp/cpuprofile.out
</pre></code></figure>

<p><img src="/static/images/tooling-5.png"></p>

<p>This makes the graph a lot less 'noisy' and if you <a href="/static/images/tooling-5b.svg">zoom in on this screenshot</a>, it's now much clearer to see and understand where the CPU usage hotspots are.</p>

<p>Profiling and optimizing resource usage is big, nuanced, topic and I've barely scratched the surface here. If you're interested in knowing more then I encourage you to read the following blog posts:</p>

<ul>
<li><a href="https://artem.krylysov.com/blog/2017/03/13/profiling-and-optimizing-go-web-applications/">Profiling and optimizing Go web applications</a></li>
<li><a href="https://github.com/golang/go/wiki/Performance">Debugging performance issues in Go programs</a></li>
<li><a href="https://medium.com/@hackintoshrao/daily-code-optimization-using-benchmarks-and-profiling-in-golang-gophercon-india-2016-talk-874c8b4dc3c5">Daily code optimization using benchmarks and profiling</a></li>
<li><a href="https://jvns.ca/blog/2017/09/24/profiling-go-with-pprof/">Profiling Go programs with pprof</a></li>
</ul>

<p>Another tool that you can use to help diagnose issues is the <em>runtime execution tracer</em>. This gives you a view of how Go is creating and scheduling goroutines to run, when the garbage collector is running, and information about blocking syscall/network/sync operations.</p>

<p>Again, you can generate trace from your tests or benchmarks, or use <code>net/http/pprof</code> to create and download a trace for your web application. You can then use <code>go tool trace</code> to view the output in your web browser like so:</p>

<figure class="shell"><code><pre>
$ go test -run=^$ -bench=^BenchmarkFoo$ -trace=/tmp/trace.out .
$ go tool trace /tmp/trace.out
</pre></code></figure>

<p>Important: This is currently only viewable in Chrome/Chromium.</p>

<p><img src="/static/images/tooling-6.png"></p>

<p>For more information about Go's execution tracer and how to interpret the output please see <a href="https://www.youtube.com/watch?v=mmqDlbWk_XA">Rhys Hiltner's dotGo 2016 talk</a> and this<a href="https://making.pusher.com/go-tool-trace/"> excellent blog post</a>.</p>

<h3 id="checking-for-race-conditions">Checking for Race Conditions</h3>

<p>I talked earlier about enabling Go's race detector during tests by using <code>go test -race</code>. But you can also enable it for running programs when building a executable, like so:</p>

<figure class="shell"><code><pre>
$ go build -race -o=/tmp/foo .
</pre></code></figure>

<p>It's critical to note that race-detector-enabled binaries will use more CPU and memory than normal, so you shouldn't use the <code>-race</code> flag when building binaries for production under normal circumstances.</p>

<p>But you may want to deploy a race-detector-enabled binary on one server within a pool of many. Or use it to help track down a suspected race-condition by using a load-test tool to throw traffic concurrently at a race-detector-enabled binary.</p>

<p>By default, if any races are detected while the binary is running a log will be written to <code>stderr</code>. You can change this by using the <code>GORACE</code> environment variable if necessary. For example, to run the binary located at <code>/tmp/foo</code> and output any race logs to <code>/tmp/race.&lt;pid&gt;</code> you can use:</p>

<figure class="shell"><code><pre>
$ GORACE=&#34;log_path=/tmp/race&#34; /tmp/foo
</pre></code></figure>

<h2 id="managing-dependencies">Managing Dependencies</h2>

<p>You can use the <code>go list</code> tool to check whether a specific dependency has a newer version available like so:</p>

<figure class="shell"><code><pre>
$ go list -m -u github.com/alecthomas/chroma
<samp>github.com/alecthomas/chroma v0.6.2 [v0.6.3]</samp>
</pre></code></figure>

<p>This will output the dependency name and version that you're currently using, followed by the latest version in square brackets <code>[]</code>, if a newer one exists. You can also use <code>go list</code> to check for updates to all dependencies (and sub-dependencies) like so:</p>

<figure class="shell"><code><pre>
$ go list -m -u all
</pre></code></figure>

<p>You can upgrade (or downgrade) a dependency to the latest version, specific tagged-release or commit hash with the <code>go get</code> command like so:</p>

<figure class="shell"><code><pre>
$ go get github.com/foo/bar@latest
$ go get github.com/foo/bar@v1.2.3
$ go get github.com/foo/bar@7e0369f
</pre></code></figure>

<p>If the dependency you're updating has a <code>go.mod</code> file, then based on the information in this <code>go.mod</code> file, updates to any <em>sub-dependencies</em> will also be downloaded if necessary. If you use the <code>go get -u</code> flag, the contents of the <code>go.mod</code> file will be ignored and all sub-dependencies will be upgraded to their latest minor/patch version&hellip; even if the <code>go.mod</code> specifies a different version.</p>

<p>After upgrading or downgrading any dependencies it's a good idea to tidy your modfiles. And you might also want to run the tests for all packages to help check for incompatibilities. Like so:</p>

<figure class="shell"><code><pre>
$ go mod tidy
$ go test all
</pre></code></figure>

<p>Occasionally you might want to use a local version of a dependency (for example, you need to use a local fork until a patch is merged upstream). To do this, you can use the <code>go mod edit</code> command to replace a dependency in your <code>go.mod</code> file with a local version. For example:</p>

<figure class="shell"><code><pre>
$ go mod edit -replace=github.com/alexedwards/argon2id=/home/alex/code/argon2id
</pre></code></figure>

<p>This will add a <em>replace rule</em> to your <code>go.mod</code> file like so, and any future invocations of <code>go run</code>, <code>go build</code> etc will use the local version.</p>

<figure class="file"><figcaption>File: go.mod</figcaption><code><pre>
module alexedwards.net/example

go 1.12

require github.com/alexedwards/argon2id v0.0.0-20190109181859-24206601af6c

replace github.com/alexedwards/argon2id =&gt; /home/alex/Projects/playground/argon2id
</pre></code></figure>

<p>Once it's no longer necessary, you can remove the replace rule with the command:</p>

<figure class="shell"><code><pre>
$ go mod edit -dropreplace=github.com/alexedwards/argon2id
</pre></code></figure>

<p>You can use the <a href="https://github.com/golang/go/wiki/Modules#can-i-work-entirely-outside-of-vcs-on-my-local-filesystem">same general technique</a> to import packages that exist <em>only</em> on your own file system. This can be useful if you're working on multiple modules in development at the same time, one of which depends on the other.</p>

<p>Note: If you don't want to use the <code>go mod edit</code> command, you can edit your <code>go.mod</code> file manually to make these changes. Either way will work.</p>

<h2 id="upgrading-to-a-new-go-release">Upgrading to a New Go Release</h2>

<p>The <code>go fix</code> tool was originally released back in 2011 (when regular changes were still being made to Go's API) to help users automatically update their old code to be compatible with the latest version of Go. Since then, Go's <a href="https://golang.org/doc/go1compat">compatibility promise</a> means if you're upgrading from one Go 1.x version to a newer 1.x version everything should Just Work and using <code>go fix</code> should generally be unnecessary.</p>

<p>However, there are a handful of very specific issues that it does deal with. You can see a summary of them by running <code>go tool fix -help</code>. If you decide that you want or need to run <code>go fix</code> after upgrading, you should you run the following command, then inspect a diff of the changes before you commit them.</p>

<figure class="shell"><code><pre>
$ go fix ./...
</pre></code></figure>

<h2 id="reporting-bugs">Reporting Bugs</h2>

<p>If you're confident that you've found an unreported issue with Go's standard library, tooling or documentation, you can use the <code>go bug</code> command to create a new Github issue.</p>

<figure class="shell"><code><pre>
$ go bug
</pre></code></figure>

<p>This will open a browser window containing an issue pre-filled with your system information and reporting template.</p>
    ]]></description>
  </item>
  <item>
    <pubDate>Mon, 10 Dec 2018 18:00:00 GMT</pubDate>
    <link>https://www.alexedwards.net/blog/how-to-hash-and-verify-passwords-with-argon2-in-go</link>
    <guid>https://www.alexedwards.net/blog/how-to-hash-and-verify-passwords-with-argon2-in-go</guid>
    <title>How to Hash and Verify Passwords With Argon2 in Go</title>
    <description><![CDATA[
<p><em>Thanks to <a href="https://twitter.com/_aead_">Andreas Auernhammer</a>, author of the <a href="https://godoc.org/golang.org/x/crypto/argon2">golang.org/x/crypto/argon2</a> package, for checking over this post before publication.</em></p>

<p>If you're planning to store user passwords it's good practice (essential really) to hash them using a computationally expensive key-derivation function (KDF) like Bcrypt, Scrypt or Argon2.</p>

<p>Hashing and verifying passwords in Go with Bcrypt and Scrypt is already easy to do thanks to the <a href="https://godoc.org/golang.org/x/crypto/bcrypt">golang.org/x/crypto/bcrypt</a> package and Matt Silverlock's <a href="https://github.com/elithrar/simple-scrypt">elithrar/simple-scrypt</a> package. I recommend them both.</p>

<p>If you want to use Argon2 &mdash; which is widely considered to be the <a href="https://password-hashing.net/">best in class</a> KDF for hashing passwords &mdash; then you've got a couple of choices.</p>

<p>The <a href="https://github.com/tvdburgt/go-argon2">tvdburgt/go-argon2</a> package provides Go bindings to the <code>libargon2</code> C library, or you can implement a pure Go solution by wrapping the <a href="https://godoc.org/golang.org/x/crypto/argon2">golang.org/x/crypto/argon2</a> package with helpers for hashing and verifying passwords. In the rest of this post I'm going to explain exactly how to use this pure Go approach.</p>

<h2 id="abriefintroductiontoargon2">A Brief Introduction to Argon2</h2>

<p>But first, a little bit of background.</p>

<p>It's important to explain that the <a href="https://tools.ietf.org/html/draft-irtf-cfrg-argon2-04">Argon2 algorithm</a> has 3 variants which work slightly differently: Argon2d, Argon2i and Argon2id. In general, for password hashing you should use the Argon2id variant. This is essentially a hybrid of the Argon2d and Argon2i algorithms and uses a combination of data-independent memory access (for resistance against side-channel timing attacks) and data-depending memory access (for resistance against GPU cracking attacks).</p>

<p>The Argon2 algorithm accepts a number of configurable parameters:</p>

<ul>
<li>Memory &mdash; The amount of memory used by the algorithm (in <a href="https://en.wikipedia.org/wiki/Kibibyte">kibibytes</a>).</li>

<li>Iterations &mdash; The number of iterations (or <em>passes</em>) over the memory.</li>

<li>Parallelism &mdash; The number of threads (or <em>lanes</em>) used by the algorithm.</li>

<li>Salt length &mdash; Length of the random salt. <a href="https://tools.ietf.org/html/draft-irtf-cfrg-argon2-04#section-3.1">16 bytes is recommended</a> for password hashing.</li>

<li>Key length &mdash; Length of the generated key (or <em>password hash</em>). 16 bytes or more is recommended.</li>
</ul>

<p>The <em>memory</em> and <em>iterations</em> parameters control the <em>computational cost</em> of hashing the password. The higher these figures are, the greater the cost of generating the hash. It also follows that the greater the cost will be for any attacker trying to guess the password.</p>

<p>But there's a balance that you need to strike. As you increase the cost, the time taken to generate the hash also increases. If you're generating the hash in response to a user action (like signing up or logging in to a website) then you probably want to keep the runtime to less than 500ms to avoid a negative user experience.</p>

<p>If the Argon2 algorithm is running on a machine with multiple cores, then one way to decrease the runtime <em>without</em> reducing the cost is to increase the  <em>parallelism</em> parameter. This controls the number of threads that the work is spread across. There's an important thing to note here though: <em>changing the value of the parallelism parameter changes the output of the algorithm</em>. So &mdash; for example &mdash; running Argon2 with a parallelism parameter of 2 will result in a different password hash to running it with a parallelism parameter of 4.</p>

<h2 id="choosingparameters">Choosing Parameters</h2>

<p>Picking the right parameters for Argon2 depends heavily on the machine that the algorithm is running on, and you'll probably need to do some experimentation in order to set them appropriately.</p>

<p><a href="https://tools.ietf.org/html/draft-irtf-cfrg-argon2-04#section-4">The recommended process </a> for choosing the parameters can be paraphrased as follows:</p>

<ol>
<li>Set the parallelism and memory parameters to the largest amount you are willing to afford, bearing in mind that you probably don't want to max these out completely unless your machine is dedicated to password hashing.</li>

<li>Increase the number of iterations until you reach your maximum runtime limit (for example, 500ms).</li>

<li>If you're already exceeding the your maximum runtime limit with the number of iterations = 1, then you should reduce the memory parameter.</li>
</ol>

<h2 id="hashingpasswords">Hashing Passwords</h2>

<p>Now that those explanations are out of the way let's jump into writing the code to hash a password with Argon2.</p>

<p>First, you'll need to <code>go get</code> the <a href="https://godoc.org/golang.org/x/crypto/argon2">golang.org/x/crypto/argon2</a> package which implements the Argon2 algorithm:</p>

<figure class="shell"><code><pre>$ go get golang.org/x/crypto/argon2
</pre></code></figure>

<p>And you can use it to hash a specific password like so:</p>

<figure class="file"><figcaption>File: main.go</figcaption><code><pre>
package main

import (
    "crypto/rand"
    "fmt"
    "log"

    "golang.org/x/crypto/argon2"
)

type params struct {
    memory      uint32
    iterations  uint32
    parallelism uint8
    saltLength  uint32
    keyLength   uint32
}

func main() {
    // Establish the parameters to use for Argon2.
    p := &amp;params{
        memory:      64 * 1024,
        iterations:  3,
        parallelism: 2,
        saltLength:  16,
        keyLength:   32,
    }

    // Pass the plaintext password and parameters to our generateFromPassword
    // helper function.
    hash, err := generateFromPassword("password123", p)
    if err != nil {
        log.Fatal(err)
    }

    fmt.Println(hash)
}

func generateFromPassword(password string, p *params) (hash []byte, err error) {
    // Generate a cryptographically secure random salt.
    salt, err := generateRandomBytes(p.saltLength)
    if err != nil {
        return nil, err
    }

    // Pass the plaintext password, salt and parameters to the argon2.IDKey
    // function. This will generate a hash of the password using the Argon2id
    // variant.
    hash = argon2.IDKey([]byte(password), salt, p.iterations, p.memory, p.parallelism, p.keyLength)

    return hash, nil
}

func generateRandomBytes(n uint32) ([]byte, error) {
    b := make([]byte, n)
    _, err := rand.Read(b)
    if err != nil {
        return nil, err
    }

    return b, nil
}
</pre></code></figure>

<p>A quick note on terminology and naming. Formally, Argon2 is a <em>key-derivation function</em> and it produces a <em>key</em> derived from the provided password and salt. This derived key is our 'hashed password'.</p>

<p>The other important thing to point out here is the <code>generateRandomBytes()</code> function. In this we're using Go's <a href="https://golang.org/pkg/crypto/rand/">crypto/rand</a> package to generate a cryptographically secure random salt, rather than using a fixed salt or a pseudo-random salt.</p>

<p>If you run the program at this point it should print a slice containing the bytes of the hashed password, similar to this:</p>

<figure class="shell"><code><pre>$ go run main.go
[9 18 35 54 101 221 120 189 57 241 229 248 140 1 102 58 93 211 115 49 131 162 24 50 167 142 227 198 85 186 200 248]
</pre></code></figure>

<p>Each time you run the program you'll see that it results in a completely different output for the same password, thanks to the addition of our random salt.</p>

<h2 id="storingpasswords">Storing Passwords</h2>

<p>So, creating a hashed password with some specific parameters is straightforward enough. But in most cases you'll want to store the salt and specific parameters that you used <em>alongside</em> the hashed password, so that it can be reproducibly verified at a later point.</p>

<p>The <a href="https://github.com/P-H-C/phc-winner-argon2#command-line-utility">standard way</a> to do this is to create an encoded representation of the hashed password which looks like this:</p>

<figure class="plain"><code><pre>$argon2id$v=19$m=65536,t=3,p=2$c29tZXNhbHQ$RdescudvJCsgt3ub+b+dWRWJTmaaJObG
</pre></code></figure>

<p>Let's break down what this represents:</p>

<ul>
<li><code>$argon2id</code> &mdash; the variant of Argon2 being used.</li>

<li><code>$v=19</code> &mdash; the version of Argon2 being used.</li>

<li><code>$m=65536,t=3,p=2</code> &mdash; the memory (<code>m</code>), iterations (<code>t</code>) and parallelism (<code>p</code>) parameters being used.</li>

<li><code>$c29tZXNhbHQ</code> &mdash; the base64-encoded salt, using standard base64-encoding and no padding.</li>

<li><code>$c29tZXNhbHQ$RdescudvJCsgt3ub+b+dWRWJTmaaJObG</code> &mdash; the base64-encoded hashed password (derived key), using standard base64-encoding and no padding.</li>
</ul>

<p>Let's update the <code>generateHash()</code> function so that it returns a string in this format:</p>

<figure class="file"><figcaption>File: main.go</figcaption><code><pre>
package main

import (
    "crypto/rand"
    "encoding/base64"
    "fmt"
    "log"

    "golang.org/x/crypto/argon2"
)

...

func generateFromPassword(password string, p *params) (encodedHash string, err error) {
    salt, err := generateRandomBytes(p.saltLength)
    if err != nil {
        return "", err
    }

    hash := argon2.IDKey([]byte(password), salt, p.iterations, p.memory, p.parallelism, p.keyLength)

    // Base64 encode the salt and hashed password.
    b64Salt := base64.RawStdEncoding.EncodeToString(salt)
    b64Hash := base64.RawStdEncoding.EncodeToString(hash)

    // Return a string using the standard encoded hash representation.
    encodedHash = fmt.Sprintf("$argon2id$v=%d$m=%d,t=%d,p=%d$%s$%s", argon2.Version, p.memory, p.iterations, p.parallelism, b64Salt, b64Hash)

    return encodedHash, nil
}

...
</pre></code></figure>

<p>And if you run the code again now, the output should look similar to this:</p>

<figure class="shell"><code><pre>$ go run run.go
<samp>$argon2id$v=19$m=65536,t=3,p=2$Woo1mErn1s7AHf96ewQ8Uw$D4TzIwGO4XD2buk96qAP+Ed2baMo/KbTRMqXX00wtsU</samp>
</pre></code></figure>

<h2 id="verifyingpasswords">Verifying Passwords</h2>

<p>The final aspect to cover is how to verify passwords.</p>

<p>In most cases, you'll take the encoded password hash that we've just produced and store it in a database of some kind. Then at a later point, you'll want to check <em>whether a plaintext password provided by a user matches the one represented by the encoded password hash</em>.</p>

<p>In essence, the steps to do this check are:</p>

<ol>
<li>Extract the salt and parameters from the encoded password hash stored in the database.</li>

<li>Derive the hash of the plaintext password using the exact same Argon2 variant, version, salt and parameters.</li>

<li>Check whether this new hash is the same as the original one.</li>
</ol>

<p>You can implement this like so:</p>

<figure class="file"><figcaption>File: main.go</figcaption><code><pre>
package main

import (
    "crypto/rand"
    "crypto/subtle"
    "encoding/base64"
    "errors"
    "fmt"
    "log"
    "strings"

    "golang.org/x/crypto/argon2"
)

var (
    ErrInvalidHash         = errors.New("the encoded hash is not in the correct format")
    ErrIncompatibleVersion = errors.New("incompatible version of argon2")
)

type params struct {
    memory      uint32
    iterations  uint32
    parallelism uint8
    saltLength  uint32
    keyLength   uint32
}

func main() {
    p := &amp;params{
        memory:      64 * 1024,
        iterations:  3,
        parallelism: 2,
        saltLength:  16,
        keyLength:   32,
    }

    encodedHash, err := generateFromPassword("password123", p)
    if err != nil {
        log.Fatal(err)
    }

    match, err := comparePasswordAndHash("password123", encodedHash)
    if err != nil {
        log.Fatal(err)
    }

    fmt.Printf("Match: %v\n", match)
}

...

func comparePasswordAndHash(password, encodedHash string) (match bool, err error) {
    // Extract the parameters, salt and derived key from the encoded password
    // hash.
    p, salt, hash, err := decodeHash(encodedHash)
    if err != nil {
        return false, err
    }

    // Derive the key from the other password using the same parameters.
    otherHash := argon2.IDKey([]byte(password), salt, p.iterations, p.memory, p.parallelism, p.keyLength)

    // Check that the contents of the hashed passwords are identical. Note
    // that we are using the subtle.ConstantTimeCompare() function for this
    // to help prevent timing attacks.
    if subtle.ConstantTimeCompare(hash, otherHash) == 1 {
        return true, nil
    }
    return false, nil
}

func decodeHash(encodedHash string) (p *params, salt, hash []byte, err error) {
    vals := strings.Split(encodedHash, "$")
    if len(vals) != 6 {
        return nil, nil, nil, ErrInvalidHash
    }

    var version int
    _, err = fmt.Sscanf(vals[2], "v=%d", &amp;version)
    if err != nil {
        return nil, nil, nil, err
    }
    if version != argon2.Version {
        return nil, nil, nil, ErrIncompatibleVersion
    }

    p = &amp;params{}
    _, err = fmt.Sscanf(vals[3], "m=%d,t=%d,p=%d", &amp;p.memory, &amp;p.iterations, &amp;p.parallelism)
    if err != nil {
        return nil, nil, nil, err
    }

    salt, err = base64.RawStdEncoding.DecodeString(vals[4])
    if err != nil {
        return nil, nil, nil, err
    }
    p.saltLength = uint32(len(salt))

    hash, err = base64.RawStdEncoding.DecodeString(vals[5])
    if err != nil {
        return nil, nil, nil, err
    }
    p.keyLength = uint32(len(hash))

    return p, salt, hash, nil
}
</pre></code></figure>

<p>If you run this code now, you should get a positive match when comparing the plaintext and hashed password and see output like this:</p>

<figure class="shell"><code><pre>$ go run main.go
<samp>Match: true</samp>
</pre></code></figure>

<p>If you change the plaintext password used in one of the function calls, like so:</p>

<figure class="file"><figcaption>File: main.go</figcaption><code><pre>
package main

...

func main() {
    p := &amp;params{
        memory:      64 * 1024,
        iterations:  3,
        parallelism: 2,
        saltLength:  16,
        keyLength:   32,
    }

    encodedHash, err := generateFromPassword("password123", p)
    if err != nil {
        log.Fatal(err)
    }

    // Use a different password...
    match, err := comparePasswordAndHash("pa$$word", encodedHash)
    if err != nil {
        log.Fatal(err)
    }

    fmt.Printf("Match: %v\n", match)
}

...
</pre></code></figure>

<p>Then running the code should result in a negative match:</p>

<figure class="shell"><code><pre>$ go run main.go
<samp>Match: false</samp>
</pre></code></figure>

<p>The complete sample code for this post is available in <a href="https://gist.github.com/alexedwards/34277fae0f48abe36822b375f0f6a621">this gist</a>.</p>
    ]]></description>
  </item>
  <item>
    <pubDate>Tue, 5 Jun 2018 13:00:00 GMT</pubDate>
    <link>https://www.alexedwards.net/blog/streamline-your-sublime-text-and-go-workflow</link>
    <guid>https://www.alexedwards.net/blog/streamline-your-sublime-text-and-go-workflow</guid>
    <title>Streamline Your Sublime Text + Go Workflow</title>
    <description><![CDATA[
<p>For the past couple of years I've used Sublime Text as my primary code editor, along with the <a href="https://github.com/DisposaBoy/GoSublime">GoSublime</a> plugin to provide some extra IDE-like features.</p>

<p>But I've recently swapped GoSublime for a more modular plugin setup and have been really happy with the way it's worked out. Although it took a while to configure, it's resulted in a coding environment that feels clearer to use and more streamlined than before.</p>

<p>I've opted for:</p>

<ul>
<li><strong>Tooling integration</strong> with the official <a href="https://github.com/golang/sublime-build">sublime-build</a> plugin.</li>
<li><strong>Automatic formatting</strong> with the <a href="https://github.com/noonat/sublime-gofmt">Gofmt</a> plugin and <a href="https://godoc.org/golang.org/x/tools/cmd/goimports">goimports</a>.</li>
<li><strong>Code linting</strong> with the <a href="https://github.com/SublimeLinter/SublimeLinter">SublimeLinter</a> plugin and <a href="https://github.com/alecthomas/gometalinter">gometalinter</a>.</li>
<li><strong>Autocompletion</strong> with the <a href="https://github.com/mdempsky/gocode">gocode</a> package.</li>
<li><strong>Code navigation</strong> with the <a href="https://github.com/alvarolm/GoGuru">GoGuru</a> plugin.</li>
<li><strong>Snippet management</strong> with Sublime Text's inbuilt tool and the <a href="https://github.com/skuroda/PackageResourceViewer">PackageResourceViewer</a> plugin.</li>
</ul>

<p>In this post I'm going to run through the process of setting these up. If you haven't come across these plugins before, I recommend giving them a try!</p>

<h2>Prerequisites</h2>

<p>To work correctly some of these Sublime Text plugins need an explicit <code>$GOPATH</code> environment variable to be set. And if you're following along, you should also make sure that your workspace's <code>bin</code> directory is on your system path.</p>

<p>Accordingly my bash <code>~/.profile</code> configuration includes these lines:</p>

<figure class="plain"><code><pre>...
export GOPATH=/home/alex/Code/go
export PATH=$PATH:$GOPATH/bin
</pre></code></figure>

<p>You'll also need to <a href="https://packagecontrol.io/installation">install Package Control</a>, if you haven't already. In the latest version of  Sublime Text the easiest way to do that by going to <code>Tools &gt; Install Package Control&hellip;</code>.</p>

<h2>Tooling integration</h2>

<p>The official <a href="https://github.com/golang/sublime-build">sublime-build</a> plugin provides integrations so you can execute common <code>go</code> commands (like <code>go run</code>, <code>go test</code> and <code>go get</code>) without leaving your editor.</p>

<p>You can install it like so:</p>

<ol>
<li>Open the Sublime Text command palette by pressing <code>Ctrl+Shift+P</code>.</li>
<li>Run the <code>Package Control: Install Package</code> command.</li>
<li>Type <code>Golang Build</code> and hit <code>Enter</code> to install the package.</li>
</ol>

<p>After installation should see a bunch of new tools in your command palette. Their names are pretty self explanatory:</p>

<ul>
<li><code>Build With: Go</code></li>
<li><code>Build With: Go - Clean</code></li>
<li><code>Build With: Go - Install</code></li>
<li><code>Build With: Go - Run</code></li>
<li><code>Build With: Go - Test</code></li>
<li><code>Build With: Go - Cross-Compile</code></li>
<li><code>Go: Get</code></li>
<li><code>Go: Open Terminal</code></li>
</ul>

<p>When you run these commands they will open and execute in a panel <em>within</em> Sublime Text. As an example, here's a screenshot of output from the <code>Build With: Go - Test</code> command:</p>

<img src="https://www.alexedwards.net/static/images/sublime-1.png">

<h2>Automatic formatting</h2>

<p>For automatic formatting of <code>.go</code> files I've been using the <a href="https://github.com/noonat/sublime-gofmt">Gofmt</a> plugin. You can install it as follows:</p>

<ol>
<li>Open the Sublime Text command palette  by pressing <code>Ctrl+Shift+P</code>.</li>
<li>Run the <code>Package Control: Install Package</code> command.</li>
<li>Type <code>Gofmt</code> and hit <code>Enter</code> to install the package.</li>
</ol>

<p>By default this will run <code>go fmt -s -e</code> on the current file each time it is saved.</p>

<p>I've customised this further to use the <a href="https://godoc.org/golang.org/x/tools/cmd/goimports">goimports</a> tool. If you're not already familiar with <code>goimports</code>, it runs <code>go fmt</code> <em>and</em> fixes your import lines &mdash; adding missing packages and removing unreferenced ones as necessary.</p>

<p>To set this up you'll need to install <code>goimports</code> and make sure it's available on your system path:</p>

<figure class="shell"><code><pre>$ go get golang.org/x/tools/cmd/goimports
$ which goimports
<samp>/home/alex/Code/go/bin/goimports</samp>
</pre></code></figure>

<p>When that's installed, you'll then need to change the <code>Gofmt</code> plugin settings in Sublime Text by opening
<code>Preferences &gt; Package Settings &gt; Gofmt &gt; Settings - User</code> and adding the following configuration settings:</p>

<figure class="json"><code><pre>{
  "cmds": [
    ["goimports"]
  ],
  "format_on_save": true
}
</pre></code></figure>

<p>(You'll probably need to restart Sublime Text for this to take effect.)</p>

<p>Each time you now save a <code>.go</code> file, you'll find that it gets automatically formatted and the import packages are updated. No more <code>"imported and not used"</code> errors!</p>

<h2>Code linting</h2>

<p>For linting of source code I'm using the <a href="https://github.com/SublimeLinter/SublimeLinter">SublimeLinter</a> plugin. This plugin isn't a linter itself, but provides a <em>framework</em> for running linters and displaying error messages. You can install it like so:</p>

<ol>
<li>Open command palette by pressing <code>Ctrl+Shift+P</code>.</li>
<li>Run the <code>Package Control: Install Package</code> command.</li>
<li>Type <code>SublimeLinter</code> and hit <code>Enter</code> to install the package.</li>
</ol>

<p>The next step is to install an actual linter. I'm using <a href="https://github.com/alecthomas/gometalinter">gometalinter</a>, which acts as a wrapper around a bunch of <a href="https://github.com/alecthomas/gometalinter#supported-linters">different linters</a> and picks up more potential problems and inefficiencies than using <code>go vet</code> and <code>golint</code> alone. You can install it with the commands:</p>

<figure class="shell"><code><pre>$ go get github.com/alecthomas/gometalinter
$ which gometalinter
<samp>/home/alex/Code/go/bin/gometalinter</samp>
$ gometalinter --install
</pre></code></figure>

<p>Once that's done, you'll need to install the <a href="https://github.com/alecthomas/SublimeLinter-contrib-gometalinter">SublimeLinter-contrib-gometalinter</a> plugin. This acts as the bridge between SublimeLinter and gometalinter.</p>

<ol>
<li>Open command palette by pressing <code>Ctrl+Shift+P</code>.</li>
<li>Run the <code>Package Control: Install Package</code> command.</li>
<li>Type <code>SublimeLinter-contrib-gometalinter</code> and hit <code>Enter</code> to install the package.</li>
</ol>

<p>By default the linter will run in the background as you type, and errors will be shown in the Sublime Text status bar at the bottom of the screen. But I've found suits me more to only lint when saving a file and to display all errors at once in a panel. If you want to do the same, go to <code>Preferences &gt; Package Settings &gt; SublimeLinter &gt; Settings</code> and add the following settings to the <code>SublimeLinter Settings - User</code> file:</p>

<figure class="json"><code><pre>{
    "show_panel_on_save": "window",
    "lint_mode": "save",
}
</pre></code></figure>

<img src="https://www.alexedwards.net/static/images/sublime-2.png">

<p>I should mention that the <code>SublimeLinter-contrib-gometalinter</code> plugin only executes the 'fast' linters included in <code>gometalinter</code>. You can see exactly which ones are run by checking the <a href="https://github.com/alecthomas/gometalinter/blob/322f0639d93eafd502424842597e73f8c3ae43d8/linters.go#L205">source code</a>.</p>

<h2>Autocompletion</h2>

<p>For autocompletion I'm using the <a href="github.com/mdempsky/gocode">gocode</a> package, which provides a deamon for code completion. You can install it like so:</p>

<figure class="shell"><code><pre>$ go get github.com/mdempsky/gocode
$ which gocode
<samp>/home/alex/Code/go/bin/gocode</samp>
</pre></code></figure>

<p>There isn't currently a <code>gocode</code> plugin available via Sublime Text package control (I might add one soon!)&hellip; but there is a plugin included in the <code>subl3</code> directory <em>within</em> the <code>gocode</code> source itself.</p>

<p>You should be able to copy it into your Sublime Text <code>Packages</code> directory with the following command:</p>

<figure class="shell"><code><pre>$ cp -r $GOPATH/src/github.com/mdempsky/gocode/subl3 ~/.config/sublime-text-3/Packages/gocode
</pre></code></figure>

<p>If you open the command palette and run <code>Package Control: List Packages</code> you should see a <code>gocode</code> entry in the list.</p>

<img src="https://www.alexedwards.net/static/images/sublime-3.png">

<p>By default Sublime Text will make autocomplete suggestions whenever a letter is pressed. But when working with Go I like also to display potential method names whenever I hit the <code>.</code> character. You can make that happen by going to <code>Preferences &gt; Settings</code> and adding a new trigger in the <code>Preferences.sublime-settings - User</code> file:</p>

<figure class="json"><code><pre>{
    ...
    "auto_complete_triggers": [
        {"selector": "text.html", "characters": "&lt;"},
        {"selector": "source.go", "characters": "."}
    ],
}
</pre></code></figure>

<p>You'll need to then restart Sublime Text for the settings to take effect. Once you have, you should have autocomplete working nicely and looking something like this:</p>

<img src="https://www.alexedwards.net/static/images/sublime-4.png">

<h2>Code navigation</h2>

<p>To help with navigating code I use the <a href="golang.org/x/tools/cmd/guru">guru</a> tool, which you can install with the following command:</p>

<figure class="shell"><code><pre>$ go get golang.org/x/tools/cmd/guru
$ which guru
<samp>/home/alex/Code/go/bin/guru</samp>
</pre></code></figure>

<p>To integrate this with Sublime Text you'll also need to install the <a href="https://github.com/alvarolm/GoGuru">GoGuru</a> plugin like so:</p>

<ol>
<li>Open command palette by pressing <code>Ctrl+Shift+P</code>.</li>
<li>Run the <code>Package Control: Install Package</code> command.</li>
<li>Type <code>GoGuru</code> and hit <code>Enter</code> to install the package.</li>
</ol>

<p>To use the GoGuru tool, first place your cursor over the piece of code you're interested in. Then if you open the command palette and type the <code>GoGuru</code> prefix you'll see a list of available commands, including:

<ul>
<li><code>GoGuru: callees</code> &ndash; Show possible targets of selected function call</li>
<li><code>GoGuru: callers</code> &ndash; Show possible callers of selected function</li>
<li><code>GoGuru: callstack</code> &ndash; Show path from callgraph root to selected function</li>
<li><code>GoGuru: definition</code> &ndash; Show declaration of selected identifier</li>
<li><code>GoGuru: describe</code> &ndash; Describe selected syntax: definition, methods, etc</li>
<li><code>GoGuru: freevars</code> &ndash; Show free variables of selection</li>
<li><code>GoGuru: implements</code> &ndash; Show 'implements' relation for selected type or method</li>
<li><code>GoGuru: jump to definition</code> &ndash; Open the file at the declaration of selected identifier</li>
<li><code>GoGuru: peers</code> &ndash; Show send/receive corresponding to selected channel op</li>
<li><code>GoGuru: pointsto</code> &ndash; Show variables the selected pointer may point to</li>
<li><code>GoGuru: referrers</code> &ndash; Show all refs to thing denoted by selected identifier</li>
<li><code>GoGuru: what</code> &ndash; Show basic information about the selected syntax node</li>
<li><code>GoGuru: whicherrs</code> &ndash; Show possible values of the selected error variable</li>
</ul>

<p>You can find a detailed description these commands and their behaviour in <a href="https://docs.google.com/document/d/1_Y9xCEMj5S-7rv2ooHpZNH15JgRT5iM742gJkw5LtmQ">this GoogleDoc</a>.</p>

<p>I don't use the GoGuru plugin as often as the others, but when working on a unfamiliar codebase it definitely makes navigating code and building up a mental map of how things work easier. I find the <code>GoGuru: jump to definition</code> and <code>GoGuru: callers</code> commands particularly useful, and easier to use than grepping or running <code>Ctrl+F</code> on the repository.</p>

<p>As an illustration, here's a screenshot of running <code>GoGuru: callers</code> on the <code>Sum</code> function:</p>

<img src="https://www.alexedwards.net/static/images/sublime-5.png">

<h2>Snippets</h2>

<p>Sublime Text ships with a pretty good workflow for creating and using custom snippets. If you're not already familiar with this Jimmy Zhang has written a great <a href="https://medium.freecodecamp.org/a-guide-to-preserving-your-wrists-with-sublime-text-snippets-7541662a53f2">in-depth guide</a> that I recommend reading.</p>

<p>My most frequently-used snippet is probably this one for creating a HTTP handler function:</p>

<figure class="html"><code><pre>&lt;snippet&gt;
    &lt;content&gt;&lt;![CDATA[
func ${1:name}(w http.ResponseWriter, r *http.Request) {
    ${2:}
}
]]&gt;&lt;/content&gt;
    &lt;tabTrigger&gt;hf&lt;/tabTrigger&gt;
    &lt;scope&gt;source.go&lt;/scope&gt;
&lt;/snippet&gt;
</pre></code></figure>

<p>One thing that bugged me for a while was the <em>built-in snippets</em> for Go that Sublime Text ships with. In particular I didn't like the way that the <code>main()</code> snippet kept triggering whenever I wrote out <code>"package main"</code>.</p>

<p>If, like me, you want to edit these built-in snippets the easiest way is probably with the <a href="https://github.com/skuroda/PackageResourceViewer">PackageResourceViewer</a> plugin. You can install this as follows:</p>

<ol>
<li>Open command palette by pressing <code>Ctrl+Shift+P</code>.</li>
<li>Run the <code>Package Control: Install Package</code> command.</li>
<li>Type <code>PackageResourceViewer</code> and hit <code>Enter</code> to install the package.</li>
</ol>

<p>Once installed you can open the command palette and run <code>PackageResourceViewer: Open Resource</code> which will list all packages on your system. If you navigate through <code>Go &gt; Snippets/</code> you should see a list of all the built-in snippets and you can open and edit them as you wish.</p>

<p><em>Hint:</em> You can also use PackageResourceViewer to edit your own custom snippets without leaving SublimeText. If &ndash; for example &ndash; your custom snippets are saved under your <code>Packages/User</code> directory, you can open them by running <code>PackageResourceViewer: Open Resource</code> and navigating to the <code>User</code> folder.</p>
    ]]></description>
  </item>
   <item>
    <pubDate>Thu, 10 May 2018 16:00:00 GMT</pubDate>
    <link>https://www.alexedwards.net/blog/http-method-spoofing</link>
    <guid>https://www.alexedwards.net/blog/http-method-spoofing</guid>
    <title>HTTP Method Spoofing in Go</title>
    <description><![CDATA[
<p>A.K.A. <em>HTTP method overriding</em>.</p>
<p>As a web developer you probably already know that HTML forms <a href="https://www.w3.org/TR/html52/sec-forms.html#element-attrdef-form-method">only support</a> the <code>GET</code> and <code>POST</code> HTTP methods. </p>
<p>If you want to send a <code>PUT</code>, <code>PATCH</code> or <code>DELETE</code> request you need to resort to either sending a <code>XMLHttpRequest</code> from JavaScript (where they are supported by most major browsers) or implement a workaround in your server-side application code to support 'spoofed' HTTP methods.</p>
<p>The de-facto workaround &mdash; which you might be familiar with if you've used frameworks like Ruby on Rails, Laravel or Express &mdash; is to include a hidden <code>_method</code> input in your form containing the spoofed HTTP method. A bit like this:</p>
<figure class="plain"><code><pre>&lt;form method="POST" action="/"&gt;
    &lt;input type="hidden" name="_method" value="PUT"&gt;
    &lt;button type="submit"&gt;Submit&lt;/button&gt;
&lt;/form&gt;
</pre></code></figure>
<p>Another common workaround is to send a spoofed HTTP method in a <code>X-HTTP-Method-Override</code> header.</p>
<p>So how can we support these things in a Go application?</p>
<h2>MethodOverride Middleware</h2>
<p>Intercepting and dealing with spoofed HTTP methods is the perfect task for some custom <a href="https://www.alexedwards.net/blog/making-and-using-middleware">middleware</a>. We want the middleware to:</p>
<ol>
    <li>Intercept <code>POST</code> requests before they reach any application handlers.</li>
    <li>Check for a spoofed HTTP method, either in a <code>_method</code> parameter of the request body or a <code>X-HTTP-Method-Override</code> header. </li>
    <li>If a spoofed method exists &mdash; and is equal to <code>"PUT"</code>, <code>"PATCH"</code> or <code>"DELETE"</code> &mdash; the current <code>http.Request.Method</code> value should be updated accordingly.</li>
</ol>
<p>It's pretty quick to implement:</p>
<figure class="go"><code><pre>package main

import (
    "net/http"
)

func MethodOverride(next http.Handler) http.Handler {
    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        // Only act on POST requests.
        if r.Method == "POST" {

            // Look in the request body and headers for a spoofed method.
            // Prefer the value in the request body if they conflict.
            method := r.PostFormValue("_method")
            if method == "" {
                method = r.Header.Get("X-HTTP-Method-Override")
            }

            // Check that the spoofed method is a valid HTTP method and
            // update the request object accordingly.
            if method == "PUT" || method == "PATCH" || method == "DELETE" {
                r.Method = method
            }
        }

        // Call the next handler in the chain.
        next.ServeHTTP(w, r)
    })
}
</pre></code></figure>
<p>You can then use the middleware in your application like so:</p>
<figure class="go"><code><pre>package main

import (
    "html/template"
    "io"
    "log"
    "net/http"
)

const form = `
&lt;!DOCTYPE HTML&gt;
&lt;html&gt;
    &lt;body&gt;
        &lt;form method="POST" action="/"&gt;
            &lt;input type="hidden" name="_method" value="PUT"&gt;
            &lt;label&gt;Example field&lt;/label&gt;
            &lt;input type="text" name="example"&gt;
            &lt;button type="submit"&gt;Submit&lt;/button&gt;
        &lt;/form&gt;
    &lt;/body&gt;
&lt;/html&gt;
`

func main() {
    mux := http.NewServeMux()
    mux.HandleFunc("/", formHandler)

    // Wrap the servemux with the MethodOverride middleware.
    err := http.ListenAndServe(":4000", MethodOverride(mux))
    log.Println(err)
}

func formHandler(w http.ResponseWriter, r *http.Request) {
    switch r.Method {
    case "GET":
        t, err := template.New("form").Parse(form)
        if err != nil {
            http.Error(w, err.Error(), 500)
        }
        t.Execute(w, nil)
    case "PUT":
        io.WriteString(w, "This is a PUT request")
    default:
        http.Error(w, http.StatusText(405), 405)
    }
}
</pre></code></figure>
    ]]></description>
  </item>
  <item>
    <pubDate>Tue, 10 Apr 2018 12:00:00 GMT</pubDate>
    <link>https://www.alexedwards.net/blog/serverless-api-with-go-and-aws-lambda</link>
    <guid>https://www.alexedwards.net/blog/serverless-api-with-go-and-aws-lambda</guid>
    <title>How to build a Serverless API with Go and AWS Lambda</title>
    <description><![CDATA[
<p>Earlier this year AWS announced that their <a href="https://aws.amazon.com/lambda/">Lambda</a> service would now be providing first-class support for the Go language, which is a great step forward for any gophers (like myself) who fancy experimenting with serverless technology.</p>
<p>So in this post I'm going to talk through how to create a HTTPS API backed by AWS Lambda, building it up step-by-step. I found there to be quite a few gotchas in the process &mdash; especially if you're not familiar the AWS permissions system &mdash; and some rough edges in the way that Lamdba interfaces with the other AWS services. But once you get your head around these it works pretty well.</p>
<p>There's a lot of content to cover in this tutorial, so I've broken it down into the following seven steps:</p>
<ol>
    <li><a href="#setup-and-the-aws-cli">Setting up the AWS CLI</a></li>
    <li><a href="#creating-and-deploying-an-lambda-function">Creating and deploying an Lambda function</a></li>
    <li><a href="#hooking-it-up-to-dynamodb">Hooking it up to DynamoDB</a></li>
    <li><a href="#setting-up-the-https-api">Setting up the HTTPS API</a></li>
    <li><a href="#working-with-events">Working with events</a></li>
    <li><a href="#deploying-the-api">Deploying the API</a></li>
    <li><a href="#supporting-multiple-actions">Supporting multiple actions</a></li>
</ol>
<p>Throughout this post we'll work towards building an API with two actions:</p>
<table>
    <tr><th>Method</th><th>Path</th><th>Action</th></tr>
    <tr><td>GET</td><td>/books?isbn=xxx</td><td>Display information about a book with a specific ISBN</td></tr>
    <tr><td>POST</td><td>/books</td><td>Create a new book</td></tr>
</table>
<p>Where a book is a basic JSON record which looks like this:</p>
<figure class="plain"><code><pre>{"isbn":"978-1420931693","title":"The Republic","author":"Plato"}
</pre></code></figure>
<p>I'm keeping the API deliberately simple to avoid getting bogged-down in application-specific code, but once you've grasped the basics it's fairly clear how to extend the API to support additional routes and actions.</p>
<h2 id="setup-and-the-aws-cli">Setting up the AWS CLI</h2>
<ol>
<li>
<p>Throughout this tutorial we'll use the AWS CLI (command line interface) to configure our lambda functions and other AWS services. Installation and basic usage instructions can be <a href="https://docs.aws.amazon.com/cli/latest/userguide/cli-chap-welcome.html">found here</a>, but if you’re using a Debian-based system like Ubuntu you can install the CLI with <code>apt</code> and run it using the <code>aws</code> command:</p>
<figure class="shell"><code><pre>$ sudo apt install awscli
$ aws --version
<samp>aws-cli/1.11.139 Python/3.6.3 Linux/4.13.0-37-generic botocore/1.6.6</samp>
</pre></code></figure>
</li>
<li>
<p>Next we need to set up an AWS IAM user with <em>programmatic access</em> permission for the CLI to use. A guide on how to do this can be <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/id_users_create.html">found here</a>. For testing purposes you can attach the all-powerful <code>AdministratorAccess</code> managed policy to this user, but in practice I would recommend using a more restrictive policy. At the end of setting up the user you'll be given a access key ID and secret access key. Make a note of these &mdash; you’ll need them in the next step.</p>
</li>
<li>
<p>Configure the CLI to use the credentials of the IAM user you've just created using the <code>configure</code> command. You’ll also need to specify the <a href="https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/Concepts.RegionsAndAvailabilityZones.html">default region</a> and <a href="https://docs.aws.amazon.com/cli/latest/userguide/controlling-output.html">output format</a> you want the CLI to use.</p>
<figure class="shell"><code><pre>$ aws configure
<samp>AWS Access Key ID [None]: <var>access-key-ID</var>
AWS Secret Access Key [None]: <var>secret-access-key</var>
Default region name [None]: us-east-1
Default output format [None]: json</samp>
</pre></code></figure>
<p>(Throughout this tutorial I'll assume you're using the <code>us-east-1</code> region &mdash; you'll need to change the code snippets accordingly if you're using a different region.)</p>
</li>
</ol>
<h2 id="creating-and-deploying-an-lambda-function">Creating and deploying an Lambda function</h2>
<ol>
<li>
<p>Now for the exciting part: making a lambda function. If you're following along, go to your <code>$GOPATH/src</code> folder and create a <code>books</code> repository containing a <code>main.go</code> file.</p>
<figure class="shell"><code><pre>$ cd ~/go/src
$ mkdir books && cd books
$ touch main.go
</pre></code></figure>
</li>
<li>
<p>Next you'll need to install the <a href="https://github.com/aws/aws-lambda-go"></a><code>github.com/aws-lambda-go/lambda</code> package. This provides the essential libraries and types we need for creating a lambda function in Go.</p>
<figure class="shell"><code><pre>$ go get github.com/aws/aws-lambda-go/lambda
</pre></code></figure>
</li>
<li>
<p>Then open up the <code>main.go</code> file and add the following code:</p>
<figure class="file"><figcaption>File: books/main.go</figcaption><code><pre>package main

import (
    "github.com/aws/aws-lambda-go/lambda"
)

type book struct {
    ISBN   string `json:"isbn"`
    Title  string `json:"title"`
    Author string `json:"author"`
}

func show() (*book, error) {
    bk := &book{
        ISBN:   "978-1420931693",
        Title:  "The Republic",
        Author: "Plato",
    }

    return bk, nil
}

func main() {
    lambda.Start(show)
}
</pre></code></figure>

<p>In the <code>main()</code> function we call <code>lambda.Start()</code> and pass in the <code>show</code> function as the lambda <em>handler</em>. In this case the handler simply initializes and returns a new <code>book</code> object.</p>
<p>Lamdba handlers can take a variety of different signatures and reflection is used to determine exactly which signature you're using. The full list of supported forms is&hellip;</p>
<figure class="plain"><code><pre>func()
func() error
func(TIn) error
func() (TOut, error)
func(TIn) (TOut, error)
func(context.Context) error
func(context.Context, TIn) error
func(context.Context) (TOut, error)
func(context.Context, TIn) (TOut, error)
</pre></code></figure>
<p>&hellip; where the <code>TIn</code> and <code>TOut</code> parameters are objects that can be marshaled (and unmarshalled) by Go's <code>encoding/json</code> package.</p>
</li>
<li>
<p>The next step is to build an executable from the <code>books</code> package using <code>go build</code>. In the code snippet below I'm using the <code>-o</code> flag to save the executable to <code>/tmp/main</code> but you can save it to any location (and name it whatever) you wish.</p>
<figure class="shell"><code><pre>$ env GOOS=linux GOARCH=amd64 go build -o /tmp/main books
</pre></code></figure>
<p>Important: as part of this command we're using <code>env</code> to temporarily set two environment variables for the duration for the command (<code>GOOS=linux</code> and <code>GOARCH=amd64</code>). These instruct the Go compiler to create an executable suitable for use with a linux OS and amd64 architecture &mdash; which is what it will be running on when we deploy it to AWS.</p>
</li>
<li>
<p>AWS requires us to upload our lambda functions in a zip file, so let's make a <code>main.zip</code> zip file containing the executable we just made:</p>
<figure class="shell"><code><pre>$ zip -j /tmp/main.zip /tmp/main
</pre></code></figure>
<p>Note that the executable must be <em>in the root</em> of the zip file &mdash; not in a folder within the zip file. To ensure this I've used the <code>-j</code> flag in the snippet above to junk directory names.</p>
</li>
<li>
<p>The next step is a bit awkward, but critical to getting our lambda function working properly. We need to set up an IAM role which defines the permission that our <em>lambda function will have when it is running</em>.</p>
<p>For now let's set up a <code>lambda-books-executor</code> role and attach the <code>AWSLambdaBasicExecutionRole</code> managed policy to it. This will give our lambda function the basic permissions it need to run and log to the AWS cloudwatch service.</p>
<p>First we have to create a <em>trust policy</em> JSON file. This will essentially instruct AWS to allow lambda services to assume the <code>lambda-books-executor</code> role:</p>
<figure class="file"><figcaption>File: /tmp/trust-policy.json</figcaption><code><pre>{
    "Version": "2012-10-17",
    "Statement": [
        {
            "Effect": "Allow",
            "Principal": {
                "Service": "lambda.amazonaws.com"
            },
            "Action": "sts:AssumeRole"
        }
    ]
}
</pre></code></figure>
<p>Then use the <code>aws iam create-role</code> command to create the role with this trust policy:</p>
<figure class="shell"><code><pre>$ aws iam create-role --role-name lambda-books-executor \
--assume-role-policy-document file:///tmp/trust-policy.json
<samp>{
    "Role": {
        "Path": "/",
        "RoleName": "lambda-books-executor",
        "RoleId": "AROAIWSQS2RVEWIMIHOR2",
        "Arn": "arn:aws:iam::<var>account-id</var>:role/lambda-books-executor",
        "CreateDate": "2018-04-05T10:22:32.567Z",
        "AssumeRolePolicyDocument": {
            "Version": "2012-10-17",
            "Statement": [
                {
                    "Effect": "Allow",
                    "Principal": {
                        "Service": "lambda.amazonaws.com"
                    },
                    "Action": "sts:AssumeRole"
                }
            ]
        }
    }
}</samp>
</pre></code></figure>
<p>Make a note of the returned ARN (Amazon Resource Name) &mdash; you'll need this in the next step.</p>
<p>Now the <code>lambda-books-executor</code> role has been created we need to specify the permissions that the role has. The easiest way to do this it to use the <code>aws iam attach-role-policy</code> command, passing in the ARN of <code>AWSLambdaBasicExecutionRole</code> permission policy like so:</p>
<figure class="shell"><code><pre>$ aws iam attach-role-policy --role-name lambda-books-executor \
--policy-arn arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
</pre></code></figure>
<p>Note: you can find a list of other permission policies that might be useful <a href="https://docs.aws.amazon.com/lambda/latest/dg/intro-permission-model.html#lambda-intro-execution-role">here</a>.</p>
</li>
<li>
<p>Now we're ready to actually deploy the lambda function to AWS, which we can do using the <code>aws lambda create-function</code> command. This takes the following flags and can take a minute or two to run.</p>
<table>
<tr>
    <td><code>--function-name</code></td>
    <td>Thethat  name your lambda function will be called within AWS</td>
</tr>
<tr>
    <td><code>--runtime </code></td>
    <td>The runtime environment for the lambda function (in our case <code>"go1.x"</code>)</td>
</tr>
<tr>
    <td><code>--role</code></td>
    <td>The ARN of the role you want the lambda function to assume when it is running (from step 6 above)</td>
</tr>
<tr>
    <td><code>--handler</code> </td>
    <td>The name of the executable in the root of the zip file</td>
</tr>
<tr>
    <td><code>--zip-file</code></td>
    <td>Path to the zip file</td>
</tr>
</table>
<p>Go ahead and try deploying it:</p>
<figure class="shell"><code><pre>$ aws lambda create-function --function-name books --runtime go1.x \
--role arn:aws:iam::<var>account-id</var>:role/lambda-books-executor \
--handler main --zip-file fileb:///tmp/main.zip
<samp>{
    "FunctionName": "books",
    "FunctionArn": "arn:aws:lambda:us-east-1:<var>account-id</var>:function:books",
    "Runtime": "go1.x",
    "Role": "arn:aws:iam::<var>account-id</var>:role/lambda-books-executor",
    "Handler": "main",
    "CodeSize": 2791699,
    "Description": "",
    "Timeout": 3,
    "MemorySize": 128,
    "LastModified": "2018-04-05T10:25:05.343+0000",
    "CodeSha256": "O20RZcdJTVcpEiJiEwGL2bX1PtJ/GcdkusIEyeO9l+8=",
    "Version": "$LATEST",
    "TracingConfig": {
        "Mode": "PassThrough"
    }
}</samp>
</pre></code></figure>
</li>
<li>
<p>So there it is. Our lambda function has been deployed and is now ready to use. You can try it out by using the <code>aws lambda invoke</code> command (which requires you to specify an output file for the response &mdash; I've used <code>/tmp/output.json</code> in the snippet below).</p>
<figure class="shell"><code><pre>$ aws lambda invoke --function-name books /tmp/output.json
<samp>{
    "StatusCode": 200
}</samp>
$ cat /tmp/output.json
<samp>{"isbn":"978-1420931693","title":"The Republic","author":"Plato"}</samp>
</pre></code></figure>
<p>If you're following along hopefully you've got the same response. Notice how the <code>book</code> object we initialized in our Go code has been automatically marshaled to JSON?</p>
</li>
</ol>
<h2 id="hooking-it-up-to-dynamodb">Hooking it up to DynamoDB</h2>
<ol>
<li>
<p>In this section we're going to add a persistence layer for our data which can be accessed by our lambda function. For this I'll use Amazon DynamoDB (it integrates nicely with AWS lambda and has a generous free-usage tier). If you're not familiar with DynamoDB, there's a decent run down of <a href="https://www.tutorialspoint.com/dynamodb/dynamodb_overview.htm">the basics here</a>.</p>
<p>The first thing we need to do is create a <code>Books</code> table to hold the book records. DynanmoDB is schema-less, but we do need to define the partion key (a bit like a primary key) on the ISBN field. We can do this in one command like so:</p>
<figure class="shell"><code><pre>$ aws dynamodb create-table --table-name Books \
--attribute-definitions AttributeName=ISBN,AttributeType=S \
--key-schema AttributeName=ISBN,KeyType=HASH \
--provisioned-throughput ReadCapacityUnits=5,WriteCapacityUnits=5
<samp>{
    "TableDescription": {
        "AttributeDefinitions": [
            {
                "AttributeName": "ISBN",
                "AttributeType": "S"
            }
        ],
        "TableName": "Books",
        "KeySchema": [
            {
                "AttributeName": "ISBN",
                "KeyType": "HASH"
            }
        ],
        "TableStatus": "CREATING",
        "CreationDateTime": 1522924177.507,
        "ProvisionedThroughput": {
            "NumberOfDecreasesToday": 0,
            "ReadCapacityUnits": 5,
            "WriteCapacityUnits": 5
        },
        "TableSizeBytes": 0,
        "ItemCount": 0,
        "TableArn": "arn:aws:dynamodb:us-east-1:<var>account-id</var>:table/Books"
    }
}</samp>
</pre></code></figure>
</li>
<li>
<p>Then lets add a couple of items using the <code>put-item</code> command, which we'll use in the next steps.</p>
<figure class="shell"><code><pre>$ aws dynamodb put-item --table-name Books --item '{"ISBN": {"S": "978-1420931693"}, "Title": {"S": "The Republic"}, "Author":  {"S": "Plato"}}'
$ aws dynamodb put-item --table-name Books --item '{"ISBN": {"S": "978-0486298238"}, "Title": {"S": "Meditations"},  "Author":  {"S": "Marcus Aurelius"}}'
</pre></code></figure>
</li>
<li>
<p>The next thing to do is update our Go code so that our lambda handler can connect to and use the DynamoDB layer. For this you'll need to install the <code>github.com/aws/aws-sdk-go</code> package which provides libraries for working with DynamoDB (and other AWS services).</p>
<figure class="shell"><code><pre>$ go get github.com/aws/aws-sdk-go
</pre></code></figure>
</li>
<li>
<p>Now for the code. To keep a bit of separation create a new <code>db.go</code> file in your <code>books</code> repository:</p>
<figure class="shell"><code><pre>$ touch ~/go/src/books/db.go
</pre></code></figure>
<p>And add the following code:</p>
<figure class="file"><figcaption>File: books/db.go</figcaption><code><pre>package main

import (
    "github.com/aws/aws-sdk-go/aws"
    "github.com/aws/aws-sdk-go/aws/session"
    "github.com/aws/aws-sdk-go/service/dynamodb"
    "github.com/aws/aws-sdk-go/service/dynamodb/dynamodbattribute"
)

// Declare a new DynamoDB instance. Note that this is safe for concurrent
// use.
var db = dynamodb.New(session.New(), aws.NewConfig().WithRegion("us-east-1"))

func getItem(isbn string) (*book, error) {
    // Prepare the input for the query.
    input := &dynamodb.GetItemInput{
        TableName: aws.String("Books"),
        Key: map[string]*dynamodb.AttributeValue{
            "ISBN": {
                S: aws.String(isbn),
            },
        },
    }

    // Retrieve the item from DynamoDB. If no matching item is found
    // return nil.
    result, err := db.GetItem(input)
    if err != nil {
        return nil, err
    }
    if result.Item == nil {
        return nil, nil
    }

    // The result.Item object returned has the underlying type
    // map[string]*AttributeValue. We can use the UnmarshalMap helper
    // to parse this straight into the fields of a struct. Note:
    // UnmarshalListOfMaps also exists if you are working with multiple
    // items.
    bk := new(book)
    err = dynamodbattribute.UnmarshalMap(result.Item, bk)
    if err != nil {
        return nil, err
    }

    return bk, nil
}
</pre></code></figure>
<p>And then update the <code>main.go</code> to use this new code:</p>
<figure class="file"><figcaption>File: books/main.go</figcaption><code><pre>package main

import (
    "github.com/aws/aws-lambda-go/lambda"
)

type book struct {
    ISBN   string `json:"isbn"`
    Title  string `json:"title"`
    Author string `json:"author"`
}

func show() (*book, error) {
    // Fetch a specific book record from the DynamoDB database. We'll
    // make this more dynamic in the next section.
    bk, err := getItem("978-0486298238")
    if err != nil {
        return nil, err
    }

    return bk, nil
}

func main() {
    lambda.Start(show)
}
</pre></code></figure>
</li>
<li>
<p>Save the files, then rebuild and zip up the lambda function so it's ready to deploy:</p>
<figure class="shell"><code><pre>$ env GOOS=linux GOARCH=amd64 go build -o /tmp/main books
$ zip -j /tmp/main.zip /tmp/main
</pre></code></figure>
</li>
<li>
<p>Re-deploying a lambda function is easier than creating it for the first time &mdash; we can use the <code>aws lambda update-function-code</code> command like so:</p>
<figure class="shell"><code><pre>$ aws lambda update-function-code --function-name books \
--zip-file fileb:///tmp/main.zip
</pre></code></figure>
</li>
<li>
<p>Let's try executing the lambda function now:</p>
<figure class="shell"><code><pre>$ aws lambda invoke --function-name books /tmp/output.json
<samp>{
    "StatusCode": 200,
    "FunctionError": "Unhandled"
}</samp>
$ cat /tmp/output.json
<samp>{"errorMessage":"AccessDeniedException: User: arn:aws:sts::<var>account-id</var>:assumed-role/lambda-books-executor/books is not authorized to perform: dynamodb:GetItem on resource: arn:aws:dynamodb:us-east-1:<var>account-id</var>:table/Books\n\tstatus code: 400, request id: 2QSB5UUST6F0R3UDSVVVODTES3VV4KQNSO5AEMVJF66Q9ASUAAJG","errorType":"requestError"}</samp>
</pre></code></figure>
<p>Ah. There's a slight problem. We can see from the output message that our lambda function (specifically, the <code>lambda-books-executor</code> role) doesn't have the necessary permissions to run <code>GetItem</code> on a DynamoDB instance. Let's fix that now.</p>
</li>
<li>
<p>Create a privilege policy file that gives <code>GetItem</code> and <code>PutItem</code> privileges on DynamoDB like so:</p>
<figure class="file"><figcaption>File: /tmp/privilege-policy.json</figcaption><code><pre>{
    "Version": "2012-10-17",
    "Statement": [
        {
            "Effect": "Allow",
            "Action": [
                "dynamodb:PutItem",
                "dynamodb:GetItem",
            ],
            "Resource": "*"
        }
    ]
}
</pre></code></figure>
<p>And then attach it to the <code>lambda-books-executor</code> role using the <code>aws iam put-role-policy</code> command:</p>
<figure class="shell"><code><pre>$ aws iam put-role-policy --role-name lambda-books-executor \
--policy-name dynamodb-item-crud-role \
--policy-document file:///tmp/privilege-policy.json
</pre></code></figure>
<p>As a side note, AWS has some managed policies called <code>AWSLambdaDynamoDBExecutionRole</code> and <code>AWSLambdaInvocation-DynamoDB</code> which sound like they would do the trick. But neither of them actually provide <code>GetItem</code> or <code>PutItem</code> privileges. Hence the need to roll our own policy.</p>
</li>
<li>
<p>Let's try executing the lambda function again. It should work smoothly this time and return information about the book with ISBN <code>978-0486298238</code>.</p>
<figure class="shell"><code><pre>$ aws lambda invoke --function-name books /tmp/output.json
<samp>{
    "StatusCode": 200
}</samp>
$ cat /tmp/output.json
<samp>{"isbn":"978-0486298238","title":"Meditations","author":"Marcus Aurelius"}</samp>
</pre></code></figure>
</li>
</ol>
<h2 id="setting-up-the-https-api">Setting up the HTTPS API</h2>
<ol>
<li>
<p>So our lambda function is now working nicely and communicating with DynamoDB. The next thing to do is set up a way to access the lamdba function over HTTPS, which we can do using the AWS API Gateway service.</p>
<p>But before we go any further, it's worth taking a moment to think about the structure of our project. Let's say we have grand plans for our lamdba function to be part of a bigger <code>bookstore</code> API which deals with information about books, customers, recommendations and other things.</p>
<p>There's three basic options for structuring this using AWS Lambda:</p>
<ul>
<li><strong>Microservice style</strong> &mdash; Each lambda function is responsible for one action only. For example, there are 3 separate lambda functions for showing, creating and deleting a book.</li>
<li><strong>Service style</strong> &mdash; Each lambda function is responsible for a group of related actions. For example, one lambda function handles all book-related actions, but customer-related actions are kept in a separate lambda function.</li>
<li><strong>Monolith style</strong> &mdash; One lambda function manages all the bookstore actions.</li>
</ul>
<p>Each of these options is valid, and theres some good discussion of the pros and cons <a href="https://serverless.com/blog/serverless-architecture-code-patterns/">here</a>.</p>
<p>For this tutorial we'll opt for a service style, and have one <code>books</code> lambda function handle the different book-related actions. This means that we'll need to implement some form of routing <em>within</em> our lambda function, which I'll cover later in the post. But for now&hellip;</p>
</li>
<li>
<p>Go ahead and create a <code>bookstore</code> API using the <code>aws apigateway create-rest-api</code> command like so:</p>
<figure class="shell"><code><pre>$ aws apigateway create-rest-api --name bookstore
<samp>{
    "id": "<var>rest-api-id</var>",
    "name": "bookstore",
    "createdDate": 1522926250
}</samp>
</pre></code></figure>
<p>Note down the <code>rest-api-id</code> value that this returns, we'll be using it a lot in the next few steps.</p>
</li>
<li>
<p>Next we need to get the id of the root API resource (<code>"/"</code>). We can retrieve this using the <code>aws apigateway get-resources</code> command like so:</p>
<figure class="shell"><code><pre>$ aws apigateway get-resources --rest-api-id <var>rest-api-id</var>
<samp>{
    "items": [
        {
            "id": "<var>root-path-id</var>",
            "path": "/"
        }
    ]
}</samp>
</pre></code></figure>
<p>Again, keep a note of the <code>root-path-id</code> value this returns.</p>
</li>
<li>
<p>Now we need to create a new resource <em>under the root path</em> &mdash; specifically a resource for the URL path <code>/books</code>. We can do this by using the <code>aws apigateway create-resource</code> command with the <code>--path-part</code> parameter like so:</p>
<figure class="shell"><code><pre>$ aws apigateway create-resource --rest-api-id <var>rest-api-id</var> \
--parent-id <var>root-path-id</var> --path-part books
<samp>{
    "id": "<var>resource-id</var>",
    "parentId": "<var>root-path-id</var>",
    "pathPart": "books",
    "path": "/books"
}</samp>
</pre></code></figure>
<p>Again, note the <code>resource-id</code> this returns, we'll need it in the next step.</p>
<p>Note that it's possible to include placeholders within your path by wrapping part of the path in curly braces. For example, a <code>--path-part</code> parameter of <code>books/{id}</code> would match requests to <code>/books/foo</code> and <code>/books/bar</code>, and the value of <code>id</code> would be made available to your lambda function via an events object (which we'll cover later in the post). You can also make a placeholder greedy by postfixing it with a <code>+</code>. A common idiom is to use the parameter <code>--path-part {proxy+}</code> if you want to match all requests regardless of their path.</p>
</li>
<li>
<p>But we're not doing either of those things. Let's get back to our <code>/books</code> resource and use the <code>aws apigateway put-method</code> command to register the HTTP method of <code>ANY</code>. This will mean that our <code>/books</code> resource will respond to all requests regardless of their HTTP method.</p>
<figure class="shell"><code><pre>$ aws apigateway put-method --rest-api-id <var>rest-api-id</var> \
--resource-id <var>resource-id</var> --http-method ANY \
--authorization-type NONE
<samp>{
    "httpMethod": "ANY",
    "authorizationType": "NONE",
    "apiKeyRequired": false
}</samp>
</pre></code></figure>
</li>
<li>
<p>Now we're all set to integrate the resource with our lambda function, which we can do using the <code>aws apigateway put-integration</code> command. This command has a few parameters that need a quick explanation:</p>
<ul>
<li>The <code>--type</code> parameter should be <code>AWS_PROXY</code>. When this is used the AWS API Gateway will send information about the HTTP request as an 'event' to the lambda function. It will also automatically transform the output from the lambda function to a HTTP response.</li>
<li>The <code>--integration-http-method</code> parameter must be <code>POST</code>. Don't confuse this with what HTTP methods your API resource responds to.</li>
<li>The <code>--uri</code> parameter needs to take the format:<br><br>
<figure class="plain"><code><pre>arn:aws:apigateway:us-east-1:lambda:path/2015-03-31/functions/<var>your-lambda-function-arn</var>/invocations
</pre></code></figure>
</li>
</ul>
<p>With those things in mind, your command should look a bit like this:</p>
<figure class="shell"><code><pre>$ aws apigateway put-integration --rest-api-id <var>rest-api-id</var> \
--resource-id <var>resource-id</var> --http-method ANY --type AWS_PROXY \
--integration-http-method POST \
--uri arn:aws:apigateway:us-east-1:lambda:path/2015-03-31/functions/arn:aws:lambda:us-east-1:<var>account-id</var>:function:books/invocations
<samp>{
    "type": "AWS_PROXY",
    "httpMethod": "POST",
    "uri": "arn:aws:apigateway:us-east-1:lambda:path/2015-03-31/functions/arn:aws:lambda:us-east-1:<var>account-id</var>:function:books/invocations",
    "passthroughBehavior": "WHEN_NO_MATCH",
    "cacheNamespace": "qtdn5h",
    "cacheKeyParameters": []
}</samp>
</pre></code></figure>
</li>
<li>
<p>Alright, let's give this a whirl. We can send a test request to the resource we just made using the <code>aws apigateway test-invoke-method</code> command like so:</p>
<figure class="shell"><code><pre>$ aws apigateway test-invoke-method --rest-api-id <var>rest-api-id</var> --resource-id <var>resource-id</var> --http-method "GET"
<samp>{
    "status": 500,
    "body": "{\"message\": \"Internal server error\"}",
    "headers": {},
    "log": "Execution log for request test-request\nThu Apr 05 11:07:54 UTC 2018 : Starting execution for request: test-invoke-request\nThu Apr 05 11:07:54 UTC 2018 : HTTP Method: GET, Resource Path: /books\nThu Apr 05 11:07:54 UTC 2018 : Method request path: {}[TRUNCATED]Thu Apr 05 11:07:54 UTC 2018 : Sending request to https://lambda.us-east-1.amazonaws.com/2015-03-31/functions/arn:aws:lambda:us-east-1:<var>account-id</var>:function:books/invocations\nThu Apr 05 11:07:54 UTC 2018 : Execution failed due to configuration error: Invalid permissions on Lambda function\nThu Apr 05 11:07:54 UTC 2018 : Method completed with status: 500\n",
    "latency": 39
}</samp>
</pre></code></figure>
<p>Ah. So that hasn't quite worked. If you take a look through the outputted log information you should see that the problem appears to be:</p>
<p><code>Execution failed due to configuration error: Invalid permissions on Lambda function</code></p>
<p>This is happening because our <code>bookstore</code> API gateway <em>doesn't have permissions to execute our lambda function.</em></p>
</li>
<li>
<p>The easiest way to fix that is to use the <code>aws lambda add-permission</code> command to give our API permissions to invoke it, like so:</p>
<figure class="shell"><code><pre>$ aws lambda add-permission --function-name books --statement-id <var>a-GUID</var> \
--action lambda:InvokeFunction --principal apigateway.amazonaws.com \
--source-arn arn:aws:execute-api:us-east-1:<var>account-id</var>:<var>rest-api-id</var>/*/*/*
<samp>{
    "Statement": "{\"Sid\":\"6d658ce7-3899-4de2-bfd4-fefb939f731\",\"Effect\":\"Allow\",\"Principal\":{\"Service\":\"apigateway.amazonaws.com\"},\"Action\":\"lambda:InvokeFunction\",\"Resource\":\"arn:aws:lambda:us-east-1:<var>account-id</var>:function:books\",\"Condition\":{\"ArnLike\":{\"AWS:SourceArn\":\"arn:aws:execute-api:us-east-1:<var>account-id</var>:<var>rest-api-id</var>/*/*/*\"}}}"
}</samp>
</pre></code></figure>
<p>Note that the <code>--statement-id</code> parameter needs to be a globally unique identifier. This could be a <a href="https://www.guidgenerator.com/">random ID</a> or something more descriptive.</p>
</li>
<li><p>Alright, let's try again:</p>
<figure class="shell"><code><pre>$ aws apigateway test-invoke-method --rest-api-id <var>rest-api-id</var> --resource-id <var>resource-id</var> --http-method "GET"
<samp>{
    "status": 502,
    "body": "{\"message\": \"Internal server error\"}",
    "headers": {},
    "log": "Execution log for request test-request\nThu Apr 05 11:12:53 UTC 2018 : Starting execution for request: test-invoke-request\nThu Apr 05 11:12:53 UTC 2018 : HTTP Method: GET, Resource Path: /books\nThu Apr 05 11:12:53 UTC 2018 : Method request path: {}\nThu Apr 05 11:12:53 UTC 2018 : Method request query string: {}\nThu Apr 05 11:12:53 UTC 2018 : Method request headers: {}\nThu Apr 05 11:12:53 UTC 2018 : Endpoint response body before transformations: {\"isbn\":\"978-0486298238\",\"title\":\"Meditations\",\"author\":\"Marcus Aurelius\"}\nThu Apr 05 11:12:53 UTC 2018 : Endpoint response headers: {X-Amz-Executed-Version=$LATEST, x-amzn-Remapped-Content-Length=0, Connection=keep-alive, x-amzn-RequestId=48d29098-38c2-11e8-ae15-f13b670c5483, Content-Length=74, Date=Thu, 05 Apr 2018 11:12:53 GMT, X-Amzn-Trace-Id=root=1-5ac604b5-cf29dd70cd08358f89853b96;sampled=0, Content-Type=application/json}\nThu Apr 05 11:12:53 UTC 2018 : Execution failed due to configuration error: Malformed Lambda proxy response\nThu Apr 05 11:12:53 UTC 2018 : Method completed with status: 502\n",
    "latency": 211
}</samp>
</pre></code></figure>
<p>So unfortunately there's still an error, but the message has now changed:</p>
<p><code>Execution failed due to configuration error: Malformed Lambda proxy response</code></p>
<p>And if you look closely at the output you'll see the information:</p>
<p><code>Endpoint response body before transformations: {\"isbn\":\"978-0486298238\",\"title\":\"Meditations\",\"author\":\"Marcus Aurelius\"}</code></p>
<p>So there's some definite progress here. Our API is talking to our lambda function and is receiving the correct response (a <code>book</code> object marshalled to JSON). It's just that the AWS API Gateway considers the response to be in the wrong format.</p>
<p>This is because, when you're using the API Gateway's lambda proxy integration, the return value from the lambda function <strong>must</strong> be in the following JSON format:</p>
<figure class="plain"><code><pre>{
    "isBase64Encoded": true|false,
    "statusCode": httpStatusCode,
    "headers": { "headerName": "headerValue", ... },
    "body": "..."
}
</pre></code></figure>
<p>So to fix this it's time to head back to our Go code and make some alterations.</p>
</li>
</ol>
<h2 id="working-with-events">Working with events</h2>
<ol>
<li>
<p>The easiest way to provide the responses that the AWS API Gateway needs is to install the <code>github.com/aws/aws-lambda-go/events</code> package:</p>
<figure class="shell"><code><pre>go get github.com/aws/aws-lambda-go/events
</pre></code></figure>
<p>This provides a couple of useful types (<code>APIGatewayProxyRequest</code> and <code>APIGatewayProxyResponse</code>) which contain information about incoming HTTP requests and allow us to construct responses that the API Gateway understands.
<figure class="plain"><code><pre>type APIGatewayProxyRequest struct {
    Resource              string                        `json:"resource"` // The resource path defined in API Gateway
    Path                  string                        `json:"path"`     // The url path for the caller
    HTTPMethod            string                        `json:"httpMethod"`
    Headers               map[string]string             `json:"headers"`
    QueryStringParameters map[string]string             `json:"queryStringParameters"`
    PathParameters        map[string]string             `json:"pathParameters"`
    StageVariables        map[string]string             `json:"stageVariables"`
    RequestContext        APIGatewayProxyRequestContext `json:"requestContext"`
    Body                  string                        `json:"body"`
    IsBase64Encoded       bool                          `json:"isBase64Encoded,omitempty"`
}
</pre></code></figure>
<figure class="plain"><code><pre>type APIGatewayProxyResponse struct {
    StatusCode      int               `json:"statusCode"`
    Headers         map[string]string `json:"headers"`
    Body            string            `json:"body"`
    IsBase64Encoded bool              `json:"isBase64Encoded,omitempty"`
}
</pre></code></figure>
</li>
<li>
<p>Let's go back to our <code>main.go</code> file and update our lambda handler so that it uses the signature:</p>
<figure class="plain"><code><pre>func(events.APIGatewayProxyRequest) (events.APIGatewayProxyResponse, error)
</pre></code></figure>
<p>Essentially, the handler will accept a <code>APIGatewayProxyRequest</code> object which contains a bunch of information about the HTTP request, and return a <code>APIGatewayProxyResponse</code> object (which is marshalable into a JSON response suitable for the AWS API Gateway).</p>
<figure class="file"><figcaption>File: books/main.go</figcaption><code><pre>package main

import (
    "encoding/json"
    "fmt"
    "log"
    "net/http"
    "os"
    "regexp"

    "github.com/aws/aws-lambda-go/events"
    "github.com/aws/aws-lambda-go/lambda"
)

var isbnRegexp = regexp.MustCompile(`[0-9]{3}\-[0-9]{10}`)
var errorLogger = log.New(os.Stderr, "ERROR ", log.Llongfile)

type book struct {
    ISBN   string `json:"isbn"`
    Title  string `json:"title"`
    Author string `json:"author"`
}

func show(req events.APIGatewayProxyRequest) (events.APIGatewayProxyResponse, error) {
    // Get the `isbn` query string parameter from the request and
    // validate it.
    isbn := req.QueryStringParameters["isbn"]
    if !isbnRegexp.MatchString(isbn) {
        return clientError(http.StatusBadRequest)
    }

    // Fetch the book record from the database based on the isbn value.
    bk, err := getItem(isbn)
    if err != nil {
        return serverError(err)
    }
    if bk == nil {
        return clientError(http.StatusNotFound)
    }

    // The APIGatewayProxyResponse.Body field needs to be a string, so
    // we marshal the book record into JSON.
    js, err := json.Marshal(bk)
    if err != nil {
        return serverError(err)
    }

    // Return a response with a 200 OK status and the JSON book record
    // as the body.
    return events.APIGatewayProxyResponse{
        StatusCode: http.StatusOK,
        Body:       string(js),
    }, nil
}

// Add a helper for handling errors. This logs any error to os.Stderr
// and returns a 500 Internal Server Error response that the AWS API
// Gateway understands.
func serverError(err error) (events.APIGatewayProxyResponse, error) {
    errorLogger.Println(err.Error())

    return events.APIGatewayProxyResponse{
        StatusCode: http.StatusInternalServerError,
        Body:       http.StatusText(http.StatusInternalServerError),
    }, nil
}

// Similarly add a helper for send responses relating to client errors.
func clientError(status int) (events.APIGatewayProxyResponse, error) {
    return events.APIGatewayProxyResponse{
        StatusCode: status,
        Body:       http.StatusText(status),
    }, nil
}

func main() {
    lambda.Start(show)
}
</pre></code></figure>
<p>Notice how in all cases the <code>error</code> value returned from our lambda handler is now <code>nil</code>? We have to do this because the API Gateway doesn't accept <code>error</code> objects when you're using it in conjunction with a lambda proxy integration (they would result in a 'malformed response' errors again). So we need to manage errors fully within our lambda function and return the appropriate HTTP response. In essence, this means that the return parameter of <code>error</code> is superfluous, but we still need to include it to have a valid signature for the lambda function.</p>
</li>
<li>
<p>Anyway, save the file and rebuild and redeploy the lambda function:</p>
<figure class="shell"><code><pre>$ env GOOS=linux GOARCH=amd64 go build -o /tmp/main books
$ zip -j /tmp/main.zip /tmp/main
$ aws lambda update-function-code --function-name books \
--zip-file fileb:///tmp/main.zip
</pre></code></figure>
</li>
<li>
<p>And if you test it again now it should work as expected. Give it a try with different <code>isbn</code> values in the query string:</p>
<figure class="shell"><code><pre>$ aws apigateway test-invoke-method --rest-api-id <var>rest-api-id</var> \
--resource-id <var>resource-id</var> --http-method "GET" \
--path-with-query-string "/books?isbn=978-1420931693"
<samp>{
    "status": 200,
    "body": "{\"isbn\":\"978-1420931693\",\"title\":\"The Republic\",\"author\":\"Plato\"}",
    "headers": {
        "X-Amzn-Trace-Id": "sampled=0;root=1-5ac60df0-0ea7a560337129d1fde588cd"
    },
    "log": [TRUNCATED],
    "latency": 1232
}</samp>
$ aws apigateway test-invoke-method --rest-api-id <var>rest-api-id</var> \
--resource-id <var>resource-id</var> --http-method "GET" \
--path-with-query-string "/books?isbn=foobar"
<samp>{
    "status": 400,
    "body": "Bad Request",
    "headers": {
        "X-Amzn-Trace-Id": "sampled=0;root=1-5ac60e1c-72fad7cfa302fd32b0a6c702"
    },
    "log": [TRUNCATED],
    "latency": 25
}</samp>
</pre></code></figure>
</li>
<li>
<p>As a side note, anything sent to <code>os.Stderr</code> will be logged to the AWS Cloudwatch service. So if you've set up an error logger like we have in the code above, you can query Cloudwatch for errors like so:</p>
<figure class="shell"><code><pre>$ aws logs filter-log-events --log-group-name /aws/lambda/books \
--filter-pattern "ERROR"
</pre></code></figure>
</li>
</ol>
<h2 id="deploying-the-api">Deploying the API</h2>
<ol>
<li>
<p>Now that the API Gateway is working properly it's time to make it live. We can do this with the <code>aws apigateway create-deployment</code> command like so:</p>
<figure class="shell"><code><pre>$ aws apigateway create-deployment --rest-api-id <var>rest-api-id</var> \
--stage-name staging
<samp>{
    "id": "4pdblq",
    "createdDate": 1522929303
}</samp>
</pre></code></figure>
<p>In the code above I've given the deployed API using the name <code>staging</code>, but you can call it anything that you wish.</p>
</li>
<li>
<p>Once deployed your API should be accessible at the URL:</p>
<figure class="plain"><code><pre>https://<var>rest-api-id</var>.execute-api.us-east-1.amazonaws.com/staging
</pre></code></figure>
<p>Go ahead and give it a try using curl. It should work as you expect:</p>
<figure class="shell"><code><pre>$ curl https://<var>rest-api-id</var>.execute-api.us-east-1.amazonaws.com/staging/books?isbn=978-1420931693
<samp>{"isbn":"978-1420931693","title":"The Republic","author":"Plato"}</samp>
$ curl https://<var>rest-api-id</var>.execute-api.us-east-1.amazonaws.com/staging/books?isbn=foobar
<samp>Bad Request</samp>
</pre></code></figure>
</li>
</ol>
<h2 id="supporting-multiple-actions">Supporting multiple actions</h2>
<ol>
<li>
<p>Let's add support for a <code>POST /books</code> action. We want this to read and validate a new book record (from a JSON HTTP request body) and then add it to the DynamoDB table.</p>
<p>Now that the different AWS services are hooked up, extending our lambda function to support additional actions is perhaps the most straightforward part of this tutorial, as it can be managed purely within our Go code.</p>
<p>First update the <code>db.go</code> file to include a new <code>putItem</code> function like so:</p>
<figure class="file"><figcaption>File: books/db.go</figcaption><code><pre>package main

import (
    "github.com/aws/aws-sdk-go/aws"
    "github.com/aws/aws-sdk-go/aws/session"
    "github.com/aws/aws-sdk-go/service/dynamodb"
    "github.com/aws/aws-sdk-go/service/dynamodb/dynamodbattribute"
)

var db = dynamodb.New(session.New(), aws.NewConfig().WithRegion("us-east-1"))

func getItem(isbn string) (*book, error) {
    input := &dynamodb.GetItemInput{
        TableName: aws.String("Books"),
        Key: map[string]*dynamodb.AttributeValue{
            "ISBN": {
                S: aws.String(isbn),
            },
        },
    }

    result, err := db.GetItem(input)
    if err != nil {
        return nil, err
    }
    if result.Item == nil {
        return nil, nil
    }

    bk := new(book)
    err = dynamodbattribute.UnmarshalMap(result.Item, bk)
    if err != nil {
        return nil, err
    }

    return bk, nil
}

// Add a book record to DynamoDB.
func putItem(bk *book) error {
    input := &dynamodb.PutItemInput{
        TableName: aws.String("Books"),
        Item: map[string]*dynamodb.AttributeValue{
            "ISBN": {
                S: aws.String(bk.ISBN),
            },
            "Title": {
                S: aws.String(bk.Title),
            },
            "Author": {
                S: aws.String(bk.Author),
            },
        },
    }

    _, err := db.PutItem(input)
    return err
}
</pre></code></figure>
<p>And then update the <code>main.go</code> function so that the <code>lambda.Start()</code> method calls a new <code>router</code> function, which does a switch on the HTTP request method to determine which action to take. Like so:</p>
<figure class="file"><figcaption>File: books/main.go</figcaption><code><pre>package main

import (
    "encoding/json"
    "fmt"
    "log"
    "net/http"
    "os"
    "regexp"

    "github.com/aws/aws-lambda-go/events"
    "github.com/aws/aws-lambda-go/lambda"
)

var isbnRegexp = regexp.MustCompile(`[0-9]{3}\-[0-9]{10}`)
var errorLogger = log.New(os.Stderr, "ERROR ", log.Llongfile)

type book struct {
    ISBN   string `json:"isbn"`
    Title  string `json:"title"`
    Author string `json:"author"`
}

func router(req events.APIGatewayProxyRequest) (events.APIGatewayProxyResponse, error) {
    switch req.HTTPMethod {
    case "GET":
        return show(req)
    case "POST":
        return create(req)
    default:
        return clientError(http.StatusMethodNotAllowed)
    }
}

func show(req events.APIGatewayProxyRequest) (events.APIGatewayProxyResponse, error) {
    isbn := req.QueryStringParameters["isbn"]
    if !isbnRegexp.MatchString(isbn) {
        return clientError(http.StatusBadRequest)
    }

    bk, err := getItem(isbn)
    if err != nil {
        return serverError(err)
    }
    if bk == nil {
        return clientError(http.StatusNotFound)
    }

    js, err := json.Marshal(bk)
    if err != nil {
        return serverError(err)
    }

    return events.APIGatewayProxyResponse{
        StatusCode: http.StatusOK,
        Body:       string(js),
    }, nil
}

func create(req events.APIGatewayProxyRequest) (events.APIGatewayProxyResponse, error) {
    if req.Headers["Content-Type"] != "application/json" {
        return clientError(http.StatusNotAcceptable)
    }

    bk := new(book)
    err := json.Unmarshal([]byte(req.Body), bk)
    if err != nil {
        return clientError(http.StatusUnprocessableEntity)
    }

    if !isbnRegexp.MatchString(bk.ISBN) {
        return clientError(http.StatusBadRequest)
    }
    if bk.Title == "" || bk.Author == "" {
        return clientError(http.StatusBadRequest)
    }

    err = putItem(bk)
    if err != nil {
        return serverError(err)
    }

    return events.APIGatewayProxyResponse{
        StatusCode: 201,
        Headers:    map[string]string{"Location": fmt.Sprintf("/books?isbn=%s", bk.ISBN)},
    }, nil
}

func serverError(err error) (events.APIGatewayProxyResponse, error) {
    errorLogger.Println(err.Error())

    return events.APIGatewayProxyResponse{
        StatusCode: http.StatusInternalServerError,
        Body:       http.StatusText(http.StatusInternalServerError),
    }, nil
}

func clientError(status int) (events.APIGatewayProxyResponse, error) {
    return events.APIGatewayProxyResponse{
        StatusCode: status,
        Body:       http.StatusText(status),
    }, nil
}

func main() {
    lambda.Start(router)
}
</pre></code></figure>
</li>
<li>
<p>Rebuild and zip up the lambda function, then deploy it as normal:</p>
<figure class="shell"><code><pre>$ env GOOS=linux GOARCH=amd64 go build -o /tmp/main books
$ zip -j /tmp/main.zip /tmp/main
$ aws lambda update-function-code --function-name books \
--zip-file fileb:///tmp/main.zip
</pre></code></figure>
</li>
<li>
<p>And now when you hit the API using different HTTP methods it should call the appropriate action:</p>
<figure class="shell"><code><pre>$ curl -i -H "Content-Type: application/json" -X POST \
-d '{"isbn":"978-0141439587", "title":"Emma", "author": "Jane Austen"}' \
https://<var>rest-api-id</var>.execeast-1.amazonaws.com/staging/books
<samp>HTTP/1.1 201 Created
Content-Type: application/json
Content-Length: 7
Connection: keep-alive
Date: Thu, 05 Apr 2018 14:55:34 GMT
x-amzn-RequestId: 64262aa3-38e1-11e8-825c-d7cfe4d1e7d0
x-amz-apigw-id: E33T1E3eIAMF9dw=
Location: /books?isbn=978-0141439587
X-Amzn-Trace-Id: sampled=0;root=1-5ac638e5-e806a84761839bc24e234c37
X-Cache: Miss from cloudfront
Via: 1.1 a22ee9ab15c998bce94f1f4d2a7792ee.cloudfront.net (CloudFront)
X-Amz-Cf-Id: wSef_GJ70YB2-0VSwhUTS9x-ATB1Yq8anWuzV_PRN98k9-DkD7FOAA==</samp>

$ curl https://<var>rest-api-id</var>.execute-api.us-east-1.amazonaws.com/staging/books?isbn=978-0141439587
<samp>{"isbn":"978-0141439587","title":"Emma","author":"Jane Austen"}</samp>
</pre></code></figure>
</li>
</ol>
    ]]></description>
  </item>
  <item>
    <pubDate>Wed, 14 Mar 2018 18:00:00 GMT</pubDate>
    <link>https://www.alexedwards.net/blog/disable-http-fileserver-directory-listings</link>
    <guid>https://www.alexedwards.net/blog/disable-http-fileserver-directory-listings</guid>
    <title>How to Disable http.FileServer Directory Listings</title>
    <description><![CDATA[
<p>A nice feature of Go's <a href="https://golang.org/pkg/net/http/#FileServer"><code>http.FileServer</code></a> is that it automatically generates navigable directory listings, which look a bit like this:</p>

<p><img src="/static/images/directory-listing.png" alt="Screenshot of a directory listing"></p>

<p>But for certain applications you might want to prevent this behavior and disable directory listings altogether. In this post I’m going to run through three different options for doing exactly that:</p>

<ul>
    <li><a href="#using-index-html-files">Using index.html files</a></li>
    <li><a href="#using-middleware">Using middleware</a></li>
    <li><a href="#using-a-custom-filesystem">Using a custom filesystem</a></li>
</ul>

<h2 id="using-index-html-files">Using index.html files</h2>

<p>Before <code>http.FileServer</code> generates a directory listing it checks for the existence of an <code>index.html</code> file in the directory root. If an <code>index.html</code> file exists, then it will respond with the contents of the file instead.</p>

<p>So it follows that a simple way to disable directory listings is to add a blank <code>index.html</code> file to your root static file directory <em>and all sub-directories</em>, like so:</p>

<figure class="plain"><code><pre>.
├── main.go
└── static
    ├── css
    │   ├── index.html
    │   └── main.css
    ├── img
    │   ├── index.html
    │   └── logo.png
    ├── index.html
    └── robots.txt
</pre></code></figure>

<p>If you've got a lot of sub-directories an easy way to do that is with a one-line command like this:</p>

<figure class="shell"><code><pre>
$ find ./static/ -type d -exec touch {}/index.html \;
</pre></code></figure>

<p>Any requests for a directory should now result in an empty <code>200 OK</code> response for the user, instead of a directory listing. For example:</p>

<figure class="shell"><code><pre>
$ curl -i http://localhost:4000/static/img/
<samp>HTTP/1.1 200 OK
Accept-Ranges: bytes
Content-Length: 0
Content-Type: text/html; charset=utf-8
Last-Modified: Tue, 13 Mar 2018 12:41:10 GMT
Date: Tue, 13 Mar 2018 12:42:35 GMT</samp>
</pre></code></figure>

<p>Or without the trailing slash, the user should get a <code>301 Redirect</code> like so:</p>

<figure class="shell"><code><pre>
$ curl -i http://localhost:4000/static/img
<samp>HTTP/1.1 301 Moved Permanently
Location: /static/img/
Date: Tue, 13 Mar 2018 12:43:13 GMT
Content-Length: 43
Content-Type: text/html; charset=utf-8

&lt;a href=&quot;/static/img/&quot;&gt;Moved Permanently&lt;/a&gt;.</samp>
</pre></code></figure>

<p>This is a good-enough solution if you can't (or don't want to) make any changes to your Go application itself.</p>

<p>But it's not perfect. You'll need to remember to add a blank <code>index.html</code> file for any new sub-directories in the future, and many people &mdash; myself included &mdash; would argue that a <code>403 Forbidden</code> or <code>404 Not Found</code> status would be more appropriate than sending the user an empty <code>200 OK</code> response.</p>

<h2 id="using-middleware">Using middleware</h2>

<p>Both of these imperfections can be addressed if we take a different approach and implement some custom <a href="/blog/making-and-using-middleware">middleware</a> to intercept requests before they reach the <code>http.FileServer</code>.
<p>Essentially, we want the middleware to check if the request URL ends with a <code>/</code> character, and if it does, return a <code>404 Not Found</code> response instead of passing on the request to the <code>http.FileServer</code>. Here's a basic implementation:</p>

<figure class="go"><code><pre>
package main

import (
    &quot;log&quot;
    &quot;net/http&quot;
    &quot;strings&quot;
)

func main() {
    mux := http.NewServeMux()

    fileServer := http.FileServer(http.Dir(&quot;./static&quot;))
    mux.Handle(&quot;/static/&quot;, http.StripPrefix(&quot;/static&quot;, neuter(fileServer)))

    err := http.ListenAndServe(&quot;:4000&quot;, mux)
    log.Fatal(err)
}

func neuter(next http.Handler) http.Handler {
    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        if strings.HasSuffix(r.URL.Path, &quot;/&quot;) {
            http.NotFound(w, r)
            return
        }

        next.ServeHTTP(w, r)
    })
}
</pre></code></figure>

<p>This approach would result in a user getting responses like these:</p>

<figure class="shell"><code><pre>
$ curl -i http://localhost:4000/static/img/
<samp>HTTP/1.1 404 Not Found
Content-Type: text/plain; charset=utf-8
X-Content-Type-Options: nosniff
Date: Tue, 13 Mar 2018 12:46:20 GMT
Content-Length: 19

404 page not found</samp>

$ curl -i http://localhost:4000/static/img
<samp>HTTP/1.1 301 Moved Permanently
Location: /static/img/
Date: Tue, 13 Mar 2018 12:46:55 GMT
Content-Length: 43
Content-Type: text/html; charset=utf-8

&lt;a href=&quot;/static/img/&quot;&gt;Moved Permanently&lt;/a&gt;.</samp>
</pre></code></figure>

<p>To me, this feels like a cleaner and easier-to-maintain way to disable directory listings than using blank <code>index.html</code> files. But again, it's still not perfect.</p>

<p>Firstly, requests for any directories <em>without</em> the trailing slash will be <code>301</code> redirected only to receive a <code>404 Not Found</code> response. It's extra, unnecessary, requests for both the client and server to deal with.</p>

<p>Secondly, if one of your directories <em>does</em> contain an <code>index.html</code> file then it won't ever be used. For example, if you have the directory structure...</p>
</ol>

<figure class="plain"><code><pre>.
├── main.go
└── static
    ├── css
    │   ├── index.html
    │   └── main.css
    ├── img
    │   └── logo.png
    └── robots.txt
</pre></code></figure>

<p>... any request to <code><a href="http://localhost:4000/static/css/">http://localhost:4000/static/css/</a></code> will result in a <code>404 Not Found</code> response instead of returning the contents of the <code>/static/css/index.html</code> file.</p>

<figure class="shell"><code><pre>
$ curl -i http://localhost:4000/static/css/
<samp>HTTP/1.1 404 Not Found
Content-Type: text/plain; charset=utf-8
X-Content-Type-Options: nosniff
Date: Tue, 13 Mar 2018 12:51:09 GMT
Content-Length: 19

404 page not found</samp>
</pre></code></figure>

<h2 id="using-a-custom-filesystem">Using a custom filesystem</h2>

<p>The final option we're going to look at is creating a custom filesystem and passing that to your <code>http.FileServer</code>.</p>

<p>There are a couple of approaches described by <a href="https://groups.google.com/d/msg/golang-nuts/bStLPdIVM6w/hidTJgDZpHcJ">Brad Fitzpatrick</a> and <a href="https://groups.google.com/d/msg/golang-nuts/bStLPdIVM6w/U_LVmJZRAwAJ">George Armhold</a> you might want to consider, but I would personally suggest doing something like this:<p>

<figure class="go"><code><pre>
package main

import (
    "log"
    "net/http"
    "path/filepath"
)

func main() {
    mux := http.NewServeMux()

    fileServer := http.FileServer(neuteredFileSystem{http.Dir("./static")})
    mux.Handle("/static", http.NotFoundHandler())
    mux.Handle("/static/", http.StripPrefix("/static", fileServer))

    err := http.ListenAndServe(":4000", mux)
    log.Fatal(err)
}

type neuteredFileSystem struct {
    fs http.FileSystem
}

func (nfs neuteredFileSystem) Open(path string) (http.File, error) {
    f, err := nfs.fs.Open(path)
    if err != nil {
        return nil, err
    }

    s, err := f.Stat()
    if s.IsDir() {
        index := filepath.Join(path, "index.html")
        if _, err := nfs.fs.Open(index); err != nil {
            closeErr := f.Close()
            if closeErr != nil {
                return nil, closeErr
            }

            return nil, err
        }
    }

    return f, nil
}    
</pre></code></figure>

<p>In this code we're creating a custom <code>neuteredFileSystem</code> type which embeds the standard <code>http.FileSystem</code>. We then implement an <code>Open()</code> method on it &mdash; which gets called each time our <code>http.FileServer</code> receives a request.</p>

<p>In our <code>Open()</code> method we <code>Stat()</code> the requested file path and use the <code>IsDir()</code> method to check whether it's a directory or not. <em>If it is a directory</em> we then try to <code>Open()</code> any <code>index.html</code> file in it. If no <code>index.html</code> file exists, then this will return a <code>os.ErrNotExist</code> error (which in turn we return and it will be transformed into a <code>404 Not Found</code> response by <code>http.Fileserver</code>). We also call <code>Close()</code> on the original file to avoid a file descriptor leak. Otherwise, we just return the file and let <code>http.FileServer</code> do its thing.</p>

<p>Putting this to use with the directory structure...</p>

<figure class="plain"><code><pre>
.
├── main.go
└── static
    ├── css
    │   ├── index.html
    │   └── main.css
    ├── img
    │   └── logo.png
    └── robots.txt
</pre></code></figure>

<p>...would result in responses like:</p>

<figure class="shell"><code><pre>
$ curl -i http://localhost:4000/static/img/
<samp>HTTP/1.1 404 Not Found
Content-Type: text/plain; charset=utf-8
X-Content-Type-Options: nosniff
Date: Tue, 13 Mar 2018 16:53:21 GMT
Content-Length: 19

404 page not found</samp>

$ curl -i http://localhost:4000/static/img
<samp>HTTP/1.1 404 Not Found
Content-Type: text/plain; charset=utf-8
X-Content-Type-Options: nosniff
Date: Tue, 13 Mar 2018 16:53:22 GMT
Content-Length: 19

404 page not found</samp>

$ curl -i http://localhost:4000/static/css/
<samp>HTTP/1.1 200 OK
Accept-Ranges: bytes
Content-Length: 37
Content-Type: text/html; charset=utf-8
Last-Modified: Tue, 13 Mar 2018 12:49:00 GMT
Date: Tue, 13 Mar 2018 16:53:27 GMT

&lt;h1&gt;This is my custom index page&lt;/h1&gt;</samp>
</pre></code></figure>

<p>This is now working pretty nicely:</p>

<ul>
    <li>All requests for directories (with no <code>index.html</code> file) return a <code>404 Not Found</code> response, instead of a directory listing or a redirect. This works for requests both with and without a trailing slash.</li>
    <li>The default behavior of <code>http.FileServer</code> isn't changed any other way, and <code>index.html</code> files work as per the standard library documentation.</li>
</ul>
    ]]></description>
  </item>
  <item>
    <pubDate>Mon, 5 Feb 2018 17:00:00 GMT</pubDate>
    <link>https://www.alexedwards.net/blog/configuring-sqldb</link>
    <guid>https://www.alexedwards.net/blog/configuring-sqldb</guid>
    <title>Configuring sql.DB for Better Performance</title>
    <description><![CDATA[
<p>There are a lot of good tutorials which talk about Go's <a href="https://golang.org/pkg/database/sql/#DB"><code>sql.DB</code></a> type and how to use it to execute SQL database queries and statements. But most of them gloss over the <a href="https://golang.org/pkg/database/sql/#DB.SetMaxOpenConns"><code>SetMaxOpenConns()</code></a>, <a href="https://golang.org/pkg/database/sql/#DB.SetMaxIdleConns"><code>SetMaxIdleConns()</code></a> and <a href="https://golang.org/pkg/database/sql/#DB.SetConnMaxLifetime"><code>SetConnMaxLifetime()</code></a> methods &mdash; which you can use to configure the behavior of <code>sql.DB</code> and alter its performance.

<p>In this post I'd like to explain exactly what these settings do and demonstrate the (positive and negative) impact that they can have.</p>

<h2 id="openandidleconnections">Open and idle connections</h2>

<p>I'll begin with a little background.</p>

<p>A <code>sql.DB</code> object is a <em>pool of many database connections</em> which contains both 'in-use' and 'idle' connections. A connection is marked as in-use when you are using it to perform a database task, such as executing a SQL statement or querying rows. When the task is complete the connection is marked as idle.</p>

<p>When you instruct <code>sql.DB</code> to perform a database task, it will first check if any idle connections are already available in the pool. If one is available then Go will reuse this existing connection and mark it as in-use for the duration of the task. If there are no idle connections in the pool when you need one, then Go will create an additional new additional connection.</p>

<h2 id="thesetmaxopenconnsmethod">The SetMaxOpenConns method</h2>

<p>By default there's no limit on the number of open connections (in-use + idle) at the same time. But you can implement your own limit via the <code>SetMaxOpenConns()</code> method like so:</p>

<figure class="go"><code><pre>// Initialise a new connection pool
db, err := sql.Open("postgres", "postgres://user:pass@localhost/db")
if err != nil {
    log.Fatal(err)
}

// Set the maximum number of concurrently open connections (in-use + idle)
// to 5. Setting this to less than or equal to 0 will mean there is no 
// maximum limit (which is also the default setting).
db.SetMaxOpenConns(5)</pre></code></figure>

<p>In this example code the pool now has a maximum limit of 5 concurrently open connections. If all 5 connections are already marked as in-use and another new connection is needed, then the application will be forced to wait until one of the 5 connections is freed up and becomes idle.</p>

<p>To illustrate the impact of changing <code>MaxOpenConns</code> I ran a benchmark test with the maximum open connections set to 1, 2, 5, 10 and unlimited. The benchmark executes parallel <code>INSERT</code> statements on a PostgreSQL database and you can find the code in <a href="https://gist.github.com/alexedwards/5d1db82e6358b5b6efcb038ca888ab07">this gist</a>. Here's the results:</p>

<figure class="plain"><code><pre>BenchmarkMaxOpenConns1-8                 500       3129633 ns/op         478 B/op         10 allocs/op
BenchmarkMaxOpenConns2-8                1000       2181641 ns/op         470 B/op         10 allocs/op
BenchmarkMaxOpenConns5-8                2000        859654 ns/op         493 B/op         10 allocs/op
BenchmarkMaxOpenConns10-8               2000        545394 ns/op         510 B/op         10 allocs/op
BenchmarkMaxOpenConnsUnlimited-8        2000        531030 ns/op         479 B/op          9 allocs/op
PASS</pre></code></figure>

<p><em><strong>Edit:</strong> To make clear, the purpose of this benchmark is not to simulate 'real-life' behaviour of an application. It's solely to help illustrate how <code>sql.DB</code> behaves behind the scenes and the impact of changing <code>MaxOpenConns</code> on that behaviour.</em></p>

<p>For this benchmark we can see that the more open connections that are allowed, the less time is taken to perform the <code>INSERT</code> on the database (3129633 ns/op with 1 open connection compared to 531030 ns/op for unlimited connections &mdash; about 6 times quicker). This is because the more open connections that are permitted, the more database queries can be performed concurrently.</p>


<h2 id="thesetmaxidleconnsmethod">The SetMaxIdleConns method</h2>

<p>By default <code>sql.DB</code> allows a maximum of 2 idle connections to be retained in the connection pool. You can change this via  the <code>SetMaxIdleConns()</code> method like so:</p>

<figure class="go"><code><pre>// Initialise a new connection pool
db, err := sql.Open("postgres", "postgres://user:pass@localhost/db")
if err != nil {
    log.Fatal(err)
}

// Set the maximum number of concurrently idle connections to 5. Setting this
// to less than or equal to 0 will mean that no idle connections are retained.
db.SetMaxIdleConns(5)</pre></code></figure>

<p>In theory, allowing a higher number of idle connections in the pool will improve performance because it makes it less likely that a new connection will need to be established from scratch &mdash; therefore helping to save resources.</p>

<p>Lets take a look at the same benchmark with the maximum idle connections is set to none, 1, 2, 5 and 10 (and the number of open connections is unlimited):</p>

<figure class="plain"><code><pre>BenchmarkMaxIdleConnsNone-8          300       4567245 ns/op       58174 B/op        625 allocs/op
BenchmarkMaxIdleConns1-8            2000        568765 ns/op        2596 B/op         32 allocs/op
BenchmarkMaxIdleConns2-8            2000        529359 ns/op         596 B/op         11 allocs/op
BenchmarkMaxIdleConns5-8            2000        506207 ns/op         451 B/op          9 allocs/op
BenchmarkMaxIdleConns10-8           2000        501639 ns/op         450 B/op          9 allocs/op
PASS</pre></code></figure>

<p>When <code>MaxIdleConns</code> is set to none, a new connection has to be created from scratch for each <code>INSERT</code> and we can see from the benchmarks that the average runtime and memory usage is comparatively high.</p>

<p>Allowing just 1 idle connection to be retained and reused makes a massive difference to this particular benchmark &mdash; it cuts the average runtime by about 8 times and reduces memory usage by about 20 times. Going on to increase the size of the idle connection pool makes the performance even better, although the improvements are less pronounced.</p>

<p>So should you maintain a large idle connection pool? The answer is <em>it depends on the application</em>.</p>

<p>It's important to realise that keeping an idle connection alive comes at a cost &mdash; it takes up memory which can otherwise be used for both your application and the database. </p>

<p>It's also possible that if a connection is idle for too long then it may become unusable. For example,  MySQL's <a href="https://dev.mysql.com/doc/refman/5.7/en/server-system-variables.html#sysvar_wait_timeout"><code>wait_timeout</code></a> setting will automatically close any connections that haven't been used for 8 hours (by default).</p>

<p>When this happens <code>sql.DB</code> handles it gracefully. Bad connections will automatically be retried twice before giving up, at which point Go will remove the connection from the pool and create a new one. So setting <code>MaxIdleConns</code> too high may actually result in connections becoming unusable and more resources being used than if you had a smaller idle connection pool (with fewer connections that are used more frequently). So really you only want to keep a connection idle if you're likely to be using it again soon.</p>

<p>One last thing to point out is that <code>MaxIdleConns</code> should always be less than or equal to <code>MaxOpenConns</code>. Go enforces this and will automatically reduce <code>MaxIdleConns</code> if necessary.</p>

<h2 id="thesetconnmaxlifetimemethod">The SetConnMaxLifetime method</h2>

<p>Let's now take a look at the <code>SetConnMaxLifetime()</code> method which sets the maximum length of time that a connection can be reused for. This can be useful if your SQL database also implements a maximum connection lifetime or if &mdash; for example &mdash; you want to facilitate gracefully swapping databases behind a load balancer.</p>

<p>You use it like this:</p>

<figure class="go"><code><pre>// Initialise a new connection pool
db, err := sql.Open("postgres", "postgres://user:pass@localhost/db")
if err != nil {
    log.Fatal(err)
}

// Set the maximum lifetime of a connection to 1 hour. Setting it to 0
// means that there is no maximum lifetime and the connection is reused
// forever (which is the default behavior).
db.SetConnMaxLifetime(time.Hour)</pre></code></figure>

<p>In this example all our connections will 'expire' 1 hour after they were first created, and cannot be reused after they've expired. But note:</p>

<ul>
<li>This doesn't guarantee that a connection will exist in the pool for a whole hour; it's quite possible that the connection will have become unusable for some reason and been automatically closed before then.</li>

<li>A connection can still be in use more than one hour after being created &mdash; it just cannot <em><strong>start</strong> to be reused</em> after that time.</li>

<li>This isn't an idle timeout. The connection will expire 1 hour after it was first created &mdash; not 1 hour after it last became idle.</li>

<li>Once every second a cleanup operation is automatically run to remove 'expired' connections from the pool.</li>
</ul>

<p>In theory, the shorter <code>ConnMaxLifetime</code> is the more often connections will expire &mdash; and consequently &mdash; the more often they will need to be created from scratch.</p>

<p>To illustrate this I ran the benchmarks with <code>ConnMaxLifetime</code> set to 100ms, 200ms, 500ms, 1000ms and unlimited (reused forever), with the default settings of unlimited open connections and 2 idle connections. These time periods are obviously much, much shorter than you'd use in most applications but they help illustrate the behaviour well.</p>

<figure class="plain"><code><pre>BenchmarkConnMaxLifetime100-8               2000        637902 ns/op        2770 B/op         34 allocs/op
BenchmarkConnMaxLifetime200-8               2000        576053 ns/op        1612 B/op         21 allocs/op
BenchmarkConnMaxLifetime500-8               2000        558297 ns/op         913 B/op         14 allocs/op
BenchmarkConnMaxLifetime1000-8              2000        543601 ns/op         740 B/op         12 allocs/op
BenchmarkConnMaxLifetimeUnlimited-8         3000        532789 ns/op         412 B/op          9 allocs/op
PASS</pre></code></figure>

<p>In these particular benchmarks we can see that memory usage was more than 3 times greater with a 100ms lifetime compared to an unlimited lifetime, and the average runtime for each <code>INSERT</code> was also slightly longer.</p>

<p>If you do set <code>ConnMaxLifetime</code> in your code, it is important to bear in mind the frequency at which connections will expire (and subsequently be recreated). For example, if you have 100 total connections and a <code>ConnMaxLifetime</code> of 1 minute, then your application can potentially kill and recreate up to 1.67 connections (on average) every second. You don't want this frequency to be so great that it ultimately hinders performance, rather than helping it.</p>

<h2 id="exceedingconnectionlimits">Exceeding connection limits</h2>

<p>Lastly, this article wouldn't be complete without mentioning what happens if you exceed a hard limit on the number of database connections.</p>

<p>As an illustration, I'll change my <code>postgresql.conf</code> file so only a total of 5 connections are permitted (the default is 100)...</p>

<figure class="plain"><code><pre>max_connections = 5</pre></code></figure>

<p>And then rerun the benchmark test with unlimited open connections...</p>

<figure class="plain"><code><pre>BenchmarkMaxOpenConnsUnlimited-8    --- FAIL: BenchmarkMaxOpenConnsUnlimited-8
    main_test.go:14: pq: sorry, too many clients already
    main_test.go:14: pq: sorry, too many clients already
    main_test.go:14: pq: sorry, too many clients already
FAIL</pre></code></figure>

<p>As soon as the hard limit of 5 connections is hit my database driver (<a href="https://github.com/lib/pq">pq</a>) immediately returns a <code>sorry, too many clients already</code> error message instead of completing the <code>INSERT</code>.</p>

<p>To prevent this error we need to set the <em>total</em> maximum of open connections (in-use + idle) in <code>sql.DB</code> to comfortably below 5. Like so:</p>

<figure class="go"><code><pre>// Initialise a new connection pool
db, err := sql.Open("postgres", "postgres://user:pass@localhost/db")
if err != nil {
    log.Fatal(err)
}

// Set the number of open connections (in-use + idle) to a maximum total of 3.
db.SetMaxOpenConns(3)
</pre></code></figure>

<p>Now there will only ever be a maximum of 3 connections created by <code>sql.DB</code> at any moment in time, and the benchmark should run without any errors.</p>

<p>But doing this comes with a big caveat: when the open connection limit is reached, any new database tasks that your application needs to execute will be forced to wait until a connection becomes free. In the context of a web application, for example, the user's HTTP request would appear to 'hang' and could potentially even timeout while waiting for the database task to be run.</p>
    
<p>To mitigate this you should always pass in a <code>context.Context</code> object with a fixed, fast, timeout when making database calls, using the context-enabled methods like <a href="https://golang.org/pkg/database/sql/#DB.ExecContext"><code>ExecContext()</code></a>. An example can be seen in the <a href="https://gist.github.com/alexedwards/5d1db82e6358b5b6efcb038ca888ab07#file-main_test-go-L12-L15">gist here</a>.</p>

<h2>In Summary</h2>

<ol>
    <li>As a rule of thumb, you should explicitly set a <code>MaxOpenConns</code> value. This should be comfortably below any hard limits on the number of connections imposed by your database and infrastructure.</li>
    <li>In general, higher <code>MaxOpenConns</code> and <code>MaxIdleConns</code> values will lead to better performance. But the returns are diminishing, and you should be aware that having a too-large idle connection pool (with connections that are not re-used and eventually go bad) can actually lead to reduced performance.</li>
    <li>To mitigate the risk from point 2 above, you may want to set a relatively short <code>ConnMaxLifetime</code>. But you don't want this to be so short that leads to connections being killed and recreated unnecessarily often.</li>
    <li><code>MaxIdleConns</code> should always be less than or equal to <code>MaxOpenConns</code>.</li>
</ol>

<p>For small-to-medium web applications I typically use the following settings as a starting point, and then optimize from there depending on the results of load-testing with real-life levels of throughput.</p></p>

<figure class="plain"><code><pre>
db.SetMaxOpenConns(25)
db.SetMaxIdleConns(25)
db.SetConnMaxLifetime(5*time.Minute)
</pre></code></figure>
    ]]></description>
  </item>
  <item>
    <pubDate>Thu, 28 Dec 2017 17:00:00 GMT</pubDate>
    <link>https://www.alexedwards.net/blog/how-to-rate-limit-http-requests</link>
    <guid>https://www.alexedwards.net/blog/how-to-rate-limit-http-requests</guid>
    <title>How to Rate Limit HTTP Requests</title>
    <description><![CDATA[
<p>If you're running a HTTP server and want to rate limit user requests, the go-to package to use is probably <a href="https://github.com/didip/tollbooth">Tollbooth</a> by Didip Kerabat. It's well maintained, has a good range of features and a clean and clear API.</p>

<p>But if you want something simple and lightweight &ndash; or just want to learn &ndash; it's not too difficult to roll your own middleware to handle rate limiting. In this post I'll run through the essentials of how to do that by using the <code><a href="https://godoc.org/golang.org/x/time/rate">x/time/rate</a></code> package, which provides a <a href="https://en.wikipedia.org/wiki/Token_bucket">token bucket</a> rate-limiter algorithm (note: this is also used by Tollbooth behind the scenes).</p>

<p>If you would like to follow along, create a demo directory containing two files, <code>limit.go</code> and <code>main.go</code>, and initialize a new Go module. Like so:</p>

<figure class="shell"><code><pre>
$ mkdir ratelimit-demo
$ cd ratelimit-demo
$ touch limit.go main.go
$ go mod init example.com/ratelimit-demo
</pre></code></figure>

<p>Let's start by making a global rate limiter which acts on <em>all the requests</em> that a HTTP server receives.</p>

<p>Open up the <code>limit.go</code> file and add the following code:</p>

<figure class="file"><figcaption>File: ratelimit-demo/limit.go</figcaption><code><pre>
package main

import (
    "net/http"

    "golang.org/x/time/rate"
)

var limiter = rate.NewLimiter(1, 3)

func limit(next http.Handler) http.Handler {
    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        if limiter.Allow() == false {
            http.Error(w, http.StatusText(429), http.StatusTooManyRequests)
            return
        }

        next.ServeHTTP(w, r)
    })
}
</pre></code></figure>

<p>In this code we've used the <code>rate.NewLimiter()</code> function to initialize and return a new rate limiter. Its signature looks like this:</p>

<figure class="plain"><code><pre>
func NewLimiter(r Limit, b int) *Limiter
</pre></code></figure>

<p>From <a href="https://godoc.org/golang.org/x/time/rate#Limiter">the documentation</a>:</p>

<p><blockquote>A Limiter controls how frequently events are allowed to happen. It implements a "token bucket" of size b, initially full and refilled at rate r tokens per second.</blockquote></p>

<p>Or to describe it another way &ndash; the limiter permits you to consume an average of r tokens per second, with a maximum of b tokens in any single 'burst'. So in the code above our limiter allows 1 token to be consumed per second, with a maximum burst size of 3.</p>

<p>In the <code>limit</code> middleware function we call the global limiter's <code>Allow()</code> method each time the middleware receives a HTTP request. If there are no tokens left in the bucket <code>Allow()</code> will return <code>false</code> and we send the user a <code>429 Too Many Requests</code> response. Otherwise, calling <code>Allow()</code> will consume exactly one token from the bucket and we pass on control to the next handler in the chain.</p>

<p>It's important to note that the code behind the <code>Allow()</code> method is protected by a mutex and is safe for concurrent use.</p>

<p>Let's put this to use. Open up the <code>main.go</code> file and setup a simple web server which uses the <code>limit</code> middleware like so:</p>

<figure class="file"><figcaption>File: ratelimit-demo/main.go</figcaption><code><pre>
package main

import (
	"log"
	"net/http"
)

func main() {
	mux := http.NewServeMux()
	mux.HandleFunc("/", okHandler)

	// Wrap the servemux with the limit middleware.
	log.Println("Listening on :4000...")
	http.ListenAndServe(":4000", limit(mux))
}

func okHandler(w http.ResponseWriter, r *http.Request) {
	w.Write([]byte("OK"))
}
</pre></code></figure>

<p>Go ahead and run the application&hellip;</p>

<figure class="shell"><code><pre>
$ go run .
</pre></code></figure>

<p>And if you make enough requests in quick succession, you should eventually get a response which looks like this:</p>

<figure class="shell"><code><pre>
$ curl -i localhost:4000
<samp>HTTP/1.1 429 Too Many Requests
Content-Type: text/plain; charset=utf-8
X-Content-Type-Options: nosniff
Date: Thu, 21 Dec 2017 19:25:52 GMT
Content-Length: 18

Too Many Requests</samp>
</pre></code></figure>

<h2>Rate limiting per user</h2>

<p>While having a single, global, rate limiter is useful in some cases, another common scenario is implement a rate limiter <em>per user</em>, based on an identifier like IP address or API key. In this post we'll use IP address as the identifier.</p>

<p>A conceptually straightforward way to do this is to create a <em>map of rate limiters</em>, using the identifier for each user as the map key. </p>

<p>At this point you might think to reach for the <code><a href="https://golang.org/pkg/sync/#Map">sync.Map</a></code> type that was introduced in Go 1.9. This essentially provides a concurrency-safe map, designed to be accessed from multiple goroutines without the risk of race conditions. But it comes with a note of caution:</p>

<p><blockquote> It is optimized for use in concurrent loops with keys that are stable over time, and either few steady-state stores, or stores localized to one goroutine per key.<br><br>For use cases that do not share these attributes, it will likely have comparable or worse performance and worse type safety than an ordinary map paired with a read-write mutex.</blockquote></p>

<p>In our particular use-case the map keys will be the IP address of users, and so new keys will be added to the map each time a new user visits our application. We'll also want to prevent undue memory consumption by removing old entries from the map when a user hasn't been seen for a long period of time.</p>

<p>So in our case the map keys <em>won't be stable</em> and it's likely that an ordinary map protected by a mutex will perform better. (If you're not familiar with the idea of mutexes or how to use them in Go, then <a href="https://www.alexedwards.net/blog/understanding-mutexes">this post</a> has an explanation which you might want to read before continuing).</p>

<p>Let's update the <code>limit.go</code> file to contain a basic implementation. I'll keep the code structure deliberately simple.</p>

<figure class="file"><figcaption>File: ratelimit-demo/limit.go</figcaption><code><pre>
package main

import (
    "log"
    "net"
    "net/http"
    "sync"

    "golang.org/x/time/rate"
)

// Create a map to hold the rate limiters for each visitor and a mutex.
var visitors = make(map[string]*rate.Limiter)
var mu sync.Mutex

// Retrieve and return the rate limiter for the current visitor if it
// already exists. Otherwise create a new rate limiter and add it to
// the visitors map, using the IP address as the key.
func getVisitor(ip string) *rate.Limiter {
    mu.Lock()
    defer mu.Unlock()

    limiter, exists := visitors[ip]
    if !exists {
        limiter = rate.NewLimiter(1, 3)
        visitors[ip] = limiter
    }

    return limiter
}

func limit(next http.Handler) http.Handler {
    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        // Get the IP address for the current user.
        ip, _, err := net.SplitHostPort(r.RemoteAddr)
        if err != nil {
            log.Println(err.Error())
            http.Error(w, "Internal Server Error", http.StatusInternalServerError)
            return
        }

        // Call the getVisitor function to retreive the rate limiter for
        // the current user.
        limiter := getVisitor(ip)
        if limiter.Allow() == false {
            http.Error(w, http.StatusText(429), http.StatusTooManyRequests)
            return
        }

        next.ServeHTTP(w, r)
    })
}    
</pre></code></figure>

<h2>Removing old entries from the map</h2>

<p>There's one problem with this: as long as the application is running the <code>visitors</code> map will continue to grow unbounded.</p>

<p>We can fix this fairly simply by recording the <em>last seen</em> time for each visitor and running a background goroutine to delete old entries from the map (and therefore free up memory as we go).</p>

<figure class="file"><figcaption>File: ratelimit-demo/limit.go</figcaption><code><pre>
package main

import (
    "log"
    "net"
    "net/http"
    "sync"
    "time"

    "golang.org/x/time/rate"
)

// Create a custom visitor struct which holds the rate limiter for each
// visitor and the last time that the visitor was seen.
type visitor struct {
    limiter  *rate.Limiter
    lastSeen time.Time
}

// Change the the map to hold values of the type visitor.
var visitors = make(map[string]*visitor)
var mu sync.Mutex

// Run a background goroutine to remove old entries from the visitors map.
func init() {
    go cleanupVisitors()
}

func getVisitor(ip string) *rate.Limiter {
    mu.Lock()
    defer mu.Unlock()

    v, exists := visitors[ip]
    if !exists {
        limiter := rate.NewLimiter(1, 3)
        // Include the current time when creating a new visitor.
        visitors[ip] = &visitor{limiter, time.Now()}
        return limiter
    }

    // Update the last seen time for the visitor.
    v.lastSeen = time.Now()
    return v.limiter
}

// Every minute check the map for visitors that haven't been seen for
// more than 3 minutes and delete the entries.
func cleanupVisitors() {
    for {
        time.Sleep(time.Minute)

        mu.Lock()
        defer mu.Unlock()
        for ip, v := range visitors {
            if time.Now().Sub(v.lastSeen) > 3*time.Minute {
                delete(visitors, ip)
            }
        }
    }
}

func limit(next http.Handler) http.Handler {
    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        ip, _, err := net.SplitHostPort(r.RemoteAddr)
        if err != nil {
            log.Println(err.Error())
            http.Error(w, "Internal Server Error", http.StatusInternalServerError)
            return
        }

        limiter := getVisitor(ip)
        if limiter.Allow() == false {
            http.Error(w, http.StatusText(429), http.StatusTooManyRequests)
            return
        }

        next.ServeHTTP(w, r)
    })
}    
</pre></code></figure>

<h2>Some more improvements&hellip;</h2>

<p>For simple applications this code will work fine as-is, but you may want to adapt it further depending on your needs. For example, it might make sense to:</p>

<ul>
    <li>Check the <code>X-Forwarded-For</code> or <code>X-Real-IP</code> headers for the IP address, if you are running your server behind a reverse proxy.</li>
    <li>Port the code to a standalone package.</li>
    <li>Make the rate limiter and cleanup settings configurable at runtime.</li>
    <li>Remove the reliance on global variables, so that different rate limiters can be created with different settings.</li>
    <li>Switch to a <code>sync.RWMutex</code> to help reduce contention on the map.</li>
</ul>
    ]]></description>
  </item>
  <item>
    <pubDate>Sat, 05 Aug 2017 19:00:00 GMT</pubDate>
    <link>https://www.alexedwards.net/blog/validation-snippets-for-go</link>
    <guid>https://www.alexedwards.net/blog/validation-snippets-for-go</guid>
    <title>Validation Snippets for Go</title>
    <description><![CDATA[
    <p>Over the past few years I've built up a collection of snippets for validating inputs in Go. There's nothing new or groundbreaking here, but hopefully they might save you some time.</p>

    <p>The snippets assume that the data to validate is stored as strings in <code>r.Form</code>, but the principles are the same no matter where the data has come from.</p>

    <ol style="margin-left: 23px;">
    <li><a href="https://www.alexedwards.net/blog/validation-snippets-for-go#required-inputs">Required inputs</a></li>
    <li><a href="https://www.alexedwards.net/blog/validation-snippets-for-go#blank-text">Blank text</a></li>
    <li><a href="https://www.alexedwards.net/blog/validation-snippets-for-go#min-and-max-length-bytes">Min and max length (bytes)</a></li>
    <li><a href="https://www.alexedwards.net/blog/validation-snippets-for-go#min-and-max-length-number-of-characters">Min and max length (number of characters)</a></li>
    <li><a href="https://www.alexedwards.net/blog/validation-snippets-for-go#starts-with,-ends-with-and-contains">Starts with, ends with and contains</a></li>
    <li><a href="https://www.alexedwards.net/blog/validation-snippets-for-go#matches-regular-expression-pattern">Matches regular expression pattern</a></li>
    <li><a href="https://www.alexedwards.net/blog/validation-snippets-for-go#unicode-character-range">Unicode character range</a></li>
    <li><a href="https://www.alexedwards.net/blog/validation-snippets-for-go#email-validation">Email validation</a></li>
    <li><a href="https://www.alexedwards.net/blog/validation-snippets-for-go#url-validation">URL validation</a></li>
    <li><a href="https://www.alexedwards.net/blog/validation-snippets-for-go#integers">Integers</a></li>
    <li><a href="https://www.alexedwards.net/blog/validation-snippets-for-go#floats">Floats</a></li>
    <li><a href="https://www.alexedwards.net/blog/validation-snippets-for-go#date">Date</a></li>
    <li><a href="https://www.alexedwards.net/blog/validation-snippets-for-go#datetime-local">Datetime-local</a></li>
    <li><a href="https://www.alexedwards.net/blog/validation-snippets-for-go#radio,-select-and-datalist-one-in-set">Radio, Select and Datalist (one-in-set)</a></li>
    <li><a href="https://www.alexedwards.net/blog/validation-snippets-for-go#checkboxes-many-in-set">Checkboxes (many-in-set)</a></li>
    <li><a href="https://www.alexedwards.net/blog/validation-snippets-for-go#single-checkbox">Single checkbox</a></li>
    </ol>

    <h2 id="required-inputs">Required inputs</h2>

    <p>If you have the HTML form:</p>

    <figure class="plain"><code><pre>    &lt;input type="text" name="foo"&gt;
    </pre></code></figure>

    <p>You can verify that a value for the <code>"foo"</code> field has been submitted with:</p>

    <figure class="plain"><code><pre>    if r.Form.Get("foo") == "" {
        fmt.Println("error: foo is required")
    }
    </pre></code></figure>

    <p>For checkbox and select inputs this will ensure that <em>at least one item</em> has been checked.</p>

    <h2 id="blank-text">Blank text</h2>

    <p>If you have the HTML form:</p>

    <figure class="plain"><code><pre>    &lt;input type="text" name="foo"&gt;
    </pre></code></figure>

    <p>You can verify that a value for the <code>"foo"</code> field isn't blank (i.e. contains whitespace only) with the <code>strings.TrimSpace</code> function:</p>

    <figure class="plain"><code><pre>    import "strings"
    ···
    if strings.TrimSpace(r.Form.Get("foo")) == "" {
        fmt.Println("error: foo must not be blank")
    }
    </pre></code></figure>

    <h2 id="min-and-max-length-bytes">Min and max length (bytes)</h2>

    <p>If you have the HTML form:</p>

    <figure class="plain"><code><pre>    &lt;input type="text" name="foo"&gt;
    </pre></code></figure>

    <p>You can verify that the <code>"foo"</code> field contains a certain number of bytes with the builtin <code>len</code> function:</p>

    <figure class="plain"><code><pre>    l := len(r.Form.Get("foo"))
    if l &lt; 5 || l &gt; 10 {
        fmt.Println("error: foo must be between 5 and 10 bytes long")
    }
    </pre></code></figure>

    <h2 id="min-and-max-length-number-of-characters">Min and max length (number of characters)</h2>

    <p>If you have the HTML form:</p>

    <figure class="plain"><code><pre>    &lt;input type="text" name="foo"&gt;
    </pre></code></figure>

    <p>You can verify that the <code>"foo"</code> field contains a certain number of <em>characters</em> with the <code>utf8.RuneCountInString</code> function. This is subtly different to checking the number of bytes. For example, the string <code>"Zoë"</code> contains 3 characters but is 4 bytes long because of the accented character.</p>

    <figure class="plain"><code><pre>    import "unicode/utf8"
    ···
    l := utf8.RuneCountInString(r.Form.Get("foo"))
    if l &lt; 5 || l &gt; 10 {
        fmt.Println("error: foo must be between 5 and 10 characters long")
    }
    </pre></code></figure>

    <h2 id="starts-with,-ends-with-and-contains">Starts with, ends with and contains</h2>

    <p>If you have the HTML form:</p>

    <figure class="plain"><code><pre>    &lt;input type="text" name="foo"&gt;
    </pre></code></figure>

    <p>You can verify that the <code>"foo"</code> field starts with, ends with, or contains a particular string using the functions in the <code>strings</code> package:</p>

    <figure class="plain"><code><pre>    import "strings"
    ···
    // Check that the field value starts with 'abc'.
    if !strings.HasPrefix(r.Form.Get("foo"), "abc") {
        fmt.Println("error: foo does not start with 'abc'")
    }

    // Check that the field value ends with 'abc'.
    if !strings.HasSuffix(r.Form.Get("foo"), "abc") {
        fmt.Println("error: foo does not end with 'abc'")
    }

    // Check that the field value contains 'abc' anywhere in it.
    if !strings.Contains(r.Form.Get("foo"), "abc") {
        fmt.Println("error: foo does not contain 'abc'")
    }
    </pre></code></figure>


    <h2 id="matches-regular-expression-pattern">Matches regular expression pattern</h2>

    <p>If you have the HTML form:</p>

    <figure class="plain"><code><pre>    &lt;input type="text" name="foo"&gt;
    </pre></code></figure>

    <p>You can verify that the <code>"foo"</code> field matches a particular regular expression using the <code>regexp</code> package. For example, to check that it matches the pattern <code>^[a-z]{4}\.[0-9]{2}$</code> (four lowercase letters followed by a period and two digits):</p>

    <figure class="plain"><code><pre>    import "regexp"
    ···
    // Pre-compiling the regular expression and storing it in a variable is more efficient
    // if you're going to use it multiple times. The regexp.MustCompile function will
    // panic on failure.
    var rxPat = regexp.MustCompile(`^[a-z]{4}.[0-9]{2}$`)

    if !rxPat.MatchString(r.Form.Get("foo")) {
        fmt.Println("error: foo does not match the required pattern")
    }
    </pre></code></figure>

    <p>Note that because the dot character has a special meaning in regular expressions, we escaped it using the <code>\</code> character so it is interpreted as a literal period character instead. In the example above we also used a <a href="https://golang.org/ref/spec#String_literals">raw string</a> for the regular expression. If you use an <em>interpreted string</em> (i.e. a string surrounded by double quotes), you need to <em>escape the backslash</em> too because that's the escape character for interpreted strings. So you would need to write:</p>

    <figure class="plain"><code><pre>    var rxPat = regexp.MustCompile("^[a-z]{4}\.[0-9]{2}$")
    </pre></code></figure>

    <p>If you're not familiar with regular expressions then <a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Guide/Regular_Expressions">this guide</a> from Mozilla is a good explanation.</p>

    <h2 id="unicode-character-range">Unicode character range</h2>

    <p>If you have the HTML form:</p>

    <figure class="plain"><code><pre>    &lt;input type="text" name="foo"&gt;
    </pre></code></figure>

    <p>You can verify that the <code>"foo"</code> field only contains characters in a certain unicode range using the <code>regexp</code> package. For example, to check that it contains only Cyrillic characters in the two <a href="http://jrgraphix.net/research/unicode_blocks.php">unicode blocks</a> 0400 - 04FF (Cyrillic) and 0500 - 052F (Cyrillic Supplementary):</p>

    <figure class="plain"><code><pre>    import "regexp"
    ···
    // Use an interpreted string and the \u escape notation to create a regular
    // expression matching the range of characters in the two unicode code blocks.
    var rxCyrillic = regexp.MustCompile("^[\u0400-\u04FF\u0500-\u052F]+$")

    if !rxCyrillic.MatchString(r.Form.Get("foo")) {
        fmt.Println("error: foo must only contain Cyrillic characters")
    }
    </pre></code></figure>

    <h2 id="email-validation">Email validation</h2>

    <p>If you have the HTML form:</p>

    <figure class="plain"><code><pre>    &lt;input type="email" name="foo"&gt;
    </pre></code></figure>

    <p>You can sanity check that the <code>"foo"</code> field contains an email address using the <code>regexp</code> package. Choosing a regular expression to use for email validation is a contentious topic, but as a starting point I would suggest the pattern recommended by the <a href="https://www.w3.org/TR/2016/REC-html51-20161101/sec-forms.html#email-state-typeemail">W3C</a> and <a href="https://html.spec.whatwg.org/multipage/forms.html#valid-e-mail-address">Web Hypertext Application Technology Working Group</a>.</p>

    <p>In addition, the email addresses have a <a href="http://stackoverflow.com/questions/386294/what-is-the-maximum-length-of-a-valid-email-address">practical limit of 254 bytes</a>. Putting those together, a decent sanity check is:</p>

    <figure class="plain"><code><pre>    import "regexp"
    ···
    var rxEmail = regexp.MustCompile("^[a-zA-Z0-9.!#$%&'*+\\/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$")

    e := r.Form.Get("foo")
    if len(e) > 254 || !rxEmail.MatchString(e) {
        fmt.Println("error: foo is not a valid email address")
    }
    </pre></code></figure>

    <p>Note that we have to use an interpreted string for the regular expression because it contains a backtick character (which means we can't use a <a href="https://golang.org/ref/spec#String_literals">raw string</a>).</p>

    <h2 id="url-validation">URL validation</h2>

    <p>If you have the HTML form:</p>

    <figure class="plain"><code><pre>    &lt;input type="url" name="foo"&gt;
    </pre></code></figure>

    <p>You can verify that the <code>"foo"</code> field contains a valid URL by first parsing it with the <code>url.Parse</code> function. This will take a URL string, break it into it's component pieces, and store it as a <a href="https://golang.org/pkg/net/url/#URL">url.URL</a> struct. You can then sanity check the component pieces as necessary.</p>

    <p>For instance, to check that a URL is absolute (i.e has both a scheme and host) and that the scheme is either http or https:</p>

    <figure class="plain"><code><pre>    import "net/url"
    ···
    // If there are any major problems with the format of the URL, url.Parse() will
    // return an error.
    u, err := url.Parse(r.Form.Get("foo"))
    if err != nil {
        fmt.Println("error: foo is not a valid URL")
    } else if u.Scheme == "" || u.Host == "" {
        fmt.Println("error: foo must be an absolute URL")
    } else if u.Scheme != "http" &amp;&amp; u.Scheme != "https" {
        fmt.Println("error: foo must begin with http or https")
    }
    </pre></code></figure>

    <h2 id="integers">Integers</h2>

    <p>If you have the HTML form:</p>

    <figure class="plain"><code><pre>    &lt;input type="number" name="foo" min="0" max="100" step="5"&gt;
    </pre></code></figure>

    You can verify that the <code>"foo"</code> field contains an integer by parsing it with the <code>strconv.Atoi</code> function. You can then sanity check the integer as necessary.</p>

    <p>For instance, to check that an integer is a multiple of 5 between 0 and 100:</p>

    <figure class="plain"><code><pre>    import "strconv"
    ···
    n, err := strconv.Atoi(r.Form.Get("foo"))
    if err != nil {
        fmt.Println("error: foo must be an integer")
    } else if n &lt; 0 || n &gt; 10  {
        fmt.Printf("error: foo must be between 0 and 100")
    } else if  n%5 != 0 {
        fmt.Println("error: foo must be an multiple of 5")
    }
    </pre></code></figure>

    <h2 id="floats">Floats</h2>

    <p>If you have the HTML form:</p>

    <figure class="plain"><code><pre>    &lt;input type="number" name="foo" min="0" max="1" step="0.01"&gt;
    </pre></code></figure>

    <p>You can verify that the <code>"foo"</code> field contains an integer by parsing it with the <code>strconv.ParseFloat</code> function. You can then sanity check the float as necessary.</p>

    <p>For instance, to check that an float is a between 0 and 1:</p>

    <figure class="plain"><code><pre>    import "strconv"

    n, err := strconv.ParseFloat(r.Form.Get("foo"), 64)
    if err != nil {
        fmt.Println("error: foo must be a float")
    } else if n &lt; 0 || n > 1  {
        fmt.Printf("error: foo must be between 0 and 1")
    }
    </pre></code></figure>

    <h2 id="date">Date</h2>

    <p>If you have the HTML form:</p>

    <figure class="plain"><code><pre>    &lt;input type="date" name="foo" min="2017-01-01" max="2017-12-31"&gt;
    </pre></code></figure>

    <p>You can verify that the <code>"foo"</code> field contains a valid date by parsing it with the <code>time.Parse</code> function. It will return an error if the date is not real: any day of month larger than 31 is rejected, as is February 29 in non-leap years, February 30, February 31, April 31, June 31, September 31, and November 31.</p>

    <p>If you're not familiar with <code>time.Parse</code>, it converts strings with a given format into a time.Time object. You specify what the format is by passing the <em>reference time</em> (<code>Mon Jan 2 15:04:05 -0700 MST 2006</code>) as the first parameter, laid-out in the format you want. If you are expecting a date in the format <code>YYYY-MM-DD</code> then the reference time is <code>2006-01-02</code>.</p>

    <p>You can then use the <a href="https://golang.org/pkg/time/#pkg-index">various functions</a> in the <code>time</code> package to sanity check the date as necessary.</p>

    <p>For instance, to check that an date is valid and between 2017-01-01 and 2017-12-31:</p>

    <figure class="plain"><code><pre>    import "time"
    ···
    d, err := time.Parse("2006-01-02", r.Form.Get("foo"))
    if err != nil {
        fmt.Printf("error: foo is not a valid date")
    } else if d.Year() != 2017 {
        fmt.Printf("error: foo is not between 2017-01-01 and 2017-12-31")
    }
    </pre></code></figure>

    <h2 id="datetime-local">Datetime-local</h2>

    <p>If you have the HTML form:</p>

    <figure class="plain"><code><pre>    &lt;input type="datetime-local" name="foo" min="2017-01-01" max="2017-12-31"&gt;
    </pre></code></figure>

    <p>You can verify that the <code>"foo"</code> field contains a valid datetime for a specific location by parsing it with the <code>time.ParseInLocation</code> function. This will return an error if the date is not real: any day of month larger than 31 is rejected, as is February 29 in non-leap years, February 30, February 31, April 31, June 31, September 31, and November 31.</p>

    <p>For instance, to check that an datetime for the "Europe/Vienna" timezone is valid and between 2017-01-01 00:00 and 2017-12-31 23:59:</p>

    <figure class="plain"><code><pre>    import "time"
    ···

    // Load the users local time zone. This accepts a location name corresponding
    // to a file in your IANA Time Zone database.
    loc, err := time.LoadLocation("Europe/Vienna")
    if err != nil {
        ···
    }

    d, err := time.ParseInLocation("2006-01-02T15:04:05", r.Form.Get("foo"), loc)
    if err != nil {
        fmt.Printf("error: foo is not a valid datetime")
    } else if d.Year() != 2017 {
        fmt.Printf("error: foo is not between 2017-01-01 00:00:00 and 2017-12-31 23:59:00")
    }
    </pre></code></figure>

    <p>The time zone database needed by <code>LoadLocation</code> may not be present on all systems, especially non-Unix systems. <code>LoadLocation</code> looks in the directory or uncompressed zip file named by the ZONEINFO environment variable, if any, then looks in known installation locations on Unix systems, and finally looks in <code>$GOROOT/lib/time/zoneinfo.zip</code>.</p>

    <h2 id="radio,-select-and-datalist-one-in-set">Radio, Select and Datalist (one-in-a-set) validation</h2>

    <p>If you have the HTML form:</p>

    <figure class="plain"><code><pre>    &lt;input type="radio" name="foo" value="wibble"&gt; Wibble
    &lt;input type="radio" name="foo" value="wobble"&gt; Wobble
    &lt;input type="radio" name="foo" value="wubble"&gt; Wubble
    </pre></code></figure>

    <p>You can check that the submitted value for the <code>"foo"</code> field is one of a known set like this:</p>

    <figure class="plain"><code><pre>    set := map[string]bool{"wibble": true, "wobble": true, "wubble": true}

    if !set[r.Form.Get("foo")] {
        fmt.Printf("error: foo not match 'wibble', 'wobble' or 'wubble'")
    }
    </pre></code></figure>

    <h2 id="checkboxes-many-in-set">Checkboxes (many-in-a-set) validation</h2>

    <p>If you have the HTML form:</p>

    <figure class="plain"><code><pre>    &lt;input type="checkbox" name="foo" value="wibble"&gt; Wibble
    &lt;input type="checkbox" name="foo" value="wobble"&gt; Wobble
    &lt;input type="checkbox" name="foo" value="wubble"&gt; Wubble
    </pre></code></figure>

    <p>To validate these, and make sure that <em>all values</em> sent by the form are either
    <code>wibble</code>, <code>wobble</code> or <code>wubble</code>, we need to access the underlying form data directly and range over each value:</p>

    <p>You can check that the submitted values for the <code>"foo"</code> field are part of a known set like this:</p>

    <figure class="plain"><code><pre>    set := map[string]bool{"wibble": true, "wobble": true, "wubble": true}

    for _, f := range r.Form["foo"] {
        if !set[f] {
            fmt.Printf("error: foo does not match 'wibble', 'wobble' or 'wubble'")
            break
        }
    }
    </pre></code></figure>

    <h2 id="single-checkbox">Single checkboxes</h2>

    <p>Sometimes you might have a single checkbox, and you want to verify that it has been checked. A common example is an "I accept the terms" checkbox on a form.</p>

    <p>If you have the HTML form:</p>

    <figure class="plain"><code><pre>    &lt;input type="checkbox" name="foo" value="checked"&gt; I accept the terms
    </pre></code></figure>

    <p>You can verify that it has been checked like this:</p>

    <figure class="plain"><code><pre>    if r.Form.Get("foo") != "checked" {
        fmt.Println("foo must be checked")
    }
    </pre></code></figure>
    ]]></description>
  </item>
  <item>
    <pubDate>Tue, 30 Aug 2016 18:00:00 GMT</pubDate>
    <link>https://www.alexedwards.net/blog/scs-session-manager</link>
    <guid>https://www.alexedwards.net/blog/scs-session-manager</guid>
    <title>SCS: A session manager for Go 1.7+</title>
    <description><![CDATA[
    <p>I’ve just released <a href="https://github.com/alexedwards/scs">SCS</a>, a session management package for Go 1.7+.</p>

    <p>Its design leverages Go’s new <code>context</code> package to automatically load and save session data via middleware.</p>

    <p>Importantly, it also provides the security features that you need when using server-side session stores (like straightforward session token regeneration) and supports both absolute and inactivity timeouts. The session data is safe for concurrent use.</p>

    <h2>A simple example</h2>

    <p>SCS is broken up into small single-purpose packages for ease of use. You should install the <code>session</code> package and your choice of session storage engine from the following table:</p>

    <table style="width: 100%">
    <thead>
    <tr>
    <th style="text-align:left">Package</th>
    <th></th>
    </tr>
    </thead>
    <tbody>
    <tr style="background: white">
    <td style="text-align:left"><a href="https://godoc.org/github.com/alexedwards/scs/session">session</a></td>
    <td>Provides session management middleware and helpers for <br>manipulating session data</td>
    </tr>
    <tr style="background: white">
    <td style="text-align:left"><a href="https://github.com/alexedwards/scs/tree/master/engine/memstore">engine/memstore</a></td>
    <td>In-memory storage engine</td>
    </tr>
    <tr style="background: white">
    <td style="text-align:left"><a href="https://github.com/alexedwards/scs/tree/master/engine/cookiestore">engine/cookiestore</a></td>
    <td>Encrypted-cookie based storage engine</td>
    </tr>
    <tr style="background: white">
    <td style="text-align:left"><a href="https://github.com/alexedwards/scs/tree/master/engine/pgstore">engine/pgstore</a></td>
    <td>PostgreSQL based storage eninge</td>
    </tr>
    <tr style="background: white">
    <td style="text-align:left"><a href="https://github.com/alexedwards/scs/tree/master/engine/mysqlstore">engine/mysqlstore</a></td>
    <td>MySQL based storage engine</td>
    </tr>
    <tr style="background: white">
    <td style="text-align:left"><a href="https://github.com/alexedwards/scs/tree/master/engine/redisstore">engine/redisstore</a></td>
    <td>Redis based storage engine</td>
    </tr>
    </tbody>
    </table>

    <p>For example:</p>

    <figure class="shell"><code><pre>    $ go get github.com/alexedwards/scs/session
    $ go get github.com/alexedwards/scs/engine/memstore
    </pre></code></figure>

    <p>Usage is then simple:</p>

    <figure class="file"><figcaption>File: main.go</figcaption><code><pre>    package main

    import (
        &quot;io&quot;
        &quot;net/http&quot;

        &quot;github.com/alexedwards/scs/engine/memstore&quot;
        &quot;github.com/alexedwards/scs/session&quot;
    )

    func main() {
        // Create the session manager middleware, passing in a new storage
        // engine instance as the first parameter.
        sessionManager := session.Manage(memstore.New(0))

        // Set up your HTTP handlers in the normal way.
        mux := http.NewServeMux()
        mux.HandleFunc(&quot;/put&quot;, putHandler)
        mux.HandleFunc(&quot;/get&quot;, getHandler)

        // Wrap your handlers with the session manager middleware.
        http.ListenAndServe(&quot;:4000&quot;, sessionManager(mux))
    }

    func putHandler(w http.ResponseWriter, r *http.Request) {
        // Use the PutString helper to add a new key and associated string value
        // to the session data. Helpers for other types are included.
        err := session.PutString(r, &quot;message&quot;, &quot;Hello from a session!&quot;)
        if err != nil {
            http.Error(w, err.Error(), 500)
        }
    }

    func getHandler(w http.ResponseWriter, r *http.Request) {
        // Use the GetString helper to retrieve the value associated with the
        // &quot;message&quot; key.
        msg, err := session.GetString(r, &quot;message&quot;)
        if err != nil {
            http.Error(w, err.Error(), 500)
            return
        }
        io.WriteString(w, msg)
    }
    </pre></code></figure>

    <p>You should be able to verify that the session data is being across requests with curl:</p>

    <figure class="shell"><code><pre>    $ curl -i -c cookies localhost:4000/put
    <samp>HTTP/1.1 200 OK
    Set-Cookie: scs.session.token=uts3FRcCMOIXpyx5uZx28Y54uUFRHxgtYhbgD4epeI4; Path=/; HttpOnly
    Date: Tue, 30 Aug 2016 17:37:12 GMT
    Content-Length: 0
    Content-Type: text/plain; charset=utf-8</samp>

    $ curl -i -b cookies localhost:4000/get
    <samp>HTTP/1.1 200 OK
    Date: Tue, 30 Aug 2016 17:37:21 GMT
    Content-Length: 21
    Content-Type: text/plain; charset=utf-8

    Hello from a session!</samp>
    </pre></code></figure>

    <p>The complete <a href="https://godoc.org/github.com/alexedwards/scs">godocs are here</a>.</p>

    <p>I’d love to hear any feedback &ndash; either drop me an email or <a href="https://github.com/alexedwards/scs/issues">open an issue</a> on Github.</p>

    ]]></description>
  </item>
  <item>
    <pubDate>Fri, 26 Feb 2016 19:00:00 GMT</pubDate>
    <link>https://www.alexedwards.net/blog/working-with-redis</link>
    <guid>https://www.alexedwards.net/blog/working-with-redis</guid>
    <title>Working with Redis</title>
    <description><![CDATA[
 <p>In this post I'm going to be looking at using <a href="http://redis.io">Redis</a> as a data persistence layer for a Go application. We'll start by explaining a few of the essential concepts, and then build a working web application which highlights some techniques for using Redis in a concurrency-safe way.</p>

<p>This post assumes a basic knowledge of Redis itself (and a <a href="http://redis.io/download">working installation</a>, if you want to follow along). If you haven't used Redis before, I highly recommend reading the <a href="http://openmymind.net/redis.pdf">Little Book of Redis</a> by Karl Seguin or running through the <a href="https://try.redis.io/">Try Redis</a> interactive tutorial.</p>

<h2>Installing a driver</h2>

<p>First up we need to install a Go driver (or <em>client</em>) for Redis. A list of available drivers is located at <a href="http://redis.io/clients#go">http://redis.io/clients#go</a>.</p>

<p>The two drivers that I would recommend are <a href="https://github.com/gomodule/redigo">gomodule/redigo</a> and <a href="https://github.com/mediocregopher/radix">mediocregopher/radix</a>. They are both well designed and actively maintained.</p>

<p>The key differences are that Redigo is completely self-contained (with no external dependencies) and it has a smaller, simpler API than Radix. Radix, on the other hand, provides support for Redis sentinel and cluster implementations.</p>

<p>Throughout this post we'll be using the Redigo driver.</p>

<h2>Getting started with Redis and Go</h2>

<p>As an example, let's say that we have an online record shop and want to store information about the albums for sale in Redis.</p>

<p>There's many different ways we could model this data in Redis, but we'll keep things simple and store each album as a hash &ndash; with fields for title, artist, price and the number of 'likes' that it has. As the key for each album hash we'll use the pattern <code>album:{id}</code>, where <code>id</code> is a unique integer value.</p>

<p>So if we wanted to store a new album using the Redis CLI, we could execute a <code>HMSET</code> command along the lines of:</p>

<figure class="shell"><code><pre>
127.0.0.1:6379> HMSET album:1 title "Electric Ladyland" artist "Jimi Hendrix" price 4.95 likes 8
<samp>OK</samp>
</pre></code></figure>

<p>To do the same thing from a Go application, we need to combine a couple of functions from the <code>gomodule/redigo/redis</code> package.</p>

<ul>
<li>The first is the <code>Dial()</code> function, which returns a new connection to our Redis server.</li>
<li>The second is the <code>Do()</code> method, which sends a command to our Redis server across the connection. This returns the reply from Redis as an <code>interface{}</code> type, along with any error if applicable.</li>
</ul>

<p>Using them is quite straightforward in practice:</p>

<figure class="file"><figcaption>File: main.go</figcaption><code><pre>
package main

import (
	"fmt"
	"log"

	// Import the redigo/redis package.
	"github.com/gomodule/redigo/redis"
)

func main() {
	// Establish a connection to the Redis server listening on port
	// 6379 of the local machine. 6379 is the default port, so unless
	// you've already changed the Redis configuration file this should
	// work.
	conn, err := redis.Dial("tcp", "localhost:6379")
	if err != nil {
		log.Fatal(err)
	}
	// Importantly, use defer to ensure the connection is always
	// properly closed before exiting the main() function.
	defer conn.Close()

	// Send our command across the connection. The first parameter to
	// Do() is always the name of the Redis command (in this example
	// HMSET), optionally followed by any necessary arguments (in this
	// example the key, followed by the various hash fields and values).
	_, err = conn.Do("HMSET", "album:2", "title", "Electric Ladyland", "artist", "Jimi Hendrix", "price", 4.95, "likes", 8)
	if err != nil {
		log.Fatal(err)
	}

	fmt.Println("Electric Ladyland added!")
}
</pre></code></figure>

<p>In this example we're not really interested in the reply from Redis (all successful <code>HMSET</code> commands just reply with the string "OK") so we don't do anything except check the return value from <code>Do()</code> for any errors.</p>

<p><strong>Working with replies</strong></p>

<p>When we <em>are</em> interested in the reply from Redis, the <code>gomodule/redigo/redis</code> package contains some useful helper functions for converting the reply (which has the type <code>interface{}</code>) into a Go type we can easily work with. These are:</p>

<ul>
    <li>redis.Bool() &ndash; converts a single reply to a <code>bool</code></li>
    <li>redis.Bytes() &ndash; converts a single reply to a byte slice (<code>[]byte</code>)</li>
    <li>redis.Float64()  &ndash; converts a single reply to a <code>float64</code></li>
    <li>redis.Int() &ndash; converts a single reply to a <code>int</code></li>
    <li>redis.String() &ndash; converts a single reply to a <code>string</code></li>
</ul>
<ul>
    <li>redis.Values() &ndash; converts an array reply to an slice of individual replies</li>
    <li>redis.Strings() &ndash; converts an array reply to an slice of strings <code>([]string)</code></li>
    <li>redis.ByteSlices() &ndash; converts an array reply to an slice of byte slices <code>([][]byte)</code></li>
    <li>redis.StringMap() &ndash;  converts an array of strings (alternating key, value) into a <code>map[string]string</code>. Useful for <code>HGETALL</code> etc</li>
</ul>

<p>Let's use some of these in conjunction with the <code>HGET</code> command to retrieve information from one of the album hashes:</p>

<figure class="file"><figcaption>File: main.go</figcaption><code><pre>
package main

import (
	"fmt"
	"log"

	"github.com/gomodule/redigo/redis"
)

func main() {
	conn, err := redis.Dial("tcp", "localhost:6379")
	if err != nil {
		log.Fatal(err)
	}
	defer conn.Close()

	// Issue a HGET command to retrieve the title for a specific album,
	// and use the Str() helper method to convert the reply to a string.
	title, err := redis.String(conn.Do("HGET", "album:1", "title"))
	if err != nil {
		log.Fatal(err)
	}

	// Similarly, get the artist and convert it to a string.
	artist, err := redis.String(conn.Do("HGET", "album:1", "artist"))
	if err != nil {
		log.Fatal(err)
	}

	// And the price as a float64...
	price, err := redis.Float64(conn.Do("HGET", "album:1", "price"))
	if err != nil {
		log.Fatal(err)
	}

	// And the number of likes as an integer.
	likes, err := redis.Int(conn.Do("HGET", "album:1", "likes"))
	if err != nil {
		log.Fatal(err)
	}

	fmt.Printf("%s by %s: £%.2f [%d likes]\n", title, artist, price, likes)
}
</pre></code></figure>

<p>It's worth pointing out that, when we use these helper methods, the error they return could relate to one of two things: either the failed execution of the command, or the conversion of the reply data to the desired type (for example, we'd get an error if we tried to convert the reply "Jimi Hendrix" to a <code>float64</code>).</code> There's no way of knowing which kind of error it is unless we examine the error message.</p>

<p>If you run the code above you should get output which looks like:</p>

<figure class="shell"><code><pre>
$ go run main.go
<samp>Electric Ladyland by Jimi Hendrix: £4.95 [8 likes]</samp>
</pre></code></figure>

<p>Let's now look at a more complete example, where we use the <code>HGETALL</code> command to retrieve all fields from an album hash in one go and store the information in a custom <code>Album</code> struct.</p>

<figure class="file"><figcaption>File: main.go</figcaption><code><pre>
package main

import (
	"fmt"
	"log"
	"strconv"

	"github.com/gomodule/redigo/redis"
)

// Define a custom struct to hold Album data.
type Album struct {
	Title  string
	Artist string
	Price  float64
	Likes  int
}

func main() {
	conn, err := redis.Dial("tcp", "localhost:6379")
	if err != nil {
		log.Fatal(err)
	}
	defer conn.Close()

	// Fetch all album fields with the HGETALL command. Because HGETALL
	// returns an array reply, and because the underlying data structure
	// in Redis is a hash, it makes sense to use the Map() helper
	// function to convert the reply to a map[string]string.
	reply, err := redis.StringMap(conn.Do("HGETALL", "album:1"))
	if err != nil {
		log.Fatal(err)
	}

	// Use the populateAlbum helper function to create a new Album
	// object from the map[string]string.
	album, err := populateAlbum(reply)
	if err != nil {
		log.Fatal(err)
	}

	fmt.Printf("%+v", album)
}

// Create, populate and return a pointer to a new Album struct, based
// on data from a map[string]string.
func populateAlbum(reply map[string]string) (*Album, error) {
	var err error
	album := new(Album)
	album.Title = reply["title"]
	album.Artist = reply["artist"]
	// We need to use the strconv package to convert the 'price' value
	// from a string to a float64 before assigning it.
	album.Price, err = strconv.ParseFloat(reply["price"], 64)
	if err != nil {
		return nil, err
	}
	// Similarly, we need to convert the 'likes' value from a string to
	// an integer.
	album.Likes, err = strconv.Atoi(reply["likes"])
	if err != nil {
		return nil, err
	}
	return album, nil
}
</pre></code></figure>

<p>Running this code should give an output like:</p>

<figure class="shell"><code><pre>
$ go run main.go
<samp>&{Title:Electric Ladyland Artist:Jimi Hendrix Price:4.95 Likes:8}</samp>
</pre></code></figure>

<p>Or an alternative, and arguably neater, approach is to use the <code>redis.Values()</code> and <code>redis.ScanStruct()</code> functions to automatically unpack the data to the <code>Album</code> struct, like so:</p>

<figure class="file"><figcaption>File: main.go</figcaption><code><pre>
package main

import (
	"fmt"
	"log"

	"github.com/gomodule/redigo/redis"
)

// Define a custom struct to hold Album data. Notice the struct tags?
// These indicate to redigo how to assign the data from the reply into
// the struct.
type Album struct {
	Title  string  `redis:"title"`
	Artist string  `redis:"artist"`
	Price  float64 `redis:"price"`
	Likes  int     `redis:"likes"`
}

func main() {
	conn, err := redis.Dial("tcp", "localhost:6379")
	if err != nil {
		log.Fatal(err)
	}
	defer conn.Close()

	// Fetch all album fields with the HGETALL command. Wrapping this
	// in the redis.Values() function transforms the response into type
	// []interface{}, which is the format we need to pass to
	// redis.ScanStruct() in the next step.
	values, err := redis.Values(conn.Do("HGETALL", "album:1"))
	if err != nil {
		log.Fatal(err)
	}

	// Create an instance of an Album struct and use redis.ScanStruct()
	// to automatically unpack the data to the struct fields. This uses
	// the struct tags to determine which data is mapped to which
	// struct fields.
	var album Album
	err = redis.ScanStruct(values, &album)
	if err != nil {
		log.Fatal(err)
	}

	fmt.Printf("%+v", album)
}
</pre></code></figure>

<p>Note: Behind the scenes the <code>redis.ScanStruct()</code> function uses Go's <code>strconv</code> package to convert the values returned from Redis in to the appropriate Go type for the struct field &mdash; similar in principle to what we did in the previous example. By default this supports integer, float, boolean, string and []byte fields. If you need to automatically scan into a custom type, you can do so by implemeting the <a href="https://godoc.org/github.com/gomodule/redigo/redis#Scanner"><code>redis.Scanner()</code></a> interface on your custom type.</p>

<h2>Using in a web application</h2>

<p>One important thing to know about <code>gomodule/redigo/redis</code> is that the <code>Conn</code> object (which is returned by the <code>Dial()</code> function we've been using so far) is <strong>not safe for concurrent use</strong>.</p>

<p>If we want to access a single Redis server from multiple goroutines, as we would in a web application, we must use establish a <em>pool of Redis connections</em>, and each time we want to use a connection we fetch it from the pool, execute our command on it, and return it too the pool.</p>

<p>We'll illustrate this in a simple web application, building on the online record store example we've already used. Our finished app will support 3 functions:</p>

<table>
<tr><th>Method</th><th>Path</th><th>Function</th></tr>
<tr><td>GET</td><td>/album?id=1</td><td>Show details of a specific album (using the id provided <br>in the query string)</td></tr>
<tr><td>POST</td><td>/like</td><td>Add a new like for a specific album (using the id <br>provided in the request body)</td></tr>
<tr><td>GET</td><td>/popular</td><td>List the top 3 most liked albums in order</td></tr>
</table>

<p>To avoid detracting from the main purpose of this blog post (which is talking about Redis) we'll use a deliberately over-simplified pattern for our web application. If you'd like to follow along, create a basic application scaffold like so&hellip;</p>

<figure class="shell"><code><pre>
$ mkdir recordstore && cd recordstore
$ go mod init example.com/recordstore
<samp>go: creating new go.mod: module example.com/recordstore</samp>
$ touch main.go albums.go
$ tree
<samp>.
├── albums.go
├── go.mod
└── main.go</samp>
</pre></code></figure>

<p>&hellip;And use the Redis CLI to add a few additional albums, along with a new <code>likes</code> sorted set. This sorted set will be used within the <code>GET /popular</code> route to help us quickly and efficiently retrieve the ids of albums with the most likes. Here's the commands to run:</p>

<figure class="shell"><code><pre>
HMSET album:1 title "Electric Ladyland" artist "Jimi Hendrix" price 4.95 likes 8
HMSET album:2 title "Back in Black" artist "AC/DC" price 5.95 likes 3
HMSET album:3 title "Rumours" artist "Fleetwood Mac" price 7.95 likes 12
HMSET album:4 title "Nevermind" artist "Nirvana" price 5.95 likes 8
ZADD likes 8 1 3 2 12 3 8 4
</pre></code></figure>

<p>In the <code>albums.go</code> file we'll define a global variable to hold a Redis connection pool, and we'll re-purpose the code we wrote earlier into a <code>FindAlbum()</code> function that we can use from our HTTP handlers.</p>

<figure class="file"><figcaption>File: albums.go</figcaption><code><pre>
package main

import (
	"errors"

	"github.com/gomodule/redigo/redis"
)

// Declare a pool variable to hold the pool of Redis connections.
var pool *redis.Pool

var ErrNoAlbum = errors.New("no album found")

// Define a custom struct to hold Album data.
type Album struct {
	Title  string  `redis:"title"`
	Artist string  `redis:"artist"`
	Price  float64 `redis:"price"`
	Likes  int     `redis:"likes"`
}

func FindAlbum(id string) (*Album, error) {
	// Use the connection pool's Get() method to fetch a single Redis
	// connection from the pool.
	conn := pool.Get()

	// Importantly, use defer and the connection's Close() method to
	// ensure that the connection is always returned to the pool before
	// FindAlbum() exits.
	defer conn.Close()

	// Fetch the details of a specific album. If no album is found
	// the given id, the []interface{} slice returned by redis.Values
	// will have a length of zero. So check for this and return an
	// ErrNoAlbum error as necessary.
	values, err := redis.Values(conn.Do("HGETALL", "album:"+id))
	if err != nil {
		return nil, err
	} else if len(values) == 0 {
		return nil, ErrNoAlbum
	}

	var album Album
	err = redis.ScanStruct(values, &album)
	if err != nil {
		return nil, err
	}

	return &album, nil
}
</pre></code></figure>

<p>Alright, let's head over to the <code>main.go</code> file. In this we will initialize the connection pool and set up a simple web server and HTTP handler for the <code>GET /album</code> route.</p>

<figure class="file"><figcaption>File: main.go</figcaption><code><pre>
package main

import (
	"fmt"
	"log"
	"net/http"
	"strconv"
	"time"

	"github.com/gomodule/redigo/redis"
)


func main() {
	// Initialize a connection pool and assign it to the pool global
	// variable.
	pool = &redis.Pool{
		MaxIdle:     10,
		IdleTimeout: 240 * time.Second,
		Dial: func() (redis.Conn, error) {
			return redis.Dial("tcp", "localhost:6379")
		},
	}

	mux := http.NewServeMux()
	mux.HandleFunc("/album", showAlbum)
	log.Println("Listening on :4000...")
	http.ListenAndServe(":4000", mux)
}

func showAlbum(w http.ResponseWriter, r *http.Request) {
	// Unless the request is using the GET method, return a 405 'Method
	// Not Allowed' response.
	if r.Method != http.MethodGet {
		w.Header().Set("Allow", http.MethodGet)
		http.Error(w, http.StatusText(405), 405)
		return
	}

	// Retrieve the id from the request URL query string. If there is
	// no id key in the query string then Get() will return an empty
	// string. We check for this, returning a 400 Bad Request response
	// if it's missing.
	id := r.URL.Query().Get("id")
	if id == "" {
		http.Error(w, http.StatusText(400), 400)
		return
	}
	// Validate that the id is a valid integer by trying to convert it,
	// returning a 400 Bad Request response if the conversion fails.
	if _, err := strconv.Atoi(id); err != nil {
		http.Error(w, http.StatusText(400), 400)
		return
	}

	// Call the FindAlbum() function passing in the user-provided id.
	// If there's no matching album found, return a 404 Not Found
	// response. In the event of any other errors, return a 500
	// Internal Server Error response.
	bk, err := FindAlbum(id)
	if err == ErrNoAlbum {
		http.NotFound(w, r)
		return
	} else if err != nil {
		http.Error(w, http.StatusText(500), 500)
		return
	}

	// Write the album details as plain text to the client.
	fmt.Fprintf(w, "%s by %s: £%.2f [%d likes] \n", bk.Title, bk.Artist, bk.Price, bk.Likes)
}
</pre></code></figure>

<p>It's worth elaborating on the <code>redis.Pool</code> settings. In the above code we specify a <code>MaxIdle</code> size of 10, which simply limits the number of <em>idle</em> connections waiting in the pool to 10 at any one time. If all 10 connections are in use when an additional <code>pool.Get()</code> call is made a new connection will be created on the fly. The <code>IdleTimeout</code> setting is set to 240 seconds, which means that any connections that are idle for longer than that will be removed from the pool.</p>

<p>If you run the application:

<figure class="shell"><code><pre>
$ go run .
<samp>2019/08/17 11:01:41 Listening on :4000...</samp>
</pre></code></figure>

<p>And make a request for one of the albums using cURL you should get a response like this:</p>

<figure class="shell"><code><pre>
$ curl -i localhost:4000/album?id=2
<samp>HTTP/1.1 200 OK
Content-Length: 42
Content-Type: text/plain; charset=utf-8

Back in Black by AC/DC: £5.95 [3 likes]</samp>
</pre></code></figure>

<h2>Using transactions</h2>

<p>The second route, <code>POST /likes</code>, is quite interesting.</p>

<p>When a user likes an album we need to issue two distinct commands: a <code>HINCRBY</code> to increment the <code>likes</code> field in the album hash, and a <code>ZINCRBY</code> to increment the relevant score in our <code>likes</code> sorted set.</p>

<p>This creates a problem. Ideally we would want both keys to be incremented at exactly the same time as a single atomic action. Having one key updated after the other opens up the potential for race conditions to occur.</p>

<p>The solution to this is to use Redis transactions, which let us run multiple commands together as an atomic group. To do this we use the <code>MULTI</code> command to start a transaction, followed by the commands (in our case a <code>HINCRBY</code> and <code>ZINCRBY</code>), and finally the <code>EXEC</code> command (which then executes our both our commands together as an atomic group).</p>

<p>Let's create a new <code>IncrementLikes()</code> function in the <code>albums.go</code> file which uses this technique.</p>

<figure class="file"><figcaption>File: albums.go</figcaption><code><pre>
...

func IncrementLikes(id string) error {
	conn := pool.Get()
	defer conn.Close()

	// Before we do anything else, check that an album with the given
	// id exists. The EXISTS command returns 1 if a specific key exists
	// in the database, and 0 if it doesn't.
	exists, err := redis.Int(conn.Do("EXISTS", "album:"+id))
	if err != nil {
		return err
	} else if exists == 0 {
		return ErrNoAlbum
	}

	// Use the MULTI command to inform Redis that we are starting a new
	// transaction. The conn.Send() method writes the command to the
	// connection's output buffer -- it doesn't actually send it to the
	// Redis server... despite it's name!
	err = conn.Send("MULTI")
	if err != nil {
		return err
	}

	// Increment the number of likes in the album hash by 1. Because it
	// follows a MULTI command, this HINCRBY command is NOT executed but
	// it is QUEUED as part of the transaction. We still need to check
	// the reply's Err field at this point in case there was a problem
	// queueing the command.
	err = conn.Send("HINCRBY", "album:"+id, "likes", 1)
	if err != nil {
		return err
	}
	// And we do the same with the increment on our sorted set.
	err = conn.Send("ZINCRBY", "likes", 1, id)
	if err != nil {
		return err
	}

	// Execute both commands in our transaction together as an atomic
	// group. EXEC returns the replies from both commands but, because
	// we're not interested in either reply in this example, it
	// suffices to simply check for any errors. Note that calling the
	// conn.Do() method flushes the previous commands from the
	// connection output buffer and sends them to the Redis server.
	_, err = conn.Do("EXEC")
	if err != nil {
		return err
	}

	return nil
}
</pre></code></figure>

<p>We'll also update the <code>main.go</code> file to add an <code>addLike()</code> handler for the route:</p>

<figure class="file"><figcaption>File: main.go</figcaption><code><pre>
package main

import (
	"fmt"
	"log"
	"net/http"
	"strconv"
	"time"

	"github.com/gomodule/redigo/redis"
)

func main() {
	pool = &redis.Pool{
		MaxIdle:     10,
		IdleTimeout: 240 * time.Second,
		Dial: func() (redis.Conn, error) {
			return redis.Dial("tcp", "localhost:6379")
		},
	}

	mux := http.NewServeMux()
	mux.HandleFunc("/album", showAlbum)
	mux.HandleFunc("/like", addLike)

	log.Println("Listening on :4000...")
	http.ListenAndServe(":4000", mux)
}

...

func addLike(w http.ResponseWriter, r *http.Request) {
	// Unless the request is using the POST method, return a 405
	// Method Not Allowed response.
	if r.Method != http.MethodPost {
		w.Header().Set("Allow", http.MethodPost)
		http.Error(w, http.StatusText(405), 405)
		return
	}

	// Retrieve the id from the POST request body. If there is no
	// parameter named "id" in the request body then PostFormValue()
	// will return an empty string. We check for this, returning a 400
	// Bad Request response if it's missing.
	id := r.PostFormValue("id")
	if id == "" {
		http.Error(w, http.StatusText(400), 400)
		return
	}
	// Validate that the id is a valid integer by trying to convert it,
	// returning a 400 Bad Request response if the conversion fails.
	if _, err := strconv.Atoi(id); err != nil {
		http.Error(w, http.StatusText(400), 400)
		return
	}

	// Call the IncrementLikes() function passing in the user-provided
	// id. If there's no album found with that id, return a 404 Not
	// Found response. In the event of any other errors, return a 500
	// Internal Server Error response.
	err := IncrementLikes(id)
	if err == ErrNoAlbum {
		http.NotFound(w, r)
		return
	} else if err != nil {
		http.Error(w, http.StatusText(500), 500)
		return
	}

	// Redirect the client to the GET /album route, so they can see the
	// impact their like has had.
	http.Redirect(w, r, "/album?id="+id, 303)
}
</pre></code></figure>

<p>If you make a POST request to like one of the albums you should now get a response like:</p>

<figure class="shell"><code><pre>
$ curl -i -L -d "id=2" localhost:4000/like
<samp>HTTP/1.1 303 See Other
Location: /album?id=2
Date: Sat, 17 Aug 2019 16:50:49 GMT
Content-Length: 0

HTTP/1.1 200 OK
Date: Sat, 17 Aug 2019 16:50:49 GMT
Content-Length: 42
Content-Type: text/plain; charset=utf-8

Back in Black by AC/DC: £5.95 [4 likes]</samp>
</pre></code></figure>

<h2>Using the Watch command</h2>

<p>OK, on to our final route: <code>GET /popular</code>. This route will display the details of the top 3 albums with the most likes, so to facilitate this we'll create a <code>FindTopThree()</code> function in the <code>albums.go</code> file. In this function we need to:</p>

<ol>
    <li>Use the <code>ZREVRANGE</code> command to fetch the 3 album ids with the highest score (i.e. most likes) from our <code>likes</code> sorted set.</li>
    <li>Loop through the returned ids, using the <code>HGETALL</code> command to retrieve the details of each album and add them to a <code>[]*Album</code> slice.</li>
</ol>

<p>Again, it's possible to imagine a race condition occurring here. If a second client happens to like an album at the exact moment <em>between</em> our <code>ZREVRANGE</code> command and the <code>HGETALL</code>s for all 3 albums being completed, our user could end up being sent wrong or mis-ordered data.</p>

<p>The solution here is to use the Redis <code>WATCH</code> command in conjunction with a transaction. <code>WATCH</code> instructs Redis to monitor a specific key for any changes. If another client or connection modifies our watched key between our <code>WATCH</code> instruction and our subsequent transaction's <code>EXEC</code>, the transaction will fail and return a nil reply. If no client changes the value before our <code>EXEC</code>, the transaction will complete as normal. We can execute our code in a loop until the transaction is successful.</p>

<figure class="file"><figcaption>File: albums.go</figcaption><code><pre>
package main

...


func FindTopThree() ([]*Album, error) {
	conn := pool.Get()
	defer conn.Close()

	// Begin an infinite loop. In a real application, you might want to
	// limit this to a set number of attempts, and return an error if
	// the transaction doesn't successfully complete within those
	// attempts.
	for {
		// Instruct Redis to watch the likes sorted set for any changes.
		_, err := conn.Do("WATCH", "likes")
		if err != nil {
			return nil, err
		}

		// Use the ZREVRANGE command to fetch the album ids with the
		// highest score (i.e. most likes) from our 'likes' sorted set.
		// The ZREVRANGE start and stop values are zero-based indexes,
		// so we use 0 and 2 respectively to limit the reply to the top
		// three. Because ZREVRANGE returns an array response, we use
		// the Strings() helper function to convert the reply into a
		// []string.
		ids, err := redis.Strings(conn.Do("ZREVRANGE", "likes", 0, 2))
		if err != nil {
			return nil, err
		}

		// Use the MULTI command to inform Redis that we are starting
		// a new transaction.
		err = conn.Send("MULTI")
		if err != nil {
			return nil, err
		}

		// Loop through the ids returned by ZREVRANGE, queuing HGETALL
		// commands to fetch the individual album details.
		for _, id := range ids {
			err := conn.Send("HGETALL", "album:"+id)
			if err != nil {
				return nil, err
			}
		}

		// Execute the transaction. Importantly, use the redis.ErrNil
		// type to check whether the reply from EXEC was nil or not. If
		// it is nil it means that another client changed the WATCHed
		// likes sorted set, so we use the continue command to re-run
		// the loop.
		replies, err := redis.Values(conn.Do("EXEC"))
		if err == redis.ErrNil {
			log.Println("trying again")
			continue
		} else if err != nil {
			return nil, err
		}

		// Create a new slice to store the album details.
		albums := make([]*Album, 3)

		// Iterate through the array of response objects, using the
		// ScanStruct() function to assign the data to Album structs.
		for i, reply := range replies {
			var album Album
			err = redis.ScanStruct(reply.([]interface{}), &album)
			if err != nil {
				return nil, err
			}

			albums[i] = &album
		}

		return albums, nil
	}
}
</pre></code></figure>

<p>Using this from our web application is nice and straightforward:</p>

<figure class="file"><figcaption>File: main.go</figcaption><code><pre>
package main

import (
	"fmt"
	"log"
	"net/http"
	"strconv"
	"time"

	"github.com/gomodule/redigo/redis"
)

func main() {
	pool = &redis.Pool{
		MaxIdle:     10,
		IdleTimeout: 240 * time.Second,
		Dial: func() (redis.Conn, error) {
			return redis.Dial("tcp", "localhost:6379")
		},
	}

	mux := http.NewServeMux()
	mux.HandleFunc("/album", showAlbum)
	mux.HandleFunc("/like", addLike)
	mux.HandleFunc("/popular", listPopular)

	log.Println("Listening on :4000...")
	http.ListenAndServe(":4000", mux)
}

...

func listPopular(w http.ResponseWriter, r *http.Request) {
	// Unless the request is using the GET method, return a 405 'Method Not
	// Allowed' response.
	if r.Method != http.MethodGet {
		w.Header().Set("Allow", http.MethodGet)
		http.Error(w, http.StatusText(405), 405)
		return
	}

	// Call the FindTopThree() function, returning a return a 500 Internal
	// Server Error response if there's any error.
	albums, err := FindTopThree()
	if err != nil {
		http.Error(w, http.StatusText(500), 500)
		return
	}

	// Loop through the 3 albums, writing the details as a plain text list
	// to the client.
	for i, ab := range albums {
		fmt.Fprintf(w, "%d) %s by %s: £%.2f [%d likes] \n", i+1, ab.Title, ab.Artist, ab.Price, ab.Likes)
	}
}
</pre></code></figure>

<p>One note about <code>WATCH</code>: a key will remain <code>WATCH</code>ed until either we either <code>EXEC</code> (or <code>DISCARD</code>) our transaction, or we manually call <code>UNWATCH</code> on the key. So calling <code>EXEC</code>, as we do in the above example, is sufficient and the <code>likes</code> sorted set will be automatically <code>UNWATCH</code>ed.</p>

<p>Making a request to the <code>GET /popular</code> route should now yield a response similar to:</p>

<figure class="shell"><code><pre>
$ curl -i localhost:4000/popular
<samp>HTTP/1.1 200 OK
Content-Length: 147
Content-Type: text/plain; charset=utf-8
Date: Sat, 17 Aug 2019 17:10:13 GMT

1) Rumours by Fleetwood Mac: £7.95 [12 likes]
2) Nevermind by Nirvana: £5.95 [8 likes]
3) Electric Ladyland by Jimi Hendrix: £4.95 [8 likes]</samp>
</pre></code></figure>
    ]]></description>
  </item>
  <item>
    <pubDate>Thu, 16 Jul 2015 23:00:00 GMT</pubDate>
    <link>https://www.alexedwards.net/blog/organising-database-access</link>
    <guid>https://www.alexedwards.net/blog/organising-database-access</guid>
    <title>Organising Database Access in Go</title>
    <description><![CDATA[
<p>A few weeks ago someone created a <a href="http://www.reddit.com/r/golang/comments/38hkor/go_best_practice_for_accessing_database_in/">thread on Reddit</a> asking:</p>

<blockquote>
    <p>In the context of a web application what would you consider a Go best practice for accessing the database in (HTTP or other) handlers?</p>
</blockquote>

<p>The replies it got were a genuinely interesting mix. Some people advised using dependency injection, a few favoured the simplicity of using global variables, others suggested putting the connection pool pointer into the request context.</p>

<p>Me? I think the right answer depends on the project.</p>

<p><em>What's the overall structure and size of the project? What's your approach to testing? How is it likely to grow in the future?</em> All these things and more should play a part when you pick an approach to take.</p>

<p>So in this post we're going to take a look at four different methods for organizing your code and structuring access to your database connection pool, and explain when they may &mdash; or may not &mdash; be a good fit for your project.</p>

<h2>Application setup</h2>

<p>I like concrete examples, so let's set up a simple book store application to help illustrate the four different approaches. If you'd like to follow along, you need to create a new <code>bookstore</code> database and then execute the following SQL to create a <code>books</code> table and add some sample records.</p>

<figure class="plain"><code class="sql">
        <pre>
CREATE TABLE books (
    isbn char(14) NOT NULL,
    title varchar(255) NOT NULL,
    author varchar(255) NOT NULL,
    price decimal(5,2) NOT NULL
);

INSERT INTO books (isbn, title, author, price) VALUES
('978-1503261969', 'Emma', 'Jayne Austen', 9.44),
('978-1505255607', 'The Time Machine', 'H. G. Wells', 5.99),
('978-1503379640', 'The Prince', 'Niccolò Machiavelli', 6.99);

ALTER TABLE books ADD PRIMARY KEY (isbn);
</pre></code></figure>

<aside class="note">
    <strong>Note:</strong> In this tutorial I'll be using PostgreSQL, but the principles are the same no matter what database you're using.
</aside>

<p>You'll also need to run the following commands to scaffold a basic application structure and initialize a Go module:</p>

<figure class="shell"><code>
        <pre>
$ mkdir bookstore && cd bookstore
$ mkdir models
$ touch main.go models/models.go
$ go mod init bookstore.alexedwards.net
<samp>go: creating new go.mod: module bookstore.alexedwards.net</samp>
</pre></code></figure>

<p>At this point, you should have a <code>bookstore</code> directory on your machine with a structure exactly like this:</p>

<figure class="shell"><code>
        <pre>
bookstore/
├── go.mod
├── main.go
└── models
    └── models.go
</pre></code></figure>

<h2 id="global-variables">1. Using a global variable</h2>

<p>OK, let's start by looking at storing the database connection pool in a global variable.</p>

<p>This approach is arguably the <em>simplest thing that works</em>. You initialise the <code>sql.DB</code> connection pool in your <code>main()</code> function, assign it to a global variable, and then access the global from anywhere that you need to execute a database query.</p>

<p>In the context of our book store application, the code would look something like this:</p>

<figure class="file">
    <figcaption>File: models/models.go</figcaption><code class="go">
        <pre>
package models

import (
    "database/sql"
)

// Create an exported global variable to hold the database connection pool.
var DB *sql.DB

type Book struct {
    Isbn   string
    Title  string
    Author string
    Price  float32
}

// AllBooks returns a slice of all books in the books table.
func AllBooks() ([]Book, error) {
    // Note that we are calling Query() on the global variable.
    rows, err := DB.Query("SELECT * FROM books")
    if err != nil {
        return nil, err
    }
    defer rows.Close()

    var bks []Book

    for rows.Next() {
        var bk Book

        err := rows.Scan(&bk.Isbn, &bk.Title, &bk.Author, &bk.Price)
        if err != nil {
            return nil, err
        }

        bks = append(bks, bk)
    }
    if err = rows.Err(); err != nil {
        return nil, err
    }

    return bks, nil
}               
</pre></code>
</figure>

<figure class="file">
    <figcaption>File: main.go</figcaption><code class="go">
        <pre>
package main

import (
    "database/sql"
    "fmt"
    "log"
    "net/http"

    "bookstore.alexedwards.net/models"

    _ "github.com/lib/pq"
)

func main() {
    var err error

    // Initalize the sql.DB connection pool and assign it to the models.DB 
    // global variable.
    models.DB, err = sql.Open("postgres", "postgres://user:pass@localhost/bookstore")
    if err != nil {
        log.Fatal(err)
    }

    http.HandleFunc("/books", booksIndex)
    http.ListenAndServe(":3000", nil)
}

// booksIndex sends a HTTP response listing all books.
func booksIndex(w http.ResponseWriter, r *http.Request) {
    bks, err := models.AllBooks()
    if err != nil {
        log.Println(err)
        http.Error(w, http.StatusText(500), 500)
        return
    }

    for _, bk := range bks {
        fmt.Fprintf(w, "%s, %s, %s, £%.2f\n", bk.Isbn, bk.Title, bk.Author, bk.Price)
    }
}           
</pre></code>
</figure>

<p>At this point, if you run this application and make a request to the <code>/books</code> endpoint you should get the following response:</p>

<figure class="shell"><code>
        <pre>
$ curl localhost:3000/books
<samp>978-1503261969, Emma, Jayne Austen, £9.44
978-1505255607, The Time Machine, H. G. Wells, £5.99
978-1503379640, The Prince, Niccolò Machiavelli, £6.99</samp>
</pre></code></figure>

<p>Using a global variable to store the database connection pool like this is potentially a good fit when:</p>

<ul>
    <li>Your application is small and simple, and keeping track of globals in your head isn't a problem.</li>
    <li>Your HTTP handlers are spread across multiple packages, but all your database-related code lives in one package.</li>
    <li>You don't need to mock the database for testing purposes.</li>
</ul>

<p>The drawbacks of using global variables are <a href="https://softwareengineering.stackexchange.com/questions/148108/why-is-global-state-so-evil">well-documented</a>, but in practice I've found that for small and simple projects using a global variable like this works just fine, and it's (arguably) clearer and easier to understand than some of the other approaches we'll look at in this post.</p>

<p>For more complex applications &mdash; where your handlers have more dependencies beyond just the database connection pool &mdash; it's generally better to use dependency injection instead of storing everything in global variables.</p>

<p>The approach we've taken here also doesn't work if your database logic is spread over multiple packages, although &mdash; if you really want to &mdash; you could a separate <code>config</code> package containing an exported <code>DB</code> global variable and <code>import "yourproject/config"</code> into every file that needs it. I've provided a basic example in <a href="https://gist.github.com/alexedwards/534b79818ac8cb2410762ea33cee91f2">this gist</a>.</p>

<h3 id="initDB">1b. Global variable with an InitDB function</h3>

<p>A variation on the 'global variable' approach that I sometimes see uses an initialisation function to set up the connection pool, like so:</p>



<figure class="file">
    <figcaption>File: models/models.go</figcaption><code class="go">
        <pre>
package models

import (
    "database/sql"

    _ "github.com/lib/pq"
)

// This time the global variable is unexported.
var db *sql.DB

// InitDB sets up setting up the connection pool global variable.
func InitDB(dataSourceName string) error {
    var err error

    db, err = sql.Open("postgres", dataSourceName)
    if err != nil {
        return err
    }

    return db.Ping()
}

type Book struct {
    Isbn   string
    Title  string
    Author string
    Price  float32
}

func AllBooks() ([]Book, error) {
    // This now uses the unexported global variable.
    rows, err := db.Query("SELECT * FROM books")
    if err != nil {
        return nil, err
    }
    defer rows.Close()

    var bks []Book

    for rows.Next() {
        var bk Book

        err := rows.Scan(&bk.Isbn, &bk.Title, &bk.Author, &bk.Price)
        if err != nil {
            return nil, err
        }

        bks = append(bks, bk)
    }
    if err = rows.Err(); err != nil {
        return nil, err
    }

    return bks, nil
}  
</pre></code>
</figure>

<figure class="file">
    <figcaption>File: main.go</figcaption><code class="go">
        <pre>
package main

import (
    "fmt"
    "log"
    "net/http"

    "bookstore.alexedwards.net/models"
)

func main() {
    // Use the InitDB function to initialise the global variable.
    err := models.InitDB("postgres://user:pass@localhost/bookstore")
    if err != nil {
        log.Fatal(err)
    }

    http.HandleFunc("/books", booksIndex)
    http.ListenAndServe(":3000", nil)
}

...             
</pre></code>
</figure>

<p>This is a small tweak to the global variable pattern, but it gives us a few nice benefits:</p>

<ul>
    <li>All the database-related code now lives a single package, including the code to set up the connection pool.</li>
    <li>The global <code>db</code> variable is not exported, which removes the possibility of it being accidentally mutated by other packages at runtime.</li>
    <li>During testing, you can reuse the <code>InitDB()</code> function to initialise a connection pool to your test database (by calling it from <a href="https://medium.com/goingogo/why-use-testmain-for-testing-in-go-dafb52b406bc"><code>TestMain()</code></a> before your tests run).</li>
</ul>

<h2 id="dependency-injection">2. Dependency injection</h2>

<p>In a more complex web application there are probably additional application-level objects that you want your handlers to have access to. For example, you might want your handlers to also have access to a shared logger, or a template cache, as well your database connection pool.</p>

<p>Rather than storing all these dependencies in global variables, a neat approach is to store them in a single custom <code>Env</code> struct like so:</p>

<figure class="plain"><code class="go">
        <pre>
type Env struct {
    db *sql.DB
    logger *log.Logger
    templates *template.Template
}
</pre></code></figure>

<p>The nice thing about this is that you can then define your handlers as <em>methods against <code>Env</code></em>. This gives you a easy and idiomatic way of making the connection pool (and any other dependencies) available to your handlers.</p>

<p>Here's a full example:</p>

<figure class="file">
    <figcaption>File: models/models.go</figcaption><code class="go">
        <pre>
package models

import (
    "database/sql"
)

type Book struct {
    Isbn   string
    Title  string
    Author string
    Price  float32
}

// Update the AllBooks function so it accepts the connection pool as a 
// parameter.
func AllBooks(db *sql.DB) ([]Book, error) {
    rows, err := db.Query("SELECT * FROM books")
    if err != nil {
        return nil, err
    }
    defer rows.Close()

    var bks []Book

    for rows.Next() {
        var bk Book

        err := rows.Scan(&bk.Isbn, &bk.Title, &bk.Author, &bk.Price)
        if err != nil {
            return nil, err
        }

        bks = append(bks, bk)
    }
    if err = rows.Err(); err != nil {
        return nil, err
    }

    return bks, nil
}     
</pre></code>
</figure>

<figure class="file">
    <figcaption>File: main.go</figcaption><code class="go">
        <pre>
package main

import (
    "database/sql"
    "fmt"
    "log"
    "net/http"

    "bookstore.alexedwards.net/models"

    _ "github.com/lib/pq"
)

// Create a custom Env struct which holds a connection pool.
type Env struct {
    db *sql.DB
}

func main() {
    // Initialise the connection pool.
    db, err := sql.Open("postgres", "postgres://user:pass@localhost/bookstore")
    if err != nil {
        log.Fatal(err)
    }

    // Create an instance of Env containing the connection pool.
    env := &Env{db: db}

    // Use env.booksIndex as the handler function for the /books route.
    http.HandleFunc("/books", env.booksIndex)
    http.ListenAndServe(":3000", nil)
}

// Define booksIndex as a method on Env.
func (env *Env) booksIndex(w http.ResponseWriter, r *http.Request) {
    // We can now access the connection pool directly in our handlers.
    bks, err := models.AllBooks(env.db)
    if err != nil {
        log.Println(err)
        http.Error(w, http.StatusText(500), 500)
        return
    }

    for _, bk := range bks {
        fmt.Fprintf(w, "%s, %s, %s, £%.2f\n", bk.Isbn, bk.Title, bk.Author, bk.Price)
    }
}                 
</pre></code>
</figure>

<p>One of the advantages of this pattern is how clear it is to see <em>what dependencies our handlers have</em> and <em>what values they take at runtime</em>. All the dependencies for our handlers are explicitly defined in one place (the <code>Env</code> struct), and we can see what values they have at runtime by simply looking at how it is initialised in the <code>main()</code> function.</p>

<p>Another benefit is that any unit tests for our handlers can be completely self-contained. For example, a unit-test for <code>booksIndex()</code> could create an <code>Env</code> struct containing a connection pool to a test database, then call it's <code>booksIndex()</code> method in order to test the handler behaviour. There's no need to rely any global variables <em>outside of the test</em>.</p>

<p>In general, dependency injection in this way is quite a nice approach when:</p>

<ul>
    <li>There is a common set of dependencies that your handlers need access to.</li>
    <li>All your HTTP handlers live in one package, but your database-related code may be spread across multiple packages.</li>
    <li>You don't need to mock the database for testing purposes.</li>
</ul>

<h3 id="closure">2b. Dependency injection via a closure</h3>

<p>If you don't want to define your handlers as methods on <code>Env</code>, an alternative approach is to put your handler logic into a closure and <em>close over</em> the <code>Env</code> variable like so:</p>

<figure class="file">
    <figcaption>File: main.go</figcaption><code class="go">
        <pre>
package main

import (
    "database/sql"
    "fmt"
    "log"
    "net/http"

    "bookstore.alexedwards.net/models"

    _ "github.com/lib/pq"
)

type Env struct {
    db *sql.DB
}

func main() {
    db, err := sql.Open("postgres", "postgres://user:pass@localhost/bookstore")
    if err != nil {
        log.Fatal(err)
    }

    env := &Env{db: db}

    // Pass the Env struct as a parameter to booksIndex().
    http.Handle("/books", booksIndex(env))
    http.ListenAndServe(":3000", nil)
}

// Use a closure to make Env available to the handler logic.
func booksIndex(env *Env) http.HandlerFunc {
    return func(w http.ResponseWriter, r *http.Request) {
        bks, err := models.AllBooks(env.db)
        if err != nil {
            log.Println(err)
            http.Error(w, http.StatusText(500), 500)
            return
        }

        for _, bk := range bks {
            fmt.Fprintf(w, "%s, %s, %s, £%.2f\n", bk.Isbn, bk.Title, bk.Author, bk.Price)
        }
    }
}    
</pre></code>
</figure>

<p>This pattern makes our handler functions a bit more verbose, but it can be a useful technique if you want to use dependency injection when <em>your handlers are spread across multiple packages</em>. Here's a <a href="https://gist.github.com/alexedwards/d42ae90aac9dfa75046ebf8a036b080b">gist</a> demonstrating how that can work.</p>

<h2 id="wrapping-the-connection-pool">3. Wrapping the connection pool</h2>

<p>The third pattern we'll look at uses dependency injection again, but this time we're going to wrap the <code>sql.DB</code> connection pool in our own custom type.</p>

<p>Let's jump straight in to the code:</p>

<figure class="file">
    <figcaption>File: models/models.go</figcaption><code class="go">
        <pre>
package models

import (
	"database/sql"
)

type Book struct {
	Isbn   string
	Title  string
	Author string
	Price  float32
}

// Create a custom BookModel type which wraps the sql.DB connection pool.
type BookModel struct {
	DB *sql.DB
}

// Use a method on the custom BookModel type to run the SQL query.
func (m BookModel) All() ([]Book, error) {
	rows, err := m.DB.Query("SELECT * FROM books")
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var bks []Book

	for rows.Next() {
		var bk Book

		err := rows.Scan(&bk.Isbn, &bk.Title, &bk.Author, &bk.Price)
		if err != nil {
			return nil, err
		}

		bks = append(bks, bk)
	}
	if err = rows.Err(); err != nil {
		return nil, err
	}

	return bks, nil
}
</pre></code>
</figure>

<figure class="file">
    <figcaption>File: main.go</figcaption><code class="go">
        <pre>
package main

import (
	"database/sql"
	"fmt"
	"log"
	"net/http"

	"bookstore.alexedwards.net/models"

	_ "github.com/lib/pq"
)

// This time make models.BookModel the dependency in Env.
type Env struct {
	books models.BookModel
}

func main() {
    // Initialise the connection pool as normal.
	db, err := sql.Open("postgres", "postgres://user:pass@localhost/bookstore")
	if err != nil {
		log.Fatal(err)
	}

    // Initalise Env with a models.BookModel instance (which in turn wraps
    // the connection pool).
	env := &Env{
		books: models.BookModel{DB: db},
	}

	http.HandleFunc("/books", env.booksIndex)
	http.ListenAndServe(":3000", nil)
}

func (env *Env) booksIndex(w http.ResponseWriter, r *http.Request) {
    // Execute the SQL query by calling the All() method.
	bks, err := env.books.All()
	if err != nil {
		log.Println(err)
		http.Error(w, http.StatusText(500), 500)
		return
	}

	for _, bk := range bks {
		fmt.Fprintf(w, "%s, %s, %s, £%.2f\n", bk.Isbn, bk.Title, bk.Author, bk.Price)
	}
}
</pre></code>
</figure>

<p>At first glance this pattern might feel more confusing than the other options we've looked at &mdash; especially if you're not very familiar with Go. But it has some distinct advantages over our previous examples:</p>

<ul>
    <li>The database calls are succinct and read very nicely from the perspective of our handlers: <code>env.books.All()</code> versus the previous <code>models.AllBooks(env.db)</code>.</li>
    <li>In a complex application, your database access layer might have more dependencies than just the connection pool. This pattern allows us to store all those dependencies in the custom <code>BookModel</code> type, rather than having to pass them as parameters with every call.</li>
    <li>Because the database actions are now defined as methods on our custom <code>BookModel</code> type, it opens up the opportunity to replace any references to <code>BookModel</code> in our application code with an interface. And in turn, that means that we can create a mock implementation of our <code>BookModel</code> which can be used during testing.</li>
</ul>

<p>The final point here is probably the most important, so let's take a look at what it could look like in practice:</p>

<figure class="file">
    <figcaption>File: main.go</figcaption><code class="go">
        <pre>
package main

import (
	"database/sql"
	"fmt"
	"log"
	"net/http"

	"bookstore.alexedwards.net/models"

	_ "github.com/lib/pq"
)

type Env struct {
    // Replace the reference to models.BookModel with an interface 
    // describing its methods instead. All the other code remains exactly 
    // the same. 
	books interface {
		All() ([]models.Book, error)
	}
}

func main() {
	db, err := sql.Open("postgres", "postgres://user:pass@localhost/bookstore")
	if err != nil {
		log.Fatal(err)
	}

	env := &Env{
		books: models.BookModel{DB: db},
	}

	http.HandleFunc("/books", env.booksIndex)
	http.ListenAndServe(":3000", nil)
}

func (env *Env) booksIndex(w http.ResponseWriter, r *http.Request) {
	bks, err := env.books.All()
	if err != nil {
		log.Println(err)
		http.Error(w, http.StatusText(500), 500)
		return
	}

	for _, bk := range bks {
		fmt.Fprintf(w, "%s, %s, %s, £%.2f\n", bk.Isbn, bk.Title, bk.Author, bk.Price)
	}
}
</pre></code>
</figure>

<aside class="note">
    <strong>Note:</strong> If you're not familiar with the concept of interfaces or how they work in Go, I've written a <a href="https://www.alexedwards.net/blog/interfaces-explained">detailed tutorial explaining them here</a>.
</aside>

<p>Once you've made that change, you should be able to create and run a unit test for the <code>booksIndex()</code> handler using a <code>mockBookModel</code> like so:</p>

<figure class="shell"><code>
        <pre>
$ touch main_test.go</pre></code></figure>



<figure class="file">
    <figcaption>File: main_test.go</figcaption><code class="go">
        <pre>
package main

import (
	"net/http"
	"net/http/httptest"
	"testing"

	"bookstore.alexedwards.net/models"
)

type mockBookModel struct{}

func (m *mockBookModel) All() ([]models.Book, error) {
	var bks []models.Book

	bks = append(bks, models.Book{"978-1503261969", "Emma", "Jayne Austen", 9.44})
	bks = append(bks, models.Book{"978-1505255607", "The Time Machine", "H. G. Wells", 5.99})

	return bks, nil
}

func TestBooksIndex(t *testing.T) {
	rec := httptest.NewRecorder()
	req, _ := http.NewRequest("GET", "/books", nil)

	env := Env{books: &mockBookModel{}}

	http.HandlerFunc(env.booksIndex).ServeHTTP(rec, req)

	expected := "978-1503261969, Emma, Jayne Austen, £9.44\n978-1505255607, The Time Machine, H. G. Wells, £5.99\n"
	if expected != rec.Body.String() {
		t.Errorf("\n...expected = %v\n...obtained = %v", expected, rec.Body.String())
	}
}
</pre></code>
</figure>

<figure class="shell"><code>
        <pre>
$ go test -v
<samp>=== RUN   TestBooksIndex
--- PASS: TestBooksIndex (0.00s)
PASS
ok      bookstore.alexedwards.net       0.003s</samp>
</pre></code></figure>

<p>Wrapping the connection pool with a custom type and combining it with dependency injection via an <code>Env</code> struct is quite a nice approach when:</p>

<ul>
    <li>There is a common set of dependencies that your handlers need access to.</li>
    <li>Your database layer has more dependencies than just the connection pool.</li>
    <li>You want to mock the database during unit tests.</li>
</ul>

<h2 id="request-context">4. Request context</h2>

<p>Finally let's look at using <a href="https://golang.org/pkg/net/http/#Request.Context">request context</a> to store and pass around the database connection pool. Just to be clear upfront, I don't recommend using this approach, and the <a href="https://golang.org/pkg/context/">official documentation</a> advises against it too:</p>

<blockquote>
    <p>Use context Values <strong>only for request-scoped data</strong> that transits processes and APIs, not for passing optional parameters to functions.</p>
</blockquote>

<p>In other words, that means request context should only be used to store values which are created <em>during an individual request cycle</em> and are no longer needed after the request has completed. It's not really intended to store long-lived handler dependencies like connection pools, loggers or template caches.</p>

<p>That said, some people <em>do</em> use request context in this way, and it's worth being aware of in case you ever come across it.</p>

<p>The pattern works like this:</p>

<figure class="file">
    <figcaption>File: main.go</figcaption><code class="go">
        <pre>
package main

import (
    "context"
    "database/sql"
    "fmt"
    "log"
    "net/http"

    "bookstore.alexedwards.net/models"

    _ "github.com/lib/pq"
)

// Create some middleware which swaps out the existing request context
// with new context.Context value containing the connection pool.
func injectDB(db *sql.DB, next http.HandlerFunc) http.HandlerFunc {
    return func(w http.ResponseWriter, r *http.Request) {
        ctx := context.WithValue(r.Context(), "db", db)

        next.ServeHTTP(w, r.WithContext(ctx))
    }
}

func main() {
    db, err := sql.Open("postgres", "postgres://user:pass@localhost/bookstore")
    if err != nil {
        log.Fatal(err)
    }

    // Wrap the booksIndex handler with the injectDB middleware,
    // passing in the new context.Context with the connection pool.
    http.Handle("/books", injectDB(db, booksIndex))
    http.ListenAndServe(":3000", nil)
}

func booksIndex(w http.ResponseWriter, r *http.Request) {
    // Pass the request context onto the database layer.
    bks, err := models.AllBooks(r.Context())
    if err != nil {
        log.Println(err)
        http.Error(w, http.StatusText(500), 500)
        return
    }

    for _, bk := range bks {
        fmt.Fprintf(w, "%s, %s, %s, £%.2f\n", bk.Isbn, bk.Title, bk.Author, bk.Price)
    }
}                      
</pre></code>
</figure>

<p>Essentially, what's happening here is that the <code>injectDB</code> middleware replaces the request context for every request with <em>one that contains the connection pool</em>. Then, in our handlers, we pass the request context on to our database layer.</p>

<p>Then in the database layer we can retrieve the connection pool from the context and use it like this:</p>

<figure class="file">
    <figcaption>File: models/models.go</figcaption><code class="go">
        <pre>
package models

import (
    "context"
    "database/sql"
    "errors"
)

type Book struct {
    Isbn   string
    Title  string
    Author string
    Price  float32
}

func AllBooks(ctx context.Context) ([]Book, error) {
    // Retrieve the connection pool from the context. Because the
    // r.Context().Value() method always returns an interface{} type, we
    // need to type assert it into a *sql.DB before using it.
    db, ok := ctx.Value("db").(*sql.DB)
    if !ok {
        return nil, errors.New("could not get database connection pool from context")
    }

    rows, err := db.Query("SELECT * FROM books")
    if err != nil {
        return nil, err
    }
    defer rows.Close()

    var bks []Book

    for rows.Next() {
        var bk Book

        err := rows.Scan(&bk.Isbn, &bk.Title, &bk.Author, &bk.Price)
        if err != nil {
            return nil, err
        }

        bks = append(bks, bk)
    }
    if err = rows.Err(); err != nil {
        return nil, err
    }

    return bks, nil
}               
</pre></code>
</figure>

<p>If you go ahead and run this code it'll work just fine. But this pattern has some big downsides:</p>

<ul>
    <li>Each time we retrieve the connection pool from the context we need to type assert it and check for any errors. This makes our code more verbose, and we lose the compile-time type safety that we have with the other approaches.</li>
    <li>Unlike the dependency injection patterns, it's not clear to see what dependencies a function has <em>just by looking at its signature</em>. Instead, you have to read through the code to see what it is retrieving from the request context. In a small application this isn't a problem &mdash; but if you're trying to get to grips with a large, unfamiliar, codebase then it's not ideal.</li>
    <li>It's not idiomatic Go. Using the request context in this way goes against the advice in the official documentation, and that means the pattern might be surprising or unfamiliar to other Go developers.</li>
</ul>

<p><em>So, is there ever a scenario where this pattern is a good fit?</em> It's tempting to be glib here and say "no", but the truth is that it <em>can</em> be an easy-ish way to pass around the connection pool if you have a sprawling codebase with handlers and database logic spread across many different packages.</p>

<p>But if you're considering using it for that reason, then it's probably a sign that you should refactor your codebase to have a simpler, flatter, package structure. Or, alternatively, I would suggest taking a closer look at the <a href="#closure">closure pattern</a> we talked about earlier instead.</p>
    ]]></description>
  </item>
  <item>
    <pubDate>Sat, 13 Jun 2015 20:00:00 GMT</pubDate>
    <link>https://www.alexedwards.net/blog/practical-persistence-sql</link>
    <guid>https://www.alexedwards.net/blog/practical-persistence-sql</guid>
    <title>Practical Persistence in Go: SQL Databases</title>
    <description><![CDATA[
    <p>This is the first in a series of tutorials about persisting data in Go web applications.</p>

    <p>In this post we'll be looking at SQL databases. I'll explain the basics of the <code><a href="http://golang.org/pkg/database/sql/">database/sql</a></code> package, walk through building a working application, and explore a couple of options for cleanly structuring your code.</p>

    <p>Before we get started you'll need to <code>go get</code> one of the <a href="https://github.com/golang/go/wiki/SQLDrivers"> drivers for the database/sql package</a>.</p>

    <p>In this post I'll be using Postgres and the excellent <a href="https://github.com/lib/pq">pq</a> driver. But all the code in this tutorial is (nearly) exactly the same for any other driver or database &ndash; including MySQL and SQLite. I'll point out the very few Postgres-specific bits as we go.</p>

    <figure class="shell"><code><pre>    $ go get github.com/lib/pq
    </pre></code></figure>

    <h2>Basic usage</h2>

    <p>Let's build a simple Bookstore application, which carries out CRUD operations on a <code>books</code> table. </p>

    <p>If you'd like to follow along, you'll need to create a new <code>bookstore</code> database and scaffold it with the following:</p>

    <figure class="plain"><code class="sql"><pre>    CREATE TABLE books (
      isbn    char(14) NOT NULL,
      title   varchar(255) NOT NULL,
      author  varchar(255) NOT NULL,
      price   decimal(5,2) NOT NULL
    );

    INSERT INTO books (isbn, title, author, price) VALUES
    ('978-1503261969', 'Emma', 'Jayne Austen', 9.44),
    ('978-1505255607', 'The Time Machine', 'H. G. Wells', 5.99),
    ('978-1503379640', 'The Prince', 'Niccolò Machiavelli', 6.99);

    ALTER TABLE books ADD PRIMARY KEY (isbn);
    </pre></code></figure>

    <p>Once that's done, head over to your Go workspace and create a new <code>bookstore</code> package directory and a <code>main.go</code> file:</p>

    <figure class="shell"><code><pre>    $ cd $GOPATH/src
    $ mkdir bookstore &amp;&amp; cd bookstore
    $ touch main.go
    </pre></code></figure>

    <p>Let's start with some code that executes a <code>SELECT * FROM books</code> query and then prints the results to stdout.</p>

    <figure class="file"><figcaption>File: main.go</figcaption><code class="go"><pre>    package main

    import (
      _ "github.com/lib/pq"
      "database/sql"
      "fmt"
      "log"
    )

    type Book struct {
      isbn  string
      title  string
      author string
      price  float32
    }

    func main() {
      db, err := sql.Open("postgres", "postgres://user:pass@localhost/bookstore")
      if err != nil {
        log.Fatal(err)
      }

      rows, err := db.Query("SELECT * FROM books")
      if err != nil {
        log.Fatal(err)
      }
      defer rows.Close()

      bks := make([]*Book, 0)
      for rows.Next() {
        bk := new(Book)
        err := rows.Scan(&bk.isbn, &bk.title, &bk.author, &bk.price)
        if err != nil {
          log.Fatal(err)
        }
        bks = append(bks, bk)
      }
      if err = rows.Err(); err != nil {
        log.Fatal(err)
      }

      for _, bk := range bks {
        fmt.Printf("%s, %s, %s, £%.2f\n", bk.isbn, bk.title, bk.author, bk.price)
      }
    }
    </pre></code></figure>

    <p>There's a lot going on here. We'll step through this bit-by-bit.</p>

    <p>The first interesting thing is the way that we <strong>import the driver</strong>. We don't use anything in the <code>pq</code> package directly, which means that the Go compiler will raise an error if we try to import it normally. But we need the pq package's <code>init()</code> function to run so that our driver can <a href="http://golang.org/pkg/database/sql/#Register">register itself</a> with <code>database/sql</code>. We get around this by <a href="http://learntogoogleit.com/post/63748050636/aliasing-imports-in-golang">aliasing the package name</a> to the blank identifier. This means <code>pq.init()</code> still gets executed, but the alias is harmlessly discarded (and our code runs error-free). This approach is standard for most of Go's SQL drivers.</p>

    <p>Next we <strong>define a <code>Book</code> type</strong> &ndash; with the struct fields and their types aligning to our <code>books</code> table. For completeness I should point out that we've only been able to use the <code>string</code> and <code>float32</code> types safely because we set <code>NOT NULL</code> constraints on the columns in our table. If the table contained nullable fields we would need to use the <code>sql.NullString</code> and <code>sql.NullFloat64</code> types instead &ndash; see <a href="https://gist.github.com/alexedwards/dc3145c8e2e6d2fd6cd9">this Gist</a> for a working example. Generally it's easiest to avoid nullable fields altogether if you can, which is what we've done here.</p>

    <p>In the <code>main()</code> function we <strong>initialise a new <code>sql.DB</code> object</strong> by calling <code><a href="http://golang.org/pkg/database/sql/#Open">sql.Open()</a></code>. We pass in the name of our driver (in this case <code>&quot;postgres&quot;</code>) and the connection string (you'll need to check your driver documentation for the correct format). It's worth emphasising that the <code>sql.DB</code> object it returns is not a <em>database connection</em> &ndash; it's an abstraction representing a pool of underlying connections. You can change the maximum number of open and idle connections in the pool with the <code>db.SetMaxOpenConns()</code> and <code>db.SetMaxIdleConns()</code> methods respectively. A final thing to note is that <code>sql.DB</code> is safe for concurrent access, which is very convenient if you're using it in a web application (like we will shortly).</p>

    <p>From there we follow a standard pattern that you'll see often:</p>

    <ol>
    <li><p>We fetch a resultset from the <code>books</code> table using the <code><a href="http://golang.org/pkg/database/sql/#DB.Query">DB.Query()</a></code> method and assign it to a <code>rows</code> variable. Then we <code>defer rows.Close()</code> to ensure the resultset is properly closed before the parent function returns. <strong>Closing a resultset properly is really important</strong>. As long as a resultset is open it will keep the underlying database connection open &ndash; which in turn means the connection is not available to the pool. So if something goes wrong and the resultset isn't closed it can
     rapidly lead to all the connections in your pool being used up. Another gotcha (which caught me out when I first began) is that the defer statement should come <em>after</em> you check for an error from <code>DB.Query</code>. Otherwise, if <code>DB.Query()</code> returns an error, you'll get a panic trying to close a nil resultset.<p></li>

    <li><p>We then use <code>rows.Next()</code> to iterate through the rows in the resultset. This preps the first (and then each subsequent) row to be acted on by the <code>rows.Scan()</code> method. Note that if iteration over all of the rows completes then the resultset automatically closes itself and frees-up the  connection.</p></li>

    <li><p>We use the <code>rows.Scan()</code> method to copy the values from each field in the row to a new <code>Book</code> object that we created. We then check for any errors that occurred during Scan, and add the new <code>Book</code> to the <code>bks</code> slice we created earlier.</p></li>

    <li><p>When our <code>rows.Next()</code> loop has finished we call <code>rows.Err()</code>. This returns any error that was encountered during the interation. It's important to call this &ndash; don't just assume that we completed a successful iteration over the whole resultset.</p></li>
    </ol>

    <p>If our <code>bks</code> slice has been filled successfully, we loop through it and print the information about each book to stdout.</p>

    <p>If you run the code you should get the following output:</p>

    <figure class="shell"><code><pre>    $ go run main.go
    <samp>978-1503261969, Emma, Jayne Austen, £9.44
    978-1505255607, The Time Machine, H. G. Wells, £5.99
    978-1503379640, The Prince, Niccolò Machiavelli, £6.99</samp>
    </pre></code></figure>


    <h2>Using in a web application</h2>

    <p>Let's start to morph our code into a RESTful-ish web application with 3 routes:</p>

    <ul>
    <li><strong>GET  /books</strong> &ndash; List all books in the store</li>
    <li><strong>GET  /books/show</strong>   &ndash; Show a specific book by its ISBN</li>
    <li><strong>POST /books/create</strong> &ndash; Add a new book to the store</li>
    </ul>

    <p>We've just written all the core logic we need for the <code>GET /books</code> route. Let's adapt it into a <code>booksIndex()</code> HTTP handler for our web application.</p>

    <figure class="file"><figcaption>File: main.go</figcaption><code class="go"><pre>    package main

    import (
      _ "github.com/lib/pq"
      "database/sql"
      "fmt"
      "log"
      "net/http"
    )

    type Book struct {
      isbn   string
      title  string
      author string
      price  float32
    }

    var db *sql.DB

    func init() {
      var err error
      db, err = sql.Open("postgres", "postgres://user:pass@localhost/bookstore")
      if err != nil {
        log.Fatal(err)
      }

      if err = db.Ping(); err != nil {
        log.Fatal(err)
      }
    }

    func main() {
      http.HandleFunc("/books", booksIndex)
      http.ListenAndServe(":3000", nil)
    }

    func booksIndex(w http.ResponseWriter, r *http.Request) {
      if r.Method != "GET" {
        http.Error(w, http.StatusText(405), 405)
        return
      }

      rows, err := db.Query("SELECT * FROM books")
      if err != nil {
        http.Error(w, err.Error(), 500)
        return
      }
      defer rows.Close()

      bks := make([]*Book, 0)
      for rows.Next() {
        bk := new(Book)
        err := rows.Scan(&bk.isbn, &bk.title, &bk.author, &bk.price)
        if err != nil {
          http.Error(w, err.Error(), 500)
          return
        }
        bks = append(bks, bk)
      }
      if err = rows.Err(); err != nil {
        http.Error(w, err.Error(), 500)
        return
      }

      for _, bk := range bks {
        fmt.Fprintf(w, "%s, %s, %s, £%.2f\n", bk.isbn, bk.title, bk.author, bk.price)
      }
    }
    </pre></code></figure>

    <p>So how is this different?</p>

    <ul>
    <li><p>We use the <code>init()</code> function to set up our connection pool and assign it to the global variable <code>db</code>. We're using a global variable to store the connection pool because it's an easy way of making it available to our HTTP handlers &ndash; but it's by no means the only way. Because <code>sql.Open()</code> doesn't actually check a connection, we also call <code><a href="http://golang.org/pkg/database/sql/#DB.Ping">DB.Ping()</a></code> to make sure that everything works OK on startup.</p></li>

    <li><p>In the <code>booksIndex</code> hander we return a <code>405 Method Not Allowed</code> response for any non-GET request. Then we have our data access logic. This is exactly the same as the earlier example, except that we're now returning proper HTTP errors instead of exiting the program. Lastly we write the books' details as plain text to the <code>http.ResponseWriter</code>.</p></li>
    </ul>

    <p>Run the application and then make a request:</p>

    <figure class="shell"><code><pre>    $ curl -i localhost:3000/books
    <samp>HTTP/1.1 200 OK
    Content-Length: 205
    Content-Type: text/plain; charset=utf-8

    978-1503261969, Emma, Jayne Austen, £9.44
    978-1505255607, The Time Machine, H. G. Wells, £5.99
    978-1503379640, The Prince, Niccolò Machiavelli, £6.99</samp>
    </pre></code></figure>

    <h2>Querying a single row</h2>

    <p>For the <code>GET /books/show</code> route we want to retrieve single book based on its ISBN, with the ISBN being passed in the query string like:</p>

    <p><code>/books/show?isbn=978-1505255607</code></p>

    <p>We'll create a new <code>bookShow()</code> handler for this:</p>

    <figure class="file"><figcaption>File: main.go</figcaption><code class="go"><pre>    ...

    func main() {
      http.HandleFunc("/books", booksIndex)
      http.HandleFunc("/books/show", booksShow)
      http.ListenAndServe(":3000", nil)
    }
    ...

    func booksShow(w http.ResponseWriter, r *http.Request) {
      if r.Method != "GET" {
        http.Error(w, http.StatusText(405), 405)
        return
      }

      isbn := r.FormValue("isbn")
      if isbn == "" {
        http.Error(w, http.StatusText(400), 400)
        return
      }

      row := db.QueryRow("SELECT * FROM books WHERE isbn = $1", isbn)

      bk := new(Book)
      err := row.Scan(&bk.isbn, &bk.title, &bk.author, &bk.price)
      if err == sql.ErrNoRows {
        http.NotFound(w, r)
        return
      } else if err != nil {
        http.Error(w, err.Error(), 500)
        return
      }

      fmt.Fprintf(w, "%s, %s, %s, £%.2f\n", bk.isbn, bk.title, bk.author, bk.price)
    }
    </pre></code></figure>

    <p>Once again the handler starts again by checking that it's dealing with a GET request.</p>

    <p>We then use the <code>Request.FormValue()</code> method to fetch the ISBN value from the request query string. This returns an empty string if there's no parameter found, so we check for that and issue a <code>400 Bad Request</code> response if it's missing.</p>

    <p>Now we get to the interesting bit: <code><a href="http://golang.org/pkg/database/sql/#DB.QueryRow">DB.QueryRow()</a></code>. This method is similar to <code>DB.Query</code>, except that it fetches a single row instead of multiple rows.<p>

    <p>Because we need to include untrusted input (the <code>isbn</code> variable) in our query we take advantage of <strong>placeholder parameters</strong>, passing in the value of our placeholder as the second argument to <code>DB.QueryRow()</code> like so:</p>

    <p><code>db.QueryRow("SELECT * FROM books WHERE isbn = $1", isbn)</code></p>

    <p>Behind the scenes, <code>db.QueryRow</code> (and also <code>db.Query()</code> and <code>db.Exec()</code>) work by creating a new prepared statement on the database, and subsequently execute that prepared statement using the placeholder parameters provided. This means that all three methods are safe from SQL injection when used correctly . From Wikipedia:</p>

    <blockquote>
      Prepared statements are resilient against SQL injection, because parameter values, which are transmitted later using a different protocol, need not be correctly escaped. If the original statement template is not derived from external input, injection cannot occur.
    </blockquote>

    <p>The placeholder parameter syntax differs depending on your database. Postgres uses the <code>$N</code> notation, but MySQL, SQL Server and others use the <code>?</code> character as a placeholder.</p>

    <p>OK, let's get back to our code.</p>

    <p>After we've got a row from <code>DB.QueryRow()</code> we use <code>row.Scan()</code> to copy the values into a new <code>Book</code> object. Note how any errors from <code>DB.QueryRow()</code> are deferred and not surfaced until we call <code>row.Scan()</code>.</p>

    <p>If our query returned no rows, our call to <code>row.Scan()</code> will return an error of the type <code>sql.ErrNoRows</code>. We check for that error type specifically and return a <code>404 Not Found</code> response if that's the case. We then handle all other errors by returning a <code>500 Internal Server Error</code>.</p>

    <p>If everything went OK, we write the book details to the <code>http.ResponseWriter</code>.</p>

    <p>Give it a try:</p>

    <figure class="shell"><code><pre>    $ curl -i localhost:3000/books/show?isbn=978-1505255607
    <samp>HTTP/1.1 200 OK
    Content-Length: 54
    Content-Type: text/plain; charset=utf-8

    978-1505255607, The Time Machine, H. G. Wells, £5.99</samp>
    </pre></code></figure>

    <p>If you play around with the ISBN value, or issue a malformed request you should see that you get the appropriate error responses.</p>

    <h2>Executing a statement</h2>

    <p>For our final <code>POST /books/create</code> route we'll make a new <code>booksCreate()</code> handler and use <code><a href="http://golang.org/pkg/database/sql/#DB.Exec">DB.Exec()</a></code> to execute a <code>INSERT</code> statement. You can take the same approach for an <code>UPDATE</code>, <code>DELETE</code>, or any other action that doesn't return rows.</p>

    <p>Here's the code:</p>

    <figure class="file"><figcaption>File: main.go</figcaption><code class="go"><pre>    ...

    import (
      _ "github.com/lib/pq"
      "database/sql"
      "fmt"
      "log"
      "net/http"
      "strconv"
    )
    ...

    func main() {
      http.HandleFunc("/books", booksIndex)
      http.HandleFunc("/books/show", booksShow)
      http.HandleFunc("/books/create", booksCreate)
      http.ListenAndServe(":3000", nil)
    }
    ...

    func booksCreate(w http.ResponseWriter, r *http.Request) {
      if r.Method != "POST" {
        http.Error(w, http.StatusText(405), 405)
        return
      }

      isbn := r.FormValue("isbn")
      title := r.FormValue("title")
      author := r.FormValue("author")
      if isbn == "" || title == "" || author == "" {
        http.Error(w, http.StatusText(400), 400)
        return
      }
      price, err := strconv.ParseFloat(r.FormValue("price"), 32)
      if err != nil {
        http.Error(w, http.StatusText(400), 400)
        return
      }

      result, err := db.Exec("INSERT INTO books VALUES($1, $2, $3, $4)", isbn, title, author, price)
      if err != nil {
        http.Error(w, err.Error(), 500)
        return
      }

      rowsAffected, err := result.RowsAffected()
      if err != nil {
        http.Error(w, err.Error(), 500)
        return
      }

      fmt.Fprintf(w, "Book %s created successfully (%d row affected)\n", isbn, rowsAffected)
    }
    </pre></code></figure>

    <p>Hopefully this is starting to feel familiar now.</p>

    <p>In the <code>booksCreate()</code> handler we check we're dealing with a POST request, and then fetch the request parameters using <code>request.FormValue()</code>. We verify that all the necessary parameters exist, and in the case of <code>price</code> use the <code>strconv.ParseFloat()</code> to convert the parameter from a string into a float.</p>

    <p>We then carry out the insert using <code>db.Exec()</code>, passing our new book details as parameters just like we did in the previous example. Note that <code>DB.Exec()</code>, like <code>DB.Query()</code> and <code>DB.QueryRow()</code>, is a variadic function, which means you can pass in as many parameters as you need.</p>

    <p>The <code>db.Exec()</code> method returns an object satisfying the <code><a href="http://golang.org/pkg/database/sql/#Result">sql.Result</a></code> interface, which you can either use (like we are here) or discard with the blank identifier.</p>

    <p>The <code>sql.Result()</code> interface guarantees two methods: <code>LastInsertId()</code> &ndash; which is often used to return the value of an new auto increment id, and <code>RowsAffected()</code> &ndash; which contains the number of rows that the statement affected. In this code we're picking up the latter, and then using it in our plain text confirmation message.</p>

    <p>It's worth noting that not all drivers support the <code>LastInsertId()</code> and <code>RowsAffected()</code> methods, and calling them may return an error. For example, pq doesn't support <code>LastInsertId()</code> &ndash; if you need that functionality you'll have to take an approach <a href="https://github.com/lib/pq/issues/24">like this one</a>.</p>

    <p>Let's try out the <code>/books/create</code> route, passing our parameters in the POST body:</p>

    <figure class="shell"><code><pre>    $ curl -i -X POST -d "isbn=978-1470184841&title=Metamorphosis&author=Franz Kafka&price=5.90" localhost:3000/books/create
    <samp>HTTP/1.1 200 OK
    Content-Length: 58
    Content-Type: text/plain; charset=utf-8

    Book 978-1470184841 created successfully (1 row affected)</samp>
    </pre></code></figure>

    <h2>Using DB.Prepare()</h2>
    <p>Something you might be wondering is: <em>Why aren't we using DB.Prepare()?</em></p>

    <p>As I explained a bit earlier, we kinda are behind the scenes. All of <code>DB.Query()</code>, <code>DB.Exec()</code> and <code>DB.QueryRow()</code> set up a prepared statement on the database, run it with the parameters provided, and then close (or <em>deallocate</em>) the prepared statement.</p>

    <p>But the downside of this is obvious: we have 3 round trips to the database with each HTTP request, whereas if we set up prepared statements with <code>DB.Prepare()</code> &ndash; possibly in the <code>init()</code> function &ndash; we could have only one round trip each time.</p>

    <p>But the trade-off isn't that simple. Prepared statements only last for the duration of the current database session. If the session ends, then the prepared statements must be recreated before being used again. So if there's database downtime or a restart you'll need to recreate the prepared statements.</p>

    <p>For a web application where latency is critical it might be worth the effort to setup monitoring for your database, and reinitialise the prepared statements after an outage. But for an application like this where latency isn't <em>that</em> important, using <code>DB.Query()</code> <em>et al</em> is clear and effective enough.</p>

    <p>There's a <a href="https://groups.google.com/forum/#!topic/golang-nuts/ISh22XXze-s">Google groups thread</a> which discusses this in more detail.</p>

    <h2>Refactoring</h2>

    <p>At the moment all our database access logic is mixed in with our HTTP handlers. It's probably a good idea to refactor this for easier maintainability and DRYness as our application grows.</p>

    <p>But this tutorial is already pretty long, so I'll explore some of the options for refactoring our code in the next post &ndash; Practical Persistence in Go: Organising Database Access (<em>coming soon!</em>)</p>

    <h2>Additional tools</h2>

    <p>The <a href="https://github.com/jmoiron/sqlx">Sqlx</a> package by Jason Moiron provides some additions to the standard <code>database/sql</code> functionality, including support for named placeholder parameters and automatic marshalling of rows into structs.</p>

    <p>If you're looking for something more ORM-ish, you might like to consider <a href="https://github.com/jmoiron/modl">Modl</a> by the same author, or <a href="https://github.com/go-gorp/gorp">gorp</a> by James Cooper.</p>

    <p>The <a href="https://github.com/guregu/null">null</a> package by can help make managing nullable values easier, if that's something you need to do a lot of.</p>

    <p>Lastly, I found the tutorials at <a href="http://go-database-sql.org">go-database-sql.org</a> to be clear and helpful. Especially worth reading is the surprises and limitations section.</p>

    <p>If you found this post useful, you might like to subscribe to my <a href="https://www.alexedwards.net/static/feed.rss">RSS feed</a>.</p>
    ]]></description>
  </item>
  <item>
    <pubDate>Wed, 03 Dec 2014 22:00:00 GMT</pubDate>
    <link>https://www.alexedwards.net/blog/handler-chains-using-stack</link>
    <guid>https://www.alexedwards.net/blog/handler-chains-using-stack</guid>
    <title>Context-Aware Handler Chains in Go (using Stack)</title>
    <description><![CDATA[
    <p>I've written a package for chaining context-aware handlers in Go, called <a href="https://github.com/alexedwards/stack">Stack</a>. It was heavily inspired by <a href="https://github.com/justinas/alice">Alice</a>.</p>

    <h2>What do you mean by 'context-aware'?</h2>

    <p>If you're using a <a href="/blog/making-and-using-middleware">middleware pattern</a> to process HTTP requests in Go, you may want to share some data or <em>context</em> between middleware handlers and your application handlers. For example you might want to:</p>

    <ul>
    <li>Use some middleware to create a CRSF token, and later render the token to a template in your application handler. Or perhaps...</li>
    <li><em>Authenticate</em> a user in one middleware handler, and then pass the user details to a second middleware handler which checks if the user is <em>authorised</em> to access the resource.</li>
    </ul>

    <p>There are a few packages that can help with this. Matt Silverlock has written a good article about some of the different approaches and tools &ndash; I won't rehash it here, instead I recommend <a href="http://elithrar.github.io/article/map-string-interface/">giving it a read</a>.</p>

    <h2>Why make another package?</h2>

    <p>Because none of the existing tools seemed ideal &ndash; at least to me. <a href="http://www.gorillatoolkit.org/pkg/context">Gorilla Context</a> is simple and very flexible, but relies on a global context map and you remembering to clear the context after each request. (It's still my favourite though). <a href="https://goji.io/">Goji</a> provides request-scoped context, which is good, but it's part of a larger package and ties you into using the Goji router. The same is true of <a href="https://github.com/gocraft/web">Gocraft/web</a>, which also relies on reflection tricks under the hood that I struggle to wrap my head around.</p>

    <p>I realised that the only time you need to worry about context is when you're chaining handlers together. So I looked at my favorite tool for chaining handlers, Alice, and began adapting that to create Stack.</p>

    <p>I wanted the package to:</p>

    <ul>
      <li>Do a simple job, and then get out of the way.</li>
      <li>Provide a <strong>request-scoped context</strong> map.</li>
      <li>Let you create <strong>stackable, reusable, handler chains</strong> in the Alice style.</li>
      <li>Be as <strong>type-safe</strong> at compile time as it possibly could be.</li>
      <li>Be <strong>simple to understand and non-magic</strong>.</li>
      <li>Operate nicely with existing standards. In particular:</li>
        <ul>
          <li>The handler chain must <strong>satisfy the <code>http.Handler</code> interface</strong>, so it can be used with the <code>http.DefaultServeMux</code>.</li>
          <li>It should be <strong>compatible with the <code>func(http.Handler) http.Handler</code> pattern</strong> commonly used by third-party middleware packages.</li>
        </ul>
    </ul>

    <p>The <a href="https://github.com/alexedwards/stack/blob/master/README.md">full documentation for Stack is here</a>, but here's a quick example of how to use it:</p>

    <figure class="file"><figcaption>File: main.go</figcaption><code><pre>    package main

    import (
        "fmt"
        "github.com/alexedwards/stack"
        "github.com/goji/httpauth"
        "net/http"
    )

    func main() {
        // Setup goji/httpauth, some third-party middleware
        authenticate := stack.Middleware(httpauth.SimpleBasicAuth("user", "pass"))

        // Create a handler chain and register it with the DefaultServeMux
        http.Handle("/", stack.New(authenticate, tokenMiddleware).Then(tokenHandler))
        http.ListenAndServe(":3000", nil)
    }

    func tokenMiddleware(ctx stack.Context, next http.Handler) http.Handler {
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
            // Add a value to Context with the key 'token'
            ctx["token"] = "c9e452805dee5044ba520198628abcaa"
            next.ServeHTTP(w, r)
        })
    }

    func tokenHandler(ctx stack.Context) http.Handler {
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
            // Retrieve the token from Context and print it
            fmt.Fprintf(w, "Token is: %s", ctx["token"])
        })
    }
    </pre></code></figure>

    <figure class="shell"><code><pre>    $ curl -i user:pass@localhost:3000
    <samp>HTTP/1.1 200 OK
    Content-Length: 41
    Content-Type: text/plain; charset=utf-8

    Token is: c9e452805dee5044ba520198628abcaa</samp>
    $ curl -i user:wrongpass@localhost:3000
    <samp>HTTP/1.1 401 Unauthorized
    Content-Length: 13
    Content-Type: text/plain; charset=utf-8
    Www-Authenticate: Basic realm="Restricted"

    Unauthorized</samp>
    </pre></code></figure>

    <p>If you found this post useful, you might like to subscribe to my <a href="https://www.alexedwards.net/static/feed.rss">RSS feed</a>.</p>
    ]]></description>
  </item>
  <item>
    <pubDate>Tue, 21 Oct 2014 20:00:00 GMT</pubDate>
    <link>https://www.alexedwards.net/blog/making-and-using-middleware</link>
    <guid>https://www.alexedwards.net/blog/making-and-using-middleware</guid>
    <title>Making and Using HTTP Middleware</title>
    <description><![CDATA[
<p>When you're building a web application there's probably some shared functionality that you want to run for many (or even all) HTTP requests. You might want to log every request, gzip every response, or check a cache before doing some expensive processing.</p>

<p>One way of organising this shared functionality is to set it up as <em>middleware</em> &ndash; self-contained code which independently acts on a request before or after your normal application handlers. In Go a common place to use middleware is between a router (such as <code><a href="http://golang.org/pkg/net/http/#ServeMux">http.ServeMux</a></code>) and your application handlers, so that the flow of control for a HTTP request looks like:</p>


<figure class="plain"><code><pre>
Router => Middleware Handler => Application Handler
</pre></code></figure>

<p>In this post I'm going to explain how to make custom middleware that works in this pattern, as well as running through some concrete examples of using third-party middleware packages.</p>

<h2>The Basic Principles</h2>

<p>Making and using middleware in Go is fundamentally simple. We want to:<p>

<ul>
  <li>Implement our middleware so that it satisfies the <a href="http://golang.org/pkg/net/http/#Handler"><code>http.Handler</code></a> interface.</li>
  <li>Build up a <em>chain of handlers</em> containing both our middleware handler and our normal application handler, which we can register with a router.</li>
</ul>

<p>I'll explain how.</p>

<p>Hopefully you're already familiar with the following method for constructing a handler:</p>

<figure class="plain"><code class="go"><pre>
func messageHandler(message string) http.Handler {
  return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
    w.Write([]byte(message)
  })
}
</pre></code></figure>

<p>In the handler above we're placing our logic (a simple <code>w.Write()</code>) in an anonymous function and closing-over the <code>message</code> variable to form a closure. We're then converting this closure to a handler by using the <a href="http://golang.org/pkg/net/http/#HandlerFunc"><code>http.HandlerFunc()</code></a> adapter and returning it.</p>

<aside class="note">
  <strong>Note:</strong> If this pattern is confusing or unfamiliar to you, it's probably best to read <a href="https://www.alexedwards.net/blog/a-recap-of-request-handling">this primer</a> before continuing.
</aside>
    

<p>We can use this same approach to create a chain of handlers. Instead of passing a string into the closure (like above) we could pass <em>the next handler in the chain</em> as a variable, and then transfer control to this next handler by calling it's <code>ServeHTTP()</code> method.</p>

<p>This gives us a complete pattern for constructing middleware:</p>

<figure class="plain"><code class="go"><pre>
func exampleMiddleware(next http.Handler) http.Handler {
  return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
    // Our middleware logic goes here...
    next.ServeHTTP(w, r)
  })
}
</pre></code></figure>

<p>You'll notice that this middleware function has a <code>func(http.Handler) http.Handler</code> signature. It accepts a handler as a parameter and returns a handler. This is useful for two reasons:</p>

<ul>
  <li>Because it returns a handler we can register the middleware function directly with the standard <code>http.ServeMux</code> router in Go's <code>net/http</code> package.</li>
  <li>We can create an arbitrarily long handler chain by nesting middleware functions inside each other.</li>
</ul>

<p>For example:</p>

<figure class="plain"><code><pre>
mux := http.NewServeMux()
mux.Handle("/", middlewareOne(middlewareTwo(finalHandler)))
</pre></code></figure>

<h2>Illustrating the Flow of Control</h2>

<p>Let's look at a stripped-down example with some middleware that writes log messages to the standard output stream in your terminal:</p>

<figure class="file"><figcaption>File: main.go</figcaption><code><pre>
package main

import (
  "log"
  "net/http"
)

func middlewareOne(next http.Handler) http.Handler {
  return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
    log.Println("Executing middlewareOne")
    next.ServeHTTP(w, r)
    log.Println("Executing middlewareOne again")
  })
}

func middlewareTwo(next http.Handler) http.Handler {
  return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
    log.Println("Executing middlewareTwo")
    if r.URL.Path == "/foo" {
      return
    }

    next.ServeHTTP(w, r)
    log.Println("Executing middlewareTwo again")
  })
}

func final(w http.ResponseWriter, r *http.Request) {
  log.Println("Executing finalHandler")
  w.Write([]byte("OK"))
}

func main() {
  mux := http.NewServeMux()

  finalHandler := http.HandlerFunc(final)
  mux.Handle("/", middlewareOne(middlewareTwo(finalHandler)))

  log.Println("Listening on :3000...")
  err := http.ListenAndServe(":3000", mux)
  log.Fatal(err)
}  
</pre></code></figure>

<p>Run this application and make a request to <a href="http://localhost:3000/">http://localhost:3000</a>. You should see some log output similar to this:</p>

<figure class="shell"><code><pre>
$ go run main.go
<samp>2020/05/08 12:31:42 Listening on :3000...
2020/05/08 12:32:05 Executing middlewareOne
2020/05/08 12:32:05 Executing middlewareTwo
2020/05/08 12:32:05 Executing finalHandler
2020/05/08 12:32:05 Executing middlewareTwo again
2020/05/08 12:32:05 Executing middlewareOne again</samp>
</pre></code></figure>

<p>It's clear to see how control is being passed through the handler chain in the order we nested them, and then back up again in the <em>reverse direction</em>.</p>

<p>We can stop control propagating through the chain at any point by issuing a <code>return</code> from a middleware handler.</p>

<p>In the example above I've included a conditional return in the <code>middlewareTwo</code> function. Try it by visiting <a href="http://localhost:3000/foo">http://localhost:3000/foo</a> and checking the log again &ndash; you'll see that this time the request gets no further than <code>middlewareTwo</code> before passing back up the chain.</p>

<figure class="shell"><code><pre>
<samp>2020/05/08 12:33:22 Executing middlewareOne
2020/05/08 12:33:22 Executing middlewareTwo
2020/05/08 12:33:22 Executing middlewareOne again</samp>
</pre></code></figure>

<h2>Understood. How About a Proper Example?</h2>

<p>OK, let's say that we're building a service which processes requests containing a JSON body.</p>
<p>We want to create some middleware which a) checks for the existence of a <code>Content-Type</code> header and b) if the header exists, check that it has the mime type <code>application/json</code>. If either of those checks fail, we want our middleware to write an error message and to stop the request from reaching our application handlers.</p>

<figure class="file"><figcaption>File: main.go</figcaption><code class="go"><pre>
package main

import (
  "log"
  "mime"
  "net/http"
)

func enforceJSONHandler(next http.Handler) http.Handler {
  return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
    contentType := r.Header.Get("Content-Type")

    if contentType != "" {
      mt, _, err := mime.ParseMediaType(contentType)
      if err != nil {
        http.Error(w, "Malformed Content-Type header", http.StatusBadRequest)
        return
      }

      if mt != "application/json" {
        http.Error(w, "Content-Type header must be application/json", http.StatusUnsupportedMediaType)
        return
      }
    }

    next.ServeHTTP(w, r)
  })
}

func final(w http.ResponseWriter, r *http.Request) {
  w.Write([]byte("OK"))
}

func main() {
  mux := http.NewServeMux()

  finalHandler := http.HandlerFunc(final)
  mux.Handle("/", enforceJSONHandler(finalHandler))

  log.Println("Listening on :3000...")
  err := http.ListenAndServe(":3000", mux)
  log.Fatal(err)
}  
</pre></code></figure>

<aside class="note">
  <strong>Note:</strong> In the code above we're using the <a href="https://golang.org/pkg/mime/#ParseMediaType"><code>mime.ParseMediaType()</code></a> function to extract the mime type from the header (which may include optional parameters, such as <code>charset</code> or <code>boundary</code>). 
</aside>

<p>This looks good. Let's test it by making some requests using cURL:</p>

<figure class="shell"><code><pre>
$ curl -i localhost:3000
<samp>HTTP/1.1 400 Bad Request
Content-Type: text/plain; charset=utf-8
X-Content-Type-Options: nosniff
Date: Fri, 08 May 2020 10:42:36 GMT
Content-Length: 37

Content-Type header must be provided</samp>

$ curl -i -H "Content-Type: application/xml" localhost:3000
<samp>HTTP/1.1 415 Unsupported Media Type
Content-Type: text/plain; charset=utf-8
X-Content-Type-Options: nosniff
Date: Fri, 08 May 2020 10:42:39 GMT
Content-Length: 45

Content-Type header must be application/json</samp>

$ curl -i -H "Content-Type: application/json; charset=UTF-8" localhost:3000
<samp>HTTP/1.1 200 OK
Date: Fri, 08 May 2020 10:42:43 GMT
Content-Length: 2
Content-Type: text/plain; charset=utf-8

OK</samp>
</pre></code></figure>

<h2>Using Third-Party Middleware</h2>

<p>Rather than rolling your own middleware all the time you might decide to save time and effort and use an existing third-party package. Let's take a look at a couple of examples to help demonstrate some common patterns that you might come across.</p>

<p>The first third-party middleware we'll demonstrate is <a href="http://elithrar.github.io/article/httpauth-basic-auth-for-go/">goji/httpauth</a>, which provides HTTP Basic Authentication functionality.<p>

<p>When using this package you call a <em>helper function</em> in order to setup the chainable middleware. Specifically, you call the <a href="https://godoc.org/github.com/goji/httpauth#SimpleBasicAuth"><code>httpauth.SimpleBasicAuth()</code></a> function, and this returns a middleware function with the signature <code>func(http.Handler) http.Handler</code> &mdash; which you can then use in exactly the same way as any custom-built middleware.</p>

<figure class="file"><figcaption>File: main.go</figcaption><code class="go"><pre>
package main

import (
  "log"
  "net/http"

  "github.com/goji/httpauth"
)

func main() {
  authHandler := httpauth.SimpleBasicAuth("alice", "pa$$word")

  mux := http.NewServeMux()

  finalHandler := http.HandlerFunc(final)
  mux.Handle("/", authHandler(finalHandler))

  log.Println("Listening on :3000...")
  err := http.ListenAndServe(":3000", mux)
  log.Fatal(err)
}

func final(w http.ResponseWriter, r *http.Request) {
  w.Write([]byte("OK"))
}  
</pre></code></figure>

<p>If you run this code then visit <a href="http://localhost:3000/">http://localhost:3000</a> in your browser you should get a username and password prompt like so:</p>

<p><img src="/static/images/middleware-1.png"></p>

<p>Entering the wrong username and password should result in the prompt being redisplayed, clicking 'Cancel' should result in a plain-text <code>"Unauthorized"</code> response, and  using the correct username (<code>alice</code>) and password (<code>pa$$word</code>) should result in an <code>"OK"</code> response.</p>

<p>That was pretty straightforward and easy to integrate. Let's now look at a different example using the <a href="https://pkg.go.dev/github.com/gorilla/handlers?tab=doc#LoggingHandler"><code>LoggingHandler</code></a> middleware from the <a href="https://github.com/gorilla/handlers">gorilla/handlers</a> package, which records request logs using the <a href="http://httpd.apache.org/docs/1.3/logs.html#common">Apache Common Log Format</a>.</p>

<p>Instead of using the standard middleware signature that we've seen so far throughout this post, this middleware has the signature <code style="white-space: normal;">func(out io.Writer, h http.Handler) http.Handler</code>, so it takes not only the next handler but also the <a href="http://golang.org/pkg/io/#Writer"><code>io.Writer</code></a> that the log will be written to.</p>

<p>Here's a simple example of using it in which we write logs to a <code>server.log</code> file in the current directory:</p>

<figure class="file"><figcaption>File: main.go</figcaption><code class="go"><pre>
package main

import (
  "log"
  "net/http"
  "os"

  "github.com/gorilla/handlers"
)

func main() {
  logFile, err := os.OpenFile("server.log", os.O_WRONLY|os.O_CREATE|os.O_APPEND, 0664)
  if err != nil {
    log.Fatal(err)
  }

  mux := http.NewServeMux()

  finalHandler := http.HandlerFunc(final)
  mux.Handle("/", handlers.LoggingHandler(logFile, finalHandler))

  log.Println("Listening on :3000...")
  err = http.ListenAndServe(":3000", mux)
  log.Fatal(err)
}

func final(w http.ResponseWriter, r *http.Request) {
  w.Write([]byte("OK"))
}
</pre></code></figure>

<p>In a trivial case like this our code is fairly clear. But what happens if we want to use this as part of a larger middleware chain? We could easily end up with a declaration looking something like this...</p>

<figure class="plain"><code><pre>
http.Handle("/", handlers.LoggingHandler(logFile, authHandler(enforceJSONHandler(finalHandler))))
</pre></code></figure>

<p>... And that's pretty confusing!</p>

<p>To help tidy this up it's possible to create a <em>constructor function</em> which wraps the <code>LoggingHandler()</code> middleware and returns a standard <code>func(http.Handler) http.Handler</code> function that we can nest neatly with other middleware. Like so:</p>

<figure class="plain"><code class="go"><pre>
package main

import (
  "io"
  "log"
  "net/http"
  "os"

  "github.com/gorilla/handlers"
)

func newLoggingHandler(dst io.Writer) func(http.Handler) http.Handler {
  return func(h http.Handler) http.Handler {
    return handlers.LoggingHandler(dst, h)
  }
}

func main() {
  logFile, err := os.OpenFile("server.log", os.O_WRONLY|os.O_CREATE|os.O_APPEND, 0664)
  if err != nil {
    log.Fatal(err)
  }

  loggingHandler := newLoggingHandler(logFile)

  mux := http.NewServeMux()

  finalHandler := http.HandlerFunc(final)
  mux.Handle("/", loggingHandler(finalHandler))

  log.Println("Listening on :3000...")
  err = http.ListenAndServe(":3000", mux)
  log.Fatal(err)
}

func final(w http.ResponseWriter, r *http.Request) {
  w.Write([]byte("OK"))
}
</pre></code></figure>

<p>If you run this application and make a few requests, your <code>server.log</code> file should look something like this:</p>

<figure class="shell"><code><pre>
$ cat server.log
<samp>127.0.0.1 - - [10/May/2020:15:11:30 +0200] "GET / HTTP/1.1" 200 2
127.0.0.1 - - [10/May/2020:15:11:31 +0200] "POST / HTTP/1.1" 200 2
127.0.0.1 - - [10/May/2020:15:11:33 +0200] "PUT / HTTP/1.1" 200 2</samp>
</pre></code></figure>

<p>If you're interested, here's a gist of the <a href="https://gist.github.com/alexedwards/6f9496caecb2996ac61d">three middleware handlers</a> from this post combined in one example</a>.</p>

<h2>Additional Tools</h2>

<p><a href="https://github.com/justinas/alice">Alice by Justinas Stankevičius</a> is a clever and very lightweight package which provides some syntactic sugar for chaining middleware handlers. At it's most basic Alice lets you rewrite this:</p>

<figure class="plain"><code><pre>
mux.Handle("/", loggingHandler(authHandler(enforceJSONHandler(finalHandler))))
</pre></code></figure>

<p>As this:</p>

<figure class="plain"><code><pre>
mux.Handle("/", alice.New(loggingHandler, authHandler, enforceJSONHandler).Then(finalHandler))
</pre></code></figure>

<p>To my eyes at least, that code is slightly clearer to understand at a glance. However, the real benefit of Alice is that it lets you to specify a handler chain once and reuse it for multiple routes. Like so:</p>

<figure class="plain"><code class="go"><pre>
stdChain := alice.New(loggingHandler, authHandler, enforceJSONHandler)

mux.Handle("/foo", stdChain.Then(fooHandler))
mux.Handle("/bar", stdChain.Then(barHandler))
</pre></code></figure>
    ]]></description>
  </item>
  <item>
    <pubDate>Tue, 19 Nov 2013 18:00:00 GMT</pubDate>
    <link>https://www.alexedwards.net/blog/simple-flash-messages-in-golang</link>
    <guid>https://www.alexedwards.net/blog/simple-flash-messages-in-golang</guid>
    <title>Simple Flash Messages in Go</title>
    <description><![CDATA[
    <p>Often in web applications you need to temporarily store data in-between requests, such as an error or success message during the Post-Redirect-Get process for a form submission. Frameworks such as Rails and Django have the concept of transient single-use <em>flash messages</em> to help with this.</p>

    <p>In this post I'm going to look at a way to create your own cookie-based flash messages in Go.</p>

    <p>We'll start by creating a directory for the project, along with a <code>flash.go</code> file for our code and a <code>main.go</code> file for an example application.</p>

    <figure class="shell"><code><pre>    $ mkdir flash-example
    $ cd flash-example
    $ touch flash.go main.go
    </pre></code></figure>

    <p>In order to keep our request handlers nice and clean, we'll create our primary <code>SetFlash()</code> and <code>GetFlash()</code> helper functions in the <code>flash.go</code> file.</p>

    <figure class="file"><figcaption>File: flash.go</figcaption><code><pre>    package main

    import (
      "encoding/base64"
      "net/http"
      "time"
    )

    func SetFlash(w http.ResponseWriter, name string, value []byte) {
      c := &http.Cookie{Name: name, Value: encode(value)}
      http.SetCookie(w, c)
    }

    func GetFlash(w http.ResponseWriter, r *http.Request, name string) ([]byte, error) {
      c, err := r.Cookie(name)
      if err != nil {
        switch err {
        case http.ErrNoCookie:
          return nil, nil
        default:
          return nil, err
        }
      }
      value, err := decode(c.Value)
      if err != nil {
        return nil, err
      }
      dc := &http.Cookie{Name: name, MaxAge: -1, Expires: time.Unix(1, 0)}
      http.SetCookie(w, dc)
      return value, nil
    }

    // -------------------------

    func encode(src []byte) string {
      return base64.URLEncoding.EncodeToString(src)
    }

    func decode(src string) ([]byte, error) {
      return base64.URLEncoding.DecodeString(src)
    }
    </pre></code></figure>

    <p>Our <code>SetFlash()</code> function is pretty succinct.</p>

    <p>It creates a new <a href="http://golang.org/pkg/net/http/#Cookie">Cookie</a>, containing the name of the flash message and the content. You'll notice that we're encoding the content &ndash; this is because <a href="http://tools.ietf.org/html/rfc6265#section-4.1.1">RFC 6265</a> is quite strict about the characters cookie values can contain, and encoding to base64 ensures our value satisfies the permitted character set. We then use the <a href="http://golang.org/pkg/net/http/#SetCookie">SetCookie</a> function to write the cookie to the response.</p>

    <p>In the <code>GetFlash()</code> helper we use the <a href="http://golang.org/pkg/net/http/#Request.Cookie">request.Cookie</a> method to load up the cookie containing the flash message &ndash; returning <code>nil</code> if it doesn't exist &ndash; and then decode the value from base64 back into a byte array.</p>

    <p>Because we want a flash message to only be available once, we need to instruct clients to not resend the cookie with future requests. We can do this by setting a new cookie with exactly the same name, with <code>MaxAge</code> set to a negative number and <code>Expiry</code> set to a historical time (to cater for old versions of IE). You should note that Go will only set an expiry time on a cookie if it is after the <a href="http://en.wikipedia.org/wiki/Unix_time#Encoding_time_as_a_number">Unix epoch</a>, so we've set ours for 1 second after that.</p>

    <p>Let's use these helper functions in a short example:</p>

    <figure class="file"><figcaption>File: main.go</figcaption><code><pre>    package main

    import (
      "fmt"
      "net/http"
    )

    func main() {
      http.HandleFunc("/set", set)
      http.HandleFunc("/get", get)
      fmt.Println("Listening...")
      http.ListenAndServe(":3000", nil)
    }

    func set(w http.ResponseWriter, r *http.Request) {
      fm := []byte("This is a flashed message!")
      SetFlash(w, "message", fm)
    }

    func get(w http.ResponseWriter, r *http.Request) {
      fm, err := GetFlash(w, r, "message")
      if err != nil {
        http.Error(w, err.Error(), http.StatusInternalServerError)
        return
      }
      if fm == nil {
        fmt.Fprint(w, "No flash messages")
        return
      }
      fmt.Fprintf(w, "%s", fm)
    }
    </pre></code></figure>

    <p>Run the application:</p>

    <figure class="shell"><code><pre>    $ go run main.go flash.go
    <samp>Listening...</samp>
    </pre></code></figure>

    <p>And make some requests against it using <a href="http://curl.haxx.se/">cURL</a>:</p>

    <figure class="shell"><code><pre>    $ curl -i --cookie-jar cj localhost:3000/set
    <samp>HTTP/1.1 200 OK
    Set-Cookie: message=VGhpcyBpcyBhIGZsYXNoZWQgbWVzc2FnZSE=
    Content-Type: text/plain; charset=utf-8
    Content-Length: 0</samp>

    $ curl -i --cookie-jar cj --cookie cj localhost:3000/get
    <samp>HTTP/1.1 200 OK
    Set-Cookie: message=; Expires=Thu, 01 Jan 1970 00:00:01 UTC; Max-Age=0
    Content-Type: text/plain; charset=utf-8
    Content-Length: 26

    This is a flashed message!</samp>

    $ curl -i --cookie-jar cj --cookie cj localhost:3000/get
    <samp>HTTP/1.1 200 OK
    Content-Type: text/plain; charset=utf-8
    Content-Length: 17

    No flash messages</samp>
    </pre></code></figure>

    <p>You can see our flash message being set, retrieved, and then not passed with subsequent requests as expected.</p>

    <h2>Additional Tools</h2>

    <p>If you don't want to roll your own helpers for flash messages, or need them to be 'signed' to prevent tampering, then the <a href="http://www.gorillatoolkit.org/pkg/sessions">Gorilla Sessions</a> package is a good option. Here's the previous example implemented with Gorilla instead:</p>

    <figure class="plain"><code><pre>    package main

    import (
      "fmt"
      "github.com/gorilla/sessions"
      "net/http"
    )

    func main() {
      http.HandleFunc("/set", set)
      http.HandleFunc("/get", get)
      fmt.Println("Listening...")
      http.ListenAndServe(":3000", nil)
    }

    var store = sessions.NewCookieStore([]byte("a-secret-string"))

    func set(w http.ResponseWriter, r *http.Request) {
      session, err := store.Get(r, "flash-session")
      if err != nil {
        http.Error(w, err.Error(), http.StatusInternalServerError)
      }
      session.AddFlash("This is a flashed message!", "message")
      session.Save(r, w)
    }

    func get(w http.ResponseWriter, r *http.Request) {
      session, err := store.Get(r, "flash-session")
      if err != nil {
        http.Error(w, err.Error(), http.StatusInternalServerError)
      }
      fm := session.Flashes("message")
      if fm == nil {
        fmt.Fprint(w, "No flash messages")
        return
      }
      session.Save(r, w)
      fmt.Fprintf(w, "%v", fm[0])
    }
    </pre></code></figure>

    <p>If you found this post useful, you might like to subscribe to my <a href="https://www.alexedwards.net/static/feed.rss">RSS feed</a>.</p>
    ]]></description>
  </item>
  <item>
    <pubDate>Fri, 01 Nov 2013 23:00:00 GMT</pubDate>
    <link>https://www.alexedwards.net/blog/form-validation-and-processing</link>
    <guid>https://www.alexedwards.net/blog/form-validation-and-processing</guid>
    <title>Form Validation and Processing in Go</title>
    <description><![CDATA[
<p>In this post I want to outline a sensible pattern that you can use for validating and processing HTML forms in Go web applications. Over the years I've tried out a number of different approaches, but this is the basic pattern that I always keep coming back to. It's clear and uncomplicated, but also flexible and extensible enough to work well in a wide variety of projects and scenarios.<p>
  
<p>To illustrate the pattern, I'll run through the start-to-finish build of a simple online contact form.</p>

<p>So let's begin by creating a new directory for the application, along with a <code>main.go</code> file for our code and a couple of vanilla HTML templates:</p>

<figure class="shell"><code><pre>
$ mkdir -p contact-form/templates
$ cd contact-form
$ touch main.go templates/home.html templates/confirmation.html
</pre></code></figure>

<figure class="file"><figcaption>File: templates/home.html</figcaption><code><pre>
&lt;h1&gt;Contact&lt;/h1&gt;
&lt;form action="/" method="POST" novalidate&gt;
  &lt;div&gt;
    &lt;p&gt;&lt;label&gt;Your email:&lt;/label&gt;&lt;/p&gt;
    &lt;p&gt;&lt;input type="email" name="email"&gt;&lt;/p&gt;
  &lt;/div&gt;
  &lt;div&gt;
    &lt;p&gt;&lt;label&gt;Your message:&lt;/label&gt;&lt;/p&gt;
    &lt;p&gt;&lt;textarea name="content"&gt;&lt;/textarea&gt;&lt;/p&gt;
  &lt;/div&gt;
  &lt;div&gt;
    &lt;input type="submit" value="Send message"&gt;
  &lt;/div&gt;
&lt;/form&gt;
</pre></code></figure>

<figure class="file"><figcaption>File: templates/confirmation.html</figcaption><code><pre>
&lt;h1&gt;Confirmation&lt;/h1&gt;
&lt;p&gt;Your message has been sent!&lt;/p&gt;
</pre></code></figure>

<p>If you're following along you'll also need to <a href="https://github.com/golang/go/wiki/Modules">enable modules</a> in the application root by running the <code>go mod init</code> command like so:</p>

<figure class="shell"><code><pre>
$ go mod init contact-form.example.com 
<samp>go: creating new go.mod: module contact-form.example.com</samp>
</pre></code></figure>

<p>Once that's done, your directory structure should look like this:</p>

<figure class="plain"><code><pre>
.
├── templates
│   ├── confirmation.html
│   └── home.html
├── go.mod
└── main.go
</pre></code></figure>

<h2>Displaying the Form</h2>

<p>Our application is going to provide three routes:</p>

<table>
  <tr>
    <th>Method</th>
    <th>URL Path</th>
    <th>Handler</th>
    <th>Description</th>
  </tr>
  <tr>
    <td>GET</td>
    <td>/</td>
    <td>home</td>
    <td>Display the contact form</td>
  </tr>
  <tr>
    <td>POST</td>
    <td>/</td>
    <td>send</td>
    <td>Submit the contact form</td>
  </tr>
  <tr>
    <td style="vertical-align: top;">GET</td>
    <td style="vertical-align: top;">/confirmation</td>
    <td style="vertical-align: top;">confirmation</td>
    <td style="vertical-align: top;">Display a confirmation message after successful submission</td>
  </tr>
</table>

<p></p>To handle the routing of requests we're going to use <a href="https://github.com/bmizerany/pat">pat</a> &ndash; a third-party router package which I've <a href="/blog/a-mux-showdown">talked about before</a>. But if you want to use an alternative router please feel free.</p>

<p>Let's go ahead and create a skeleton for the application:</p>

<figure class="file"><figcaption>File: main.go</figcaption><code><pre>
package main

import (
  "html/template"
  "log"
  "net/http"

  "github.com/bmizerany/pat"
)

func main() {
  mux := pat.New()
  mux.Get("/", http.HandlerFunc(home))
  mux.Post("/", http.HandlerFunc(send))
  mux.Get("/confirmation", http.HandlerFunc(confirmation))

  log.Println("Listening...")
  err := http.ListenAndServe(":3000", mux)
  if err != nil {
    log.Fatal(err)
  }
}

func home(w http.ResponseWriter, r *http.Request) {
  render(w, "templates/home.html", nil)
}

func send(w http.ResponseWriter, r *http.Request) {
  // Step 1: Validate form
  // Step 2: Send message in an email
  // Step 3: Redirect to confirmation page
}

func confirmation(w http.ResponseWriter, r *http.Request) {
  render(w, "templates/confirmation.html", nil)
}

func render(w http.ResponseWriter, filename string, data interface{}) {
  tmpl, err := template.ParseFiles(filename)
  if err != nil {
    log.Println(err)
    http.Error(w, "Sorry, something went wrong", http.StatusInternalServerError)
  }

  if err := tmpl.Execute(w, data); err != nil {
    log.Println(err)
    http.Error(w, "Sorry, something went wrong", http.StatusInternalServerError)
  }
}  
</pre></code></figure>

<p>This is fairly straightforward stuff so far. The only real point of note is that we've put the template handling into a <code>render</code> function to cut down on boilerplate code.</p>

<p>If you run the application:</p>

<figure class="shell"><code><pre>
$ go run .
<samp>2020/03/30 06:41:42 Listening...</samp>
</pre></code></figure>

<p>And then visit <a href="http://localhost:3000/">localhost:3000</a> in your browser you should see the contact form being displayed (although it doesn't do anything yet!).</p>

<p><img src="/static/images/contact-1.png"></p>

<h2>Validating the Form</h2>

<p>Now for the interesting part. Let's add some validation rules to this contact form, display the validation errors if there are any, and make sure that the form values get presented back if there's an error so the user doesn't need to retype them.</p>

<p>We <em>could</em> add the code for this inline in our <code>send</code> handler, but personally I find it cleaner and neater to break out the logic into a separate <code>message.go</code> file:</p>

<figure class="shell"><code><pre>
$ touch message.go
</pre></code></figure>

<figure class="file"><figcaption>File: message.go</figcaption><code><pre>
package main

import (
  "regexp"
  "strings"
)

var rxEmail = regexp.MustCompile(".+@.+\\..+")

type Message struct {
  Email   string
  Content string
  Errors  map[string]string
}

func (msg *Message) Validate() bool {
  msg.Errors = make(map[string]string)

  match := rxEmail.Match([]byte(msg.Email))
  if match == false {
    msg.Errors["Email"] = "Please enter a valid email address"
  }

  if strings.TrimSpace(msg.Content) == "" {
    msg.Errors["Content"] = "Please enter a message"
  }

  return len(msg.Errors) == 0
}
</pre></code></figure>

<p>So what's going on here?</p>

<p>We've started by defining a <code>rxEmail</code> variable, containing a simple regular expression for validating the format of the email address in the form.</p>

<p>Then we define a <code>Message</code> struct, consisting of <code>Email</code> and <code>Content</code> fields (which will hold the data from the submitted form), along with an <code>Errors</code> map to hold any validation error messages.</p>

<p>We then created a <code>Validate()</code> method that acts on a given <code>Message</code>, which checks the format of the email address and makes sure that the content isn't blank. In the event of any errors we add them to the <code>Errors</code> map, and finally return a <code>true</code> or <code>false</code> value to indicate whether validation passed successful or not. In a large project you might want to break the validation checks into helper functions to reduce duplication.</p>

<p>This approach means that we can keep the code in our <code>send</code> handler fantastically light. All we need it to do is retrieve the form values from the POST request, create a new <code>Message</code> instance containing them, and call <code>Validate()</code>. If the validation fails we can re-render the contact form, passing back the relevant <code>Message</code> struct. Like so:</p>

<figure class="file"><figcaption>File: main.go</figcaption><code><pre>
...

func send(w http.ResponseWriter, r *http.Request) {
	// Step 1: Validate form
	msg := &Message{
		Email:   r.PostFormValue("email"),
		Content: r.PostFormValue("content"),
	}

	if msg.Validate() == false {
		render(w, "templates/home.html", msg)
		return
	}

	// Step 2: Send message in an email
	// Step 3: Redirect to confirmation page
}

...
</pre></code></figure>

<p>As a side note, in the code above we're using the <a href="http://golang.org/pkg/net/http/#Request.PostFormValue"><code>PostFormValue()</code></a> method on the request to access the POST data. This is a helper method which parses the form data in the request body (using <a href="http://golang.org/pkg/net/http/#Request.ParseForm"><code>ParseForm()</code></a>) and returns the value for a specific field. If no matching field exists in the request body, it will return the empty string <code>""</code>.</p>

<p>For large request bodies, you might also want to consider using the <a href="https://pkg.go.dev/github.com/gorilla/schema?tab=overview">Gorilla Schema</a> package to automatically decode the form values in to a struct, instead of assigning them manually like we have done in the code above.</p>
  
<p>Anyway, let's now update our <code>home.html</code> template so it displays the validation errors (if they exist) above the relevant fields, and repopulate the form inputs with any information that the user previously typed in:</p>

<figure class="file"><figcaption>File: templates/home.html</figcaption><code><pre>
&lt;style type="text/css"&gt;.error {color: red;}&lt;/style&gt;

&lt;h1&gt;Contact&lt;/h1&gt;
&lt;form action="/" method="POST" novalidate&gt;
  &lt;div&gt;
    {{ with .Errors.Email }}
    &lt;p class="error"&gt;{{ . }}&lt;/p&gt;
    {{ end }}
    &lt;p&gt;&lt;label&gt;Your email:&lt;/label&gt;&lt;/p&gt;
    &lt;p&gt;&lt;input type="email" name="email" value="{{ .Email }}"&gt;&lt;/p&gt;
  &lt;/div&gt;
  &lt;div&gt;
    {{ with .Errors.Content }}
    &lt;p class="error" &gt;{{ . }}&lt;/p&gt;
    {{ end }}
    &lt;p&gt;&lt;label&gt;Your message:&lt;/label&gt;&lt;/p&gt;
    &lt;p&gt;&lt;textarea name="content"&gt;{{ .Content }}&lt;/textarea&gt;&lt;/p&gt;
  &lt;/div&gt;
  &lt;div&gt;
    &lt;input type="submit" value="Send message"&gt;
  &lt;/div&gt;
&lt;/form&gt;
</pre></code></figure>

<p>Let's try this out. Go ahead and run the application:</p>

<figure class="shell"><code><pre>
$ go run .
<samp>2020/03/30 08:41:42 Listening...</samp>
</pre></code></figure>

<p>And try submitting an invalid form. You should find that the form is redisplayed along with the relevant data and validation errors like so:</p> 

<p><img src="/static/images/contact-2.png"></p>

<h2>Sending the Contact Form Message</h2>

<p>Great! That's now working nicely, but our contact form isn't very useful unless we actually do something with it. Let's add a <code>Deliver()</code> method to our <code>Message</code> which sends the contact form message to a particular email address. In the code below I'm using the <a href="https://pkg.go.dev/github.com/go-mail/mail?tab=overview">go-mail/mail</a> package and a <a href="mailtrap.io/">mailtrap.io</a> account for email sending, but the same thing should work with any other SMTP server.</p>

<figure class="file"><figcaption>File: message.go</figcaption><code><pre>
package main

import (
  "regexp"
  "strings"

  "github.com/go-mail/mail"
)

...

func (msg *Message) Deliver() error {
  email := mail.NewMessage()
  email.SetHeader("To", "admin@example.com")
  email.SetHeader("From", "server@example.com")
  email.SetHeader("Reply-To", msg.Email)
  email.SetHeader("Subject", "New message via Contact Form")
  email.SetBody("text/plain", msg.Content)

  username := "your_username"
  password := "your_password"

  return mail.NewDialer("smtp.mailtrap.io", 25, username, password).DialAndSend(email)
}  
</pre></code></figure>

<p>The final step is to head back to our <code>main.go</code> file, add some code to call <code>Deliver()</code>, and issue a <code>303 See Other</code> redirect to the confirmation page that we made earlier:</p>

<figure class="file"><figcaption>File: main.go</figcaption><code><pre>
...

func send(w http.ResponseWriter, r *http.Request) {
	// Step 1: Validate form
	msg := &Message{
		Email:   r.PostFormValue("email"),
		Content: r.PostFormValue("content"),
	}

	if msg.Validate() == false {
		render(w, "templates/home.html", msg)
		return
	}

	// Step 2: Send contact form message in an email
	if err := msg.Deliver(); err != nil {
		log.Println(err)
		http.Error(w, "Sorry, something went wrong", http.StatusInternalServerError)
		return
	}

	// Step 3: Redirect to confirmation page
	http.Redirect(w, r, "/confirmation", http.StatusSeeOther)
}

...
</pre></code></figure>

<p>So long as your SMTP server account credentials are set up correctly, you should now be able to successfully submit the contact form and you should see the confirmation message below in your browser.</p>

<p><img src="/static/images/contact-3.png"></p>
    ]]></description>
  </item>
  <item>
    <pubDate>Sat, 19 Oct 2013 12:00:00 GMT</pubDate>
    <link>https://www.alexedwards.net/blog/golang-response-snippets</link>
    <guid>https://www.alexedwards.net/blog/golang-response-snippets</guid>
    <title>HTTP Response Snippets for Go</title>
    <description><![CDATA[
    <p>Taking inspiration from the Rails <a href="http://guides.rubyonrails.org/layouts_and_rendering.html">layouts and rendering</a> guide, I thought it'd be a nice idea to build a snippet collection illustrating some common HTTP responses for Go web applications.</p>

    <ol style="margin-left: 21px;">
      <li><a href="#headers">Sending Headers Only</a></li>
      <li><a href="#plain">Rendering Plain Text</a></li>
      <li><a href="#json">Rendering JSON</a></li>
      <li><a href="#xml">Rendering XML</a></li>
      <li><a href="#file">Serving a File</a></li>
      <li><a href="#html">Rendering a HTML Template</a></li>
      <li><a href="#string">Rendering a HTML Template to a String</a></li>
      <li><a href="#nesting">Using Layouts and Nested Templates</a></li>
    </ol>

    <h2 id="headers">Sending Headers Only</h2>

    <figure class="file"><figcaption>File: main.go</figcaption><code><pre>    package main

    import (
      "net/http"
    )

    func main() {
      http.HandleFunc("/", foo)
      http.ListenAndServe(":3000", nil)
    }

    func foo(w http.ResponseWriter, r *http.Request) {
      w.Header().Set("Server", "A Go Web Server")
      w.WriteHeader(200)
    }
    </pre></code></figure>

    <figure class="shell"><code><pre>    $ curl -i localhost:3000
    <samp>HTTP/1.1 200 OK
    Server: A Go Web Server
    Content-Type: text/plain; charset=utf-8
    Content-Length: 0</samp>
    </pre></code></figure>

    <h2 id="plain">Rendering Plain Text</h2>

    <figure class="file"><figcaption>File: main.go</figcaption><code><pre>    package main

    import (
      "net/http"
    )

    func main() {
      http.HandleFunc("/", foo)
      http.ListenAndServe(":3000", nil)
    }

    func foo(w http.ResponseWriter, r *http.Request) {
      w.Write([]byte("OK"))
    }
    </pre></code></figure>

    <figure class="shell"><code><pre>    $ curl -i localhost:3000
    <samp>HTTP/1.1 200 OK
    Content-Type: text/plain; charset=utf-8
    Content-Length: 2

    OK</samp>
    </pre></code></figure>

    <h2 id="json">Rendering JSON</h2>

    <figure class="file"><figcaption>File: main.go</figcaption><code><pre>    package main

    import (
      "encoding/json"
      "net/http"
    )

    type Profile struct {
      Name    string
      Hobbies []string
    }

    func main() {
      http.HandleFunc("/", foo)
      http.ListenAndServe(":3000", nil)
    }

    func foo(w http.ResponseWriter, r *http.Request) {
      profile := Profile{"Alex", []string{"snowboarding", "programming"}}

      js, err := json.Marshal(profile)
      if err != nil {
        http.Error(w, err.Error(), http.StatusInternalServerError)
        return
      }

      w.Header().Set("Content-Type", "application/json")
      w.Write(js)
    }
    </pre></code></figure>

    <figure class="shell"><code><pre>    $ curl -i localhost:3000
    <samp>HTTP/1.1 200 OK
    Content-Type: application/json
    Content-Length: 56

    {"Name":"Alex",Hobbies":["snowboarding","programming"]}</samp>
    </pre></code></figure>

    <h2 id="xml">Rendering XML</h2>

    <figure class="file"><figcaption>File: main.go</figcaption><code><pre>    package main

    import (
      "encoding/xml"
      "net/http"
    )

    type Profile struct {
      Name    string
      Hobbies []string `xml:"Hobbies>Hobby"`
    }

    func main() {
      http.HandleFunc("/", foo)
      http.ListenAndServe(":3000", nil)
    }

    func foo(w http.ResponseWriter, r *http.Request) {
      profile := Profile{"Alex", []string{"snowboarding", "programming"}}

      x, err := xml.MarshalIndent(profile, "", "  ")
      if err != nil {
        http.Error(w, err.Error(), http.StatusInternalServerError)
        return
      }

      w.Header().Set("Content-Type", "application/xml")
      w.Write(x)
    }
    </pre></code></figure>

    <figure class="shell"><code><pre>    $ curl -i localhost:3000
    <samp>HTTP/1.1 200 OK
    Content-Type: application/xml
    Content-Length: 128

    &lt;Profile&gt;
      &lt;Name&gt;Alex&lt;/Name&gt;
      &lt;Hobbies&gt;
        &lt;Hobby&gt;snowboarding&lt;/Hobby&gt;
        &lt;Hobby&gt;programming&lt;/Hobby&gt;
      &lt;/Hobbies&gt;
    &lt;/Profile&gt;</samp>
    </pre></code></figure>

    <h2 id="file">Serving a File</h2>

    <figure class="file"><figcaption>File: main.go</figcaption><code><pre>    package main

    import (
      "net/http"
      "path"
    )

    func main() {
      http.HandleFunc("/", foo)
      http.ListenAndServe(":3000", nil)
    }

    func foo(w http.ResponseWriter, r *http.Request) {
      // Assuming you want to serve a photo at 'images/foo.png'
      fp := path.Join("images", "foo.png")
      http.ServeFile(w, r, fp)
    }
    </pre></code></figure>

    <figure class="shell"><code><pre>    $ curl -I localhost:3000
    <samp>HTTP/1.1 200 OK
    Accept-Ranges: bytes
    Content-Length: 236717
    Content-Type: image/png
    Last-Modified: Thu, 10 Oct 2013 22:23:26 GMT</samp>
    </pre></code></figure>

    <h2 id="html">Rendering a HTML Template</h2>

    <figure class="file"><figcaption>File: templates/index.html</figcaption><code><pre>    &lt;h1&gt;Hello &#123;&#123; .Name &#125;&#125;&lt;/h1&gt;
    &lt;p&gt;Lorem ipsum dolor sit amet, consectetur adipisicing elit.&lt;/p&gt;
    </pre></code></figure>

    <figure class="file"><figcaption>File: main.go</figcaption><code><pre>    package main

    import (
      "html/template"
      "net/http"
      "path"
    )

    type Profile struct {
      Name    string
      Hobbies []string
    }

    func main() {
      http.HandleFunc("/", foo)
      http.ListenAndServe(":3000", nil)
    }

    func foo(w http.ResponseWriter, r *http.Request) {
      profile := Profile{"Alex", []string{"snowboarding", "programming"}}

      fp := path.Join("templates", "index.html")
      tmpl, err := template.ParseFiles(fp)
      if err != nil {
        http.Error(w, err.Error(), http.StatusInternalServerError)
        return
      }

      if err := tmpl.Execute(w, profile); err != nil {
        http.Error(w, err.Error(), http.StatusInternalServerError)
      }
    }
    </pre></code></figure>

    <figure class="shell"><code><pre>    $ curl -i localhost:3000
    <samp>HTTP/1.1 200 OK
    Content-Type: text/html; charset=utf-8
    Content-Length: 84

    &lt;h1&gt;Hello Alex&lt;/h1&gt;
    &lt;p&gt;Lorem ipsum dolor sit amet, consectetur adipisicing elit.&lt;/p&gt;</samp>
    </pre></code></figure>

    <h2 id="string">Rendering a HTML Template to a String</h2>

    <p>Instead of passing in the <code>http.ResponseWriter</code> when executing your template (like in the above snippet) use a buffer instead:</p>

    <figure class="file"><figcaption>File: main.go</figcaption><code><pre>    ...
    buf := new(bytes.Buffer)
    if err := tmpl.Execute(buf, profile); err != nil {
      http.Error(w, err.Error(), http.StatusInternalServerError)
    }
    templateString := buf.String()
    ...
    </pre></code></figure>

    <h2 id="nesting">Using Layouts and Nested Templates</h2>

    <figure class="file"><figcaption>File: templates/layout.html</figcaption><code><pre>    &lt;html&gt;
      &lt;head&gt;
        &lt;title&gt;&#123;&#123; template "title" . &#125;&#125;&lt;/title&gt;
      &lt;/head&gt;
      &lt;body&gt;
        &#123;&#123; template "content" . &#125;&#125;
      &lt;/body&gt;
    &lt;/html&gt;
    </pre></code></figure>

    <figure class="file"><figcaption>File: templates/index.html</figcaption><code><pre>    &#123;&#123; define "title" &#125;&#125;An example layout&#123;&#123; end &#125;&#125;

    &#123;&#123; define "content" &#125;&#125;
    &lt;h1&gt;Hello &#123;&#123; .Name &#125;&#125;&lt;/h1&gt;
    &lt;p&gt;Lorem ipsum dolor sit amet, consectetur adipisicing elit.&lt;/p&gt;
    &#123;&#123; end &#125;&#125;
    </pre></code></figure>

    <figure class="file"><figcaption>File: main.go</figcaption><code><pre>    package main

    import (
      "html/template"
      "net/http"
      "path"
    )

    type Profile struct {
      Name    string
      Hobbies []string
    }

    func main() {
      http.HandleFunc("/", foo)
      http.ListenAndServe(":3000", nil)
    }

    func foo(w http.ResponseWriter, r *http.Request) {
      profile := Profile{"Alex", []string{"snowboarding", "programming"}}

      lp := path.Join("templates", "layout.html")
      fp := path.Join("templates", "index.html")

      // Note that the layout file must be the first parameter in ParseFiles
      tmpl, err := template.ParseFiles(lp, fp)
      if err != nil {
        http.Error(w, err.Error(), http.StatusInternalServerError)
        return
      }

      if err := tmpl.Execute(w, profile); err != nil {
        http.Error(w, err.Error(), http.StatusInternalServerError)
      }
    }
    </pre></code></figure>

    <figure class="shell"><code><pre>    $ curl -i localhost:3000
    <samp>HTTP/1.1 200 OK
    Content-Type: text/html; charset=utf-8
    Content-Length: 180

    &lt;html&gt;
      &lt;head&gt;
        &lt;title&gt;An example layout&lt;/title&gt;
      &lt;/head&gt;
      &lt;body&gt;
        &lt;h1&gt;Hello Alex&lt;/h1&gt;
        &lt;p&gt;Lorem ipsum dolor sit amet, consectetur adipisicing elit.&lt;/p&gt;
      &lt;/body&gt;
    &lt;/html&gt;</samp>
    </pre></code></figure>

    <p>If you found this post useful, you might like to subscribe to my <a href="https://www.alexedwards.net/static/feed.rss">RSS feed</a>.</p>
    ]]></description>
  </item>
  <item>
    <pubDate>Fri, 04 Oct 2013 20:00:00 GMT</pubDate>
    <link>https://www.alexedwards.net/blog/understanding-mutexes</link>
    <guid>https://www.alexedwards.net/blog/understanding-mutexes</guid>
    <title>Understanding Mutexes</title>
    <description><![CDATA[
    <p>For anyone new to building web applications with Go, it's important to realise that all incoming HTTP requests are served in their own Goroutine. This means that any code in or called by your application handlers will be running concurrently, and there is a risk of <a href="http://stackoverflow.com/questions/34510/what-is-a-race-condition">race conditions</a> occurring.</p>

    <p>In case you're new to concurrent programming, I'll quickly explain the problem.</p>

    <p>Race conditions occur when two or more Goroutines try to use a piece of shared data at the same time, but the result of their operations is dependent on the exact order that the scheduler executes their instructions.</p>

    <p>As an illustration, here's an example where two Goroutines try to add money to a shared bank balance at the same time:</p>

    <table style="width: 100%; text-align: center">
    <tr><th>Instruction</th><th>Goroutine 1</th><th>Goroutine 2</th><th>Bank Balance</th></tr>
    <tr><td>1</td><td>Read balance &lArr; &pound;50</td><td></td><td>&pound;50</td></tr>
    <tr><td>2</td><td></td><td>Read balance &lArr; &pound;50</td><td>&pound;50</td></tr>
    <tr><td>3</td><td>Add &pound;100 to balance</td><td></td><td>&pound;50</td></tr>
    <tr><td>4</td><td></td><td>Add &pound;50 to balance</td><td>&pound;50</td></tr>
    <tr><td>5</td><td>Write balance &rArr; &pound;150</td><td></td><td>&pound;150</td></tr>
    <tr><td>6</td><td></td><td>Write balance &rArr; &pound;100</td><td>&pound;100</td></tr>
    </table>

    <p>Despite making two separate deposits, only the second one is reflected in the final balance because the two Goroutines were <em>racing</em> each other to make the change.</p>

    <p>The Go blog describes the downsides:</p>

    <blockquote>Race conditions are among the most insidious and elusive programming errors. They typically cause erratic and mysterious failures, often long after the code has been deployed to production. While Go's concurrency mechanisms make it easy to write clean concurrent code, they don't prevent race conditions. Care, diligence, and testing are required.</blockquote>

    <p>Go provides a number of tools to help us avoid data races. These include <a href="http://golangtutorials.blogspot.co.uk/2011/06/channels-in-go.html">Channels</a> for communicating data between Goroutines, a <a href="http://www.goinggo.net/2013/09/detecting-race-conditions-with-go.html">Race Detector</a> for monitoring unsynchronized access to memory at runtime, and a variety of 'locking' features in the <a href="http://golang.org/pkg/sync/atomic/">Atomic</a> and <a href="http://golang.org/pkg/sync/">Sync</a> packages. One of these features are Mutual Exclusion locks, or <em>mutexes</em>, which we'll be looking at in the rest of this post.</p>

    <h2>Creating a Basic Mutex</h2>

    <p>Let's create some toy code to mimic the bank balance example:

    <figure class="plain"><code><pre>    import "strconv"

    var Balance = &amp;currency{50.00, "GBP"}

    type currency struct {
      amount float64
      code   string
    }

    func (c *currency) Add(i float64) {
      // This is racy
      c.amount += i
    }

    func (c *currency) Display() string {
      // This is racy
      return strconv.FormatFloat(c.amount, 'f', 2, 64) + " " + c.code
    }
    </pre></code></figure>

    <p>We know that if there are multiple Goroutines using this code and calling <code>Balance.Add()</code> and <code>Balance.Display()</code>, then at some point a race condition is likely to occur.</p>

    <p>One way we could prevent a data race is to ensure that if one Goroutine is using the <code>Balance</code> variable, then all other Goroutines are prevented (or <em>mutually excluded</em>) from using it at the same time.</p>

    <p>We can do this by creating a <a href="http://golang.org/pkg/sync/#Mutex">Mutex</a> and setting a <em>lock</em> around particular lines of code with it. While one Goroutine holds the lock, all other Goroutines are prevented from executing any lines of code protected by the same mutex, and are forced to wait until the lock is yielded before they can proceed.</p>

    <p>In practice, it's more simple than it sounds:</p>

    <figure class="plain"><code><pre>    import (
      "strconv"
      "sync"
    )

    var mu = &amp;sync.Mutex{}
    var Balance = &amp;currency{50.00, "GBP"}

    type currency struct {
      amount float64
      code   string
    }

    func (c *currency) Add(i float64) {
      mu.Lock()
      c.amount += i
      mu.Unlock()
    }

    func (c *currency) Display() string {
      mu.Lock()
      amt := c.amount
      mu.Unlock()
      return strconv.FormatFloat(amt, 'f', 2, 64) + " " + c.code
    }
    </pre></code></figure>

    <p>Here we've created a new mutex and assigned it to <code>mu</code>. We then use <code>mu.Lock()</code> to create a lock immediately before both racy parts of the code, and <code>mu.Unlock()</code> to yield the lock immediately after.</p>

    <p>There's a couple of things to note:</p>

    <ul>
      <li>The same mutex variable can be used in multiple places throughout your code. So long as it's the same mutex (in our case <code>mu</code>) then <em>none</em> of the chunks of code protected by it can be executed at the same time.</li>
      <li>Holding a mutex lock doesn't 'protect' a memory location from being read or updated. A non-mutex-locked line of code could still access it at any time and create a race condition. Therefore you need to be careful to make sure all points in your code which are potentially racy are protected.</li>
    </ul>

    <p>Let's tidy up the example a bit:</p>

    <figure class="plain"><code><pre>    import (
      "strconv"
      "sync"
    )

    var Balance = &amp;currency{amount: 50.00, code: "GBP"}

    type currency struct {
      sync.Mutex
      amount float64
      code   string
    }

    func (c *currency) Add(i float64) {
      c.Lock()
      c.amount += i
      c.Unlock()
    }

    func (c *currency) Display() string {
      c.Lock()
      defer c.Unlock()
      return strconv.FormatFloat(c.amount, 'f', 2, 64) + " " + c.code
    }
    </pre></code></figure>

    <p>So what's changed here?</p>

    <p>Because our mutex is only being used in the context of a <code>currency</code> object, it makes sense to anonymously embed it in the <code>currency</code> struct (an idea borrowed from Andrew Gerrard's excellent <a href="http://nf.wh3rd.net/10things/#1">
    10 things you (probably) don't know about Go</a> slideshow). If you look at a larger codebase with lots of mutexes, like Go's <a href="http://golang.org/src/pkg/net/http/server.go">HTTP Server</a>, you can see how this approach helps to keep locking rules nice and clear.</p>

    <p>We've also made use of the <a href="http://golang.org/doc/effective_go.html#defer">defer</a> statement, which ensures that the mutex gets unlocked immediately before a function returns. This is common practice for functions that contain multiple return statements, or where the return statement itself is racy.</p>

    <h2>Read Write Mutexes</h2>

    <p>In our bank balance example, having a full mutex lock on the <code>Display()</code> function isn't strictly necessary. It would be OK for us to have multiple reads of <code>Balance</code> happening at the same time, so long as nothing is being written.</p>

    <p>We can achieve this using <a href="http://golang.org/pkg/sync/#RWMutex">RWMutex</a>, a reader/writer mutual exclusion lock which allows any number of readers to hold the lock <strong>or</strong> one writer. Depending on the nature of your application and ratio of reads to writes, this may be more efficient than using a full mutex.</p>

    <p>Reader locks can be opened and closed with <code>RLock()</code> and <code>RUnlock()</code> like so:</p>

    <figure class="plain"><code><pre>    import (
      "strconv"
      "sync"
    )

    var Balance = &amp;currency{amount: 50.00, code: "GBP"}

    type currency struct {
      sync.RWMutex
      amount float64
      code   string
    }

    func (c *currency) Add(i float64) {
      c.Lock()
      c.amount += i
      c.Unlock()
    }

    func (c *currency) Display() string {
      c.RLock()
      defer c.RUnlock()
      return strconv.FormatFloat(c.amount, 'f', 2, 64) + " " + c.code
    }
    </pre></code></figure>

    <p>If you found this post useful, you might like to subscribe to my <a href="https://www.alexedwards.net/static/feed.rss">RSS feed</a>.</p>
    ]]></description>
  </item>
  <item>
    <pubDate>Fri, 20 Sep 2013 22:00:00 GMT</pubDate>
    <link>https://www.alexedwards.net/blog/golang-automatic-reloads</link>
    <guid>https://www.alexedwards.net/blog/golang-automatic-reloads</guid>
    <title>Golang Automatic Reloads</title>
    <description><![CDATA[
    <p>I wrote a short Bash script to automatically reload Go programs.</p>

    <p>The script acts as a light wrapper around <code>go run</code>, stopping and restarting it whenever a <code>.go</code> file in your current directory or <code>$GOPATH/src</code> folder is saved. I've been using it mainly when developing web applications, in the same way that I use Shotgun or Guard when working with Ruby.</p>

    <p>You can grab this from the <a href="https://github.com/alexedwards/go-reload">Github repository</a>.</p>

    <figure class="file"><figcaption>File: go-reload</figcaption><code><pre>    #!/bin/bash

    # Watch all *.go files in the specified directory
    # Call the restart function when they are saved
    function monitor() {
      inotifywait -q -m -r -e close_write --exclude '[^g][^o]$' $1 |
      while read line; do
        restart
      done
    }

    # Terminate and rerun the main Go program
    function restart {
      if [ "$(pidof $PROCESS_NAME)" ]; then
        killall -q -w -9 $PROCESS_NAME
      fi
      echo ">> Reloading..."
      go run $FILE_PATH $ARGS &
    }

    # Make sure all background processes get terminated
    function close {
      killall -q -w -9 inotifywait
      exit 0
    }

    trap close INT
    echo "== Go-reload"
    echo ">> Watching directories, CTRL+C to stop"

    FILE_PATH=$1
    FILE_NAME=$(basename $FILE_PATH)
    PROCESS_NAME=${FILE_NAME%%.*}

    shift
    ARGS=$@

    # Start the main Go program
    go run $FILE_PATH $ARGS &

    # Monitor the /src directories in all directories on the GOPATH
    OIFS="$IFS"
    IFS=':'
    for path in $GOPATH
    do
      monitor $path/src &
    done
    IFS="$OIFS"

    # Monitor the current directory
    monitor .
    </pre></code></figure>

    <h2>Usage</h2>

    <p>The only dependency for this script is <a href="https://github.com/rvoicilas/inotify-tools/wiki">inotify-tools</a>, which is used to monitor the filesystem for changes.<p>

    <figure class="shell"><code><pre>    $ sudo apt-get install inotify-tools
    </pre></code></figure>

    <p>Once you've <a href="https://raw.github.com/alexedwards/go-reload/master/go-reload">downloaded</a> (or copy-pasted) the script, you'll need to make it executable and move it to <code>/usr/local/bin</code> or another directory on your system path:</p>

    <figure class="shell"><code><pre>    $ wget https://raw.github.com/alexedwards/go-reload/master/go-reload
    $ chmod +x go-reload
    $ sudo mv go-reload /usr/local/bin/
    </pre></code></figure>

    <p>You should then be able to use the <code>go-reload</code> command in place of <code>go run</code>:</p>

    <figure class="shell"><code><pre>    $ go-reload main.go
    <samp>== Go-reload
    >> Watching directories, CTRL+C to stop</samp>
    </pre></code></figure>

    <p>If you found this post useful, you might like to subscribe to my <a href="https://www.alexedwards.net/static/feed.rss">RSS feed</a>.</p>
    ]]></description>
  </item>
  <item>
    <pubDate>Thu, 12 Sep 2013 19:00:00 GMT</pubDate>
    <link>https://www.alexedwards.net/blog/a-recap-of-request-handling</link>
    <guid>https://www.alexedwards.net/blog/a-recap-of-request-handling</guid>
    <title>A Recap of Request Handling in Go</title>
    <description><![CDATA[
    <p>Processing HTTP requests with Go is primarily about two things: ServeMuxes and Handlers.</p>

    <p>A <a href="http://golang.org/pkg/net/http/#ServeMux">ServeMux</a> is essentially a HTTP request router (or <em>multiplexor</em>). It compares incoming requests against a list of predefined URL paths, and calls the associated handler for the path whenever a match is found.</p>

    <p>Handlers are responsible for writing response headers and bodies. Almost any object can be a handler, so long as it satisfies the <a href="http://golang.org/pkg/net/http/#Handler">Handler interface</a>. In lay terms, that simply means it must have a <code>ServeHTTP</code> method with the following signature:</p>

    <p><code>ServeHTTP(http.ResponseWriter, *http.Request)</code></p>

    <p>Go's HTTP package ships with a few functions to generate common handlers, such as <a href="http://golang.org/pkg/net/http/#FileServer">FileServer</a>,  <a href="http://golang.org/pkg/net/http/#NotFoundHandler">NotFoundHandler</a> and <a href="http://golang.org/pkg/net/http/#RedirectHandler">RedirectHandler</a>. Let's begin with a simple but contrived example:</p>

    <figure class="shell"><code><pre>    $ mkdir handler-example
    $ cd handler-example
    $ touch main.go
    </pre></code></figure>

    <figure class="file"><figcaption>File: main.go</figcaption><code><pre>    package main

    import (
      "log"
      "net/http"
    )

    func main() {
      mux := http.NewServeMux()

      rh := http.RedirectHandler("http://example.org", 307)
      mux.Handle("/foo", rh)

      log.Println("Listening...")
      http.ListenAndServe(":3000", mux)
    }
    </pre></code></figure>
    <p>Let's step through this quickly:</p>

    <ul>
      <li>In the <code>main</code> function we use the <a href="http://golang.org/pkg/net/http/#NewServeMux">http.NewServeMux</a> function to create an empty ServeMux.
      <li>We then use the <a href="http://golang.org/pkg/net/http/#RedirectHandler">http.RedirectHandler</a> function to create a new handler. This handler 307 redirects all requests it receives to <code>http://example.org</code>.</li>
      <li>Next we use the <a href="http://golang.org/pkg/net/http/#ServeMux.Handle">ServeMux.Handle</a> function to register this with our new ServeMux, so it acts as the handler for all incoming requests with the URL path <code>/foo</code>.</li>
      <li>Finally we create a new server and start listening for incoming requests with the <a href="http://golang.org/pkg/net/http/#ListenAndServe">http.ListenAndServe</a> function, passing in our ServeMux for it to match requests against.</li>
    </ul>

    <p>Go ahead and run the application:</p>

    <figure class="shell"><code><pre>    $ go run main.go
    <samp>Listening...</samp>
    </pre></code></figure>

    <p>And visit <a href="http://localhost:3000/foo">http://localhost:3000/foo</a> in your browser. You should find that your request gets successfully redirected.</p>

    <p>The eagle-eyed of you might have noticed something interesting: The signature for the ListenAndServe function is <code>ListenAndServe(addr string, handler Handler)</code>, but we passed a ServeMux as the second parameter.</p>

    <p>We were able to do this because ServeMux also <a href="http://golang.org/pkg/net/http/#ServeMux.ServeHTTP">has a ServeHTTP method</a>, meaning that it too satisfies the Handler interface.</p>

    <p>For me it simplifies things to think of a ServeMux as <em>just being a special kind of handler</em>, which instead of providing a response itself passes the request on to a second handler. This isn't as much of a leap as it first sounds &ndash; chaining handlers together is fairly commonplace in Go<!-- , and we'll take a look at an example further down the page -->.</p>

    <h2>Custom Handlers</h2>

    <p>Let's create a custom handler which responds with the current local time in a given format:</p>

    <figure class="plain"><code><pre>    type timeHandler struct {
      format string
    }

    func (th *timeHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) {
      tm := time.Now().Format(th.format)
      w.Write([]byte("The time is: " + tm))
    }
    </pre></code></figure>

    <p>The exact code here isn't too important.</p>

    <p>All that really matters is that we have an object (in this case it's a <code>timeHandler</code> struct, but it could equally be a string or function or anything else), and we've implemented a method with the signature <code>ServeHTTP(http.ResponseWriter, *http.Request)</code> on it. That's all we need to make a handler.</p>

    <p>Let's embed this in a concrete example:</p>

    <figure class="file"><figcaption>File: main.go</figcaption><code><pre>    package main

    import (
      "log"
      "net/http"
      "time"
    )

    type timeHandler struct {
      format string
    }

    func (th *timeHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) {
      tm := time.Now().Format(th.format)
      w.Write([]byte("The time is: " + tm))
    }

    func main() {
      mux := http.NewServeMux()

      th := &timeHandler{format: time.RFC1123}
      mux.Handle("/time", th)

      log.Println("Listening...")
      http.ListenAndServe(":3000", mux)
    }
    </pre></code></figure>

    <p>In the <code>main</code> function we initialised the <code>timeHandler</code> in exactly the same way we would any normal struct, using the <code>&amp;</code> symbol to yield a pointer. And then, like the previous example, we use the <code>mux.Handle</code> function to register this with our ServeMux.</p>

    <p>Now when we run the application, the ServeMux will pass any request for <code>/time</code> straight on to our <code>timeHandler.ServeHTTP</code> method.</p>

    <p>Go ahead and give it a try: <a href="http://localhost:3000/time">http://localhost:3000/time</a>.</p>

    <p>Notice too that we could easily reuse the <code>timeHandler</code> in multiple routes:</p>

    <figure class="plain"><code><pre>    func main() {
      mux := http.NewServeMux()

      th1123 := &timeHandler{format: time.RFC1123}
      mux.Handle("/time/rfc1123", th1123)

      th3339 := &timeHandler{format: time.RFC3339}
      mux.Handle("/time/rfc3339", th3339)

      log.Println("Listening...")
      http.ListenAndServe(":3000", mux)
    }
    </pre></code></figure>

    <p><code>  </code></p>

    <h2>Functions as Handlers</h2>

    <p>For simple cases (like the example above) defining new custom types and ServeHTTP methods feels a bit verbose. Let's look at an alternative approach, where we leverage Go's <a href="http://golang.org/pkg/net/http/#HandlerFunc">http.HandlerFunc</a> type to coerce a normal function into satisfying the Handler interface.</p>

    <p>Any function which has the signature <code>func(http.ResponseWriter, *http.Request)</code> can be converted into a HandlerFunc type. This is useful because HandleFunc objects come with an inbuilt ServeHTTP method which &ndash; rather cleverly and conveniently &ndash; executes the content of the original function.</p>

    <p>If that sounds confusing, try taking a look at the <a href="http://golang.org/src/pkg/net/http/server.go?s=35455:35502#L1221">relevant source code</a>. You'll see that it's a very succinct way of making a function satisfy the Handler interface.</p>

    <p>Let's reproduce the timeHandler application using this technique:</p>

    <figure class="file"><figcaption>File: main.go</figcaption><code><pre>    package main

    import (
      "log"
      "net/http"
      "time"
    )

    func timeHandler(w http.ResponseWriter, r *http.Request) {
      tm := time.Now().Format(time.RFC1123)
      w.Write([]byte("The time is: " + tm))
    }

    func main() {
      mux := http.NewServeMux()

      // Convert the timeHandler function to a HandleFunc type
      th := http.HandlerFunc(timeHandler)
      // And add it to the ServeMux
      mux.Handle("/time", th)

      log.Println("Listening...")
      http.ListenAndServe(":3000", mux)
    }
    </pre></code></figure>

    <!-- TODO: -->

    <p>In fact, converting a function to a HandlerFunc type and then adding it to a ServeMux like this is so common that Go provides a shortcut: the <a href="http://golang.org/pkg/net/http/#ServeMux.HandleFunc">ServeMux.HandleFunc</a> method.</p>

    <p>This is what the <code>main()</code> function would have looked like if we'd used this shortcut instead:</p>

    <figure class="plain"><code><pre>    func main() {
      mux := http.NewServeMux()

      mux.HandleFunc("/time", timeHandler)

      log.Println("Listening...")
      http.ListenAndServe(":3000", mux)
    }
    </pre></code></figure>

    <p id="passing-variables">Most of the time using a function as a handler like this works well. But there is a bit of a limitation when things start getting more complex.</p>

    <p>You've probably noticed that, unlike the method before, we've had to hardcode the time format in the <code>timeHandler</code> function. <em>What happens when we want to pass information or variables from <code>main()</code> to a handler?</em></p>

    <p>A neat approach is to put our handler logic into a closure, and <em>close over</em> the variables we want to use:</p>

    <figure class="file"><figcaption>File: main.go</figcaption><code><pre>    package main

    import (
      "log"
      "net/http"
      "time"
    )

    func timeHandler(format string) http.Handler {
      fn := func(w http.ResponseWriter, r *http.Request) {
        tm := time.Now().Format(format)
        w.Write([]byte("The time is: " + tm))
      }
      return http.HandlerFunc(fn)
    }

    func main() {
      mux := http.NewServeMux()

      th := timeHandler(time.RFC1123)
      mux.Handle("/time", th)

      log.Println("Listening...")
      http.ListenAndServe(":3000", mux)
    }
    </pre></code></figure>

    <p>The <code>timeHandler</code> function now has a subtly different role. Instead of coercing the function into a handler (like we did previously), we are now using it to <em>return a handler</em>. There's two key elements to making this work.</p>

    <p>First it creates <code>fn</code>, an anonymous function which accesses &dash; or closes over &ndash; the <code>format</code> variable forming a <em>closure</em>. Regardless of what we do with the closure it will always be able to access the variables that are local to the scope it was created in &ndash; which in this case means it'll always have access to the <code>format</code> variable.</p>

    <p>Secondly our closure has the signature <code>func(http.ResponseWriter, *http.Request)</code>. As you may remember from earlier, this means that we can convert it into a HandlerFunc type (so that it satisfies the Handler interface). Our <code>timeHandler</code> function then returns this converted closure.</p>

    <p>In this example we've just been passing a simple string to a handler. But in a real-world application you could use this method to pass database connection, template map, or any other application-level context. It's a good alternative to using global variables, and has the added benefit of making neat self-contained handlers for testing.</p>

    <p>You might also see this same pattern written as:</p>

    <figure class="plain"><code><pre>    func timeHandler(format string) http.Handler {
      return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        tm := time.Now().Format(format)
        w.Write([]byte("The time is: " + tm))
      })
    }
    </pre></code></figure>

    <p>Or using an implicit conversion to the HandlerFunc type on return:</p>

    <figure class="plain"><code><pre>    func timeHandler(format string) http.HandlerFunc {
      return func(w http.ResponseWriter, r *http.Request) {
        tm := time.Now().Format(format)
        w.Write([]byte("The time is: " + tm))
      }
    }
    </pre></code></figure>

    <!-- TODO: Talk about defining as methods: https://gist.github.com/tsenart/5fc18c659814c078378d -->

    <h2>The DefaultServeMux</h2>

    <p>You've probably seen DefaultServeMux mentioned in lots of places, from the simplest Hello World examples to the Go source code.</p>

    <p>It took me a long time to realise it isn't anything special. The DefaultServeMux is just a  plain ol' ServeMux like we've already been using, which gets instantiated by default when the HTTP package is used. Here's the relevant line from the Go source:</p>

    <p><code>var DefaultServeMux = NewServeMux()</code></p>

    <p>The HTTP package provides a couple of shortcuts for working with the DefaultServeMux: <a href="http://golang.org/pkg/net/http/#Handle">http.Handle</a> and <a href="http://golang.org/pkg/net/http/#HandleFunc">http.HandleFunc</a>. These do exactly the same as their namesake functions we've already looked at, with the difference that they add handlers to the DefaultServeMux instead of one that you've created. </p>

    <p>Additionally, ListenAndServe will fall back to using the DefaultServeMux if no other handler is provided (that is, the second parameter is set to <code>nil</code>).</p>

    <p>So as a final step, let's update our timeHandler application to use the DefaultServeMux instead:</p></del>

    <figure class="file"><figcaption>File: main.go</figcaption><code><pre>    package main

    import (
      "log"
      "net/http"
      "time"
    )

    func timeHandler(format string) http.Handler {
      fn := func(w http.ResponseWriter, r *http.Request) {
        tm := time.Now().Format(format)
        w.Write([]byte("The time is: " + tm))
      }
      return http.HandlerFunc(fn)
    }

    func main() {
      // Note that we skip creating the ServeMux...

      var format string = time.RFC1123
      th := timeHandler(format)

      // We use http.Handle instead of mux.Handle...
      http.Handle("/time", th)

      log.Println("Listening...")
      // And pass nil as the handler to ListenAndServe.
      http.ListenAndServe(":3000", nil)
    }
    </pre></code></figure>

    <p>If you found this post useful, you might like to subscribe to my <a href="https://www.alexedwards.net/static/feed.rss">RSS feed</a>.</p>
    ]]></description>
  </item>
   <item>
    <pubDate>Mon, 2 Sep 2013 12:00:00 GMT</pubDate>
    <link>https://www.alexedwards.net/blog/a-mux-showdown</link>
    <guid>https://www.alexedwards.net/blog/a-mux-showdown</guid>
    <title>Gorilla vs Pat vs Routes: A Mux Showdown</title>
    <description><![CDATA[
    <p>One of the first things I missed when learning Go was being able to route HTTP requests to handlers based on the <em>pattern</em> of a URL path, like you can with web frameworks like Sinatra and Django.</p>

    <p>Although Go's <a href="http://golang.org/pkg/net/http/#NewServeMux">ServeMux</a> does a great job at routing incoming requests, it only works for fixed URL paths. To support pretty URLs with variable parameters we either need to roll a custom router (or <em>HTTP request multiplexer</em> in Go terminology), or look to a third-party package.</p>

    <p>In this post we'll compare and contrast three popular packages for the job: <a href="https://github.com/bmizerany/pat">Pat</a>, <a href="https://github.com/drone/routes">Routes</a> and <a href="http://www.gorillatoolkit.org/pkg/mux">Gorilla Mux</a>. If you're already familiar with them, you might want to <a href="#benchmarks">skip to the benchmarks</a> and summary.</p>

    <h2>Pat</h2>

    <p><a href="https://github.com/bmizerany/pat">Pat</a> by Blake Mizerany is the simplest and lightest of the three packages. It supports basic pattern matching on request paths, matching on request method (GET, POST etc), and the capture of named parameters.</p>

    <p>The syntax for defining URL patterns should feel familiar if you're from the Ruby world &ndash; named parameters start with a colon, with the remainder of the path matched literally. For example, the pattern <code>/user/:name/profile</code> would match a request to <code>/user/oomi/profile</code>, with the name <code>oomi</code> captured as a parameter.</p>

    <p>It's worth pointing out that behind the scenes Pat uses a custom algorithm for pattern matching, rather than a regular expression based approach like the other two packages. In theory this means it should be more a little more optimised for the task at hand.</p>

    <p>Let's take a look at a sample application using Pat:</p>

    <figure class="shell"><code><pre>    $ mkdir pat-example && cd pat-example
    $ touch app.go
    $ go get github.com/bmizerany/pat
    </pre></code></figure>


    <figure class="file"><figcaption>File: app.go</figcaption><code><pre>    package main

    import (
      "github.com/bmizerany/pat"
      "log"
      "net/http"
    )

    func main() {
      mux := pat.New()
      mux.Get("/user/:name/profile", http.HandlerFunc(profile))

      http.Handle("/", mux)

      log.Println("Listening...")
      http.ListenAndServe(":3000", nil)
    }

    func profile(w http.ResponseWriter, r *http.Request) {
      params := r.URL.Query()
      name := params.Get(":name")
      w.Write([]byte("Hello " + name))
    }
    </pre></code></figure>

    <p>We'll quickly step through the interesting bits.</p>

    <p>In the <code>main</code> function we start by creating a new HTTP request multiplexer (or mux for short) with Pat. Then we add a rule to the mux so that all <code>GET</code> requests which match the specified pattern are routed to the <code>profile</code> function.</p>

    <p>Next we use the <a href="http://golang.org/pkg/net/http/#Handle">Handle</a> function to register our custom mux as the handler for <em>all incoming requests</em> in Go's DefaultServeMux.</p>

    <p>Because we're only using a single handler in this code, an alternative approach would be to skip registering with the DefaultServeMux, and pass our custom mux directly to <a href="http://golang.org/pkg/net/http/#ListenAndServe">ListenAndServe</a> as the handler instead.</p>

    <p>When a request gets matched, Pat adds any named parameters to the URL <a href="http://golang.org/pkg/net/url/#URL">RawQuery</a>. In the <code>profile</code> function we then access these in the same way as a normal query string value.</p>

    <p>Go ahead and run the application:</p>

    <figure class="shell"><code><pre>    $ go run app
    <samp>Listening...</samp>
    </pre></code></figure>

    <p>And visit <a href="http://localhost:3000/user/oomi/profile">localhost:3000/user/oomi/profile</a> in your browser. You should see a <code>Hello oomi</code> response.</p>


    <p>Pat also provides a couple of other nice touches, including redirecting paths with trailing slashes. Here's the <a href="http://godoc.org/github.com/bmizerany/pat">full documentation</a>.</p>

    <h2>Routes</h2>

    <p><a href="https://github.com/drone/routes">Routes</a> by Drone provides a similar  interface to Pat, with the additional benefit that patterns can be more tightly controlled with optional Regular Expressions. For example, the two patterns below are both valid, with the second one matching if the name parameter contains lowercase letters only:</p>

    <ul>
      <li><code>/user/:name/profile</code></li>
      <li><code>/user/:name([a-z]+)/profile</code></li>
    </ul>

    <p>Routes also provides a few other nice features, including:</p>

    <ul>
      <li>Built-in routing for a static files.</li>
      <li>A before filter, so specific code can be run before each request is handled.</li>
      <li>Helpers for returning JSON and XML responses.</li>
    </ul>

    <p>Basic usage of Routes is almost identical to Pat:</p>

    <figure class="shell"><code><pre>    $ mkdir routes-example && cd routes-example
    $ touch app.go
    $ go get github.com/drone/routes
    </pre></code></figure>

    <figure class="file"><figcaption>File: app.go</figcaption><code><pre>    package main

    import (
      "github.com/drone/routes"
      "log"
      "net/http"
    )

    func main() {
      mux := routes.New()
      mux.Get("/user/:name([a-z]+)/profile", profile)

      http.Handle("/", mux)

      log.Println("Listening...")
      http.ListenAndServe(":3000", nil)
    }

    func profile(w http.ResponseWriter, r *http.Request) {
      params := r.URL.Query()
      name := params.Get(":name")
      w.Write([]byte("Hello " + name))
    }
    </pre></code></figure>

    <h2>Gorilla Mux</h2>

    <p><a href="http://www.gorillatoolkit.org/pkg/mux">Gorilla Mux</a> is the most full-featured of the three packages. It supports:</p>

    <ul>
      <li>Pattern matching on request paths, with optional regular expressions.</li>
      <li>Matching on URL host and scheme, request method, header and query values.</li>
      <li>Matching based on custom functions.</li>
      <li>Use of sub-routers for easy nested routing.</li>
    </ul>

    <p>Additionally the matchers can be chained together, giving a lot of potential for granular routing rules if you need them.</p>

    <p>The pattern syntax that Gorilla uses is slightly different to the other packages, with named parameters surrounded by curly braces. For example: <code>/user/{name}/profile</code> and <code>/user/{name:[a-z]+}/profile</code>.</p>

    <p>Let's take a look at an example:</p>

    <figure class="shell"><code><pre>    $ mkdir gorilla-example && cd gorilla-example
    $ touch app.go
    $ go get github.com/gorilla/mux
    </pre></code></figure>

    <figure class="file"><figcaption>File: app.go</figcaption><code><pre>    package main

    import (
      "github.com/gorilla/mux"
      "log"
      "net/http"
    )

    func main() {
      rtr := mux.NewRouter()
      rtr.HandleFunc("/user/{name:[a-z]+}/profile", profile).Methods("GET")

      http.Handle("/", rtr)

      log.Println("Listening...")
      http.ListenAndServe(":3000", nil)
    }

    func profile(w http.ResponseWriter, r *http.Request) {
      params := mux.Vars(r)
      name := params["name"]
      w.Write([]byte("Hello " + name))
    }
    </pre></code></figure>

    <p>Fundamentally there's the same thing going on here as in the previous two examples. So although the syntax looks a bit different I won't dwell on it &ndash; the Gorilla <a href="http://www.gorillatoolkit.org/pkg/mux">documentation</a> does a fine job of explaining it if it's not immediately clear.</p>

    <h2 id="benchmarks">Relative Performance</h2>

    <p>I ran two different sets of benchmarks on the packages. The first was a stripped-down benchmark to look at their performance in isolation, and the second was an attempt at profiling a more real-world use case.</p>

    <p>In both tests I measured the number of successful requests across a ten second period, and took the average over 50 iterations, all running on my local machine.</p>

    <p>For the 'stripped-down' benchmark, requests were simply routed to a handler that returned a 200 status code and message. Here are the <a href="https://gist.github.com/alexedwards/6404944">code samples</a> and results:</p>

    <figure class="chart">
      <img src="https://www.alexedwards.net/static/images/muxer-performance-comparison.png" alt="">
    </figure>

    <p>In this test the best performing package appeared to be Pat by a large margin. It handled around 30% more requests than Routes and Gorilla Mux, which were very evenly matched.</p>

    <p>In the second benchmark requests were routed to a handler which accessed a named parameter from the URL, and then merged it with a HTML template read from disk. Here are the <a href="https://gist.github.com/alexedwards/6414164">code samples</a> and results:</p>

    <figure class="chart">
      <img src="https://www.alexedwards.net/static/images/muxer-performance-comparison-2.png" alt="">
    </figure>


    <p>In this benchmark the performance difference between the three packages was negligible.</p>

    <p>Although it's always dangerous to draw conclusions from just one set of tests, it does point toward the overall performance impact of a router being much smaller for higher-latency applications, such as those with a lot of file system or database access in the handlers.</p>

    <h2>Summary</h2>

    <p>Pat would appear to be a good choice for scenarios where performance is important, you have a low-latency application, and only require simple pattern-based routing.</p>

    <p>If you're likely to be validating a lot of parameter input with regular expressions in your application, then it probably makes sense to skip Pat and use Routes or Gorilla Mux instead, with the expressions built into your routing patterns.</p>

    <p>For higher-latency applications, where there appears to be less of an overall impact due to router performance, Gorilla Mux may be a wise choice because of the sheer number of options and the flexibility it provides. Although I haven't looked at it in detail, larger applications with a lot of URL endpoints may also get a performance benefit from using Gorilla's nested routing too.</p>

    <p>If you found this post useful, you might like to subscribe to my <a href="https://www.alexedwards.net/static/feed.rss">RSS feed</a>.</p>
    ]]></description>
  </item>
   <item>
    <pubDate>Sat, 24 Aug 2013 12:00:00 GMT</pubDate>
    <link>https://www.alexedwards.net/blog/serving-static-sites-with-go</link>
    <guid>https://www.alexedwards.net/blog/serving-static-sites-with-go</guid>
    <title>Serving Static Sites with Go</title>
    <description><![CDATA[
<p>I've recently moved the site you're reading right now from a Sinatra/Ruby application to an (almost) static site served by Go. So while it's fresh in my head, here's an explanation of principles behind creating and serving static sites with Go.</p>

<p>Let's begin with a simple but real-world example: serving vanilla HTML and CSS files from a particular location on disk.</p>

<p>Start by creating a directory to hold the project:</p>

<figure class="shell"><code><pre>
$ mkdir static-site
$ cd static-site
</pre></code></figure>

<p>And then add a <code>main.go</code> file to hold our code, and some simple HTML and CSS files in a <code>static</code> directory.</p>

<figure class="shell"><code><pre>
$ touch main.go
$ mkdir -p static/stylesheets
$ touch static/example.html static/stylesheets/main.css
</pre></code></figure>

<figure class="file"><figcaption>File: static/example.html</figcaption><code><pre>
&lt;!doctype html&gt;
&lt;html&gt;
&lt;head&gt;
  &lt;meta charset="utf-8"&gt;
  &lt;title&gt;A static page&lt;/title&gt;
  &lt;link rel="stylesheet" href="/stylesheets/main.css"&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;h1&gt;Hello from a static page&lt;/h1&gt;
&lt;/body&gt;
&lt;/html&gt;
</pre></code></figure>

<figure class="file"><figcaption>File: static/stylesheets/main.css</figcaption><code><pre>
body {color: #c0392b}
</pre></code></figure>

<p>Once those files are created, the code we need to get up and running is wonderfully compact:</p>

<figure class="file"><figcaption>File: main.go</figcaption><code><pre>
package main

import (
  "log"
  "net/http"
)

func main() {
  fs := http.FileServer(http.Dir("./static"))
  http.Handle("/", fs)

  log.Println("Listening on :3000...")
  err := http.ListenAndServe(":3000", nil)
  if err != nil {
    log.Fatal(err)
  }
}
</pre></code></figure>

<p>Let's step through this.</p>

<p>First we use the <a href="http://golang.org/pkg/net/http/#FileServer"><code>http.FileServer()</code></a> function to create a handler which responds to all HTTP requests with the contents of a given <em>file system</em>. For our file system we're using the <code>static</code> directory relative to our application, but you could use any other directory on your machine (or indeed any object that implements the <a href="https://golang.org/pkg/net/http/#FileSystem"><code>http.FileSystem</code></a> interface). Next we use the <a href="http://golang.org/pkg/net/http/#Handle"><code>http.Handle()</code></a> function to register the file server as the handler for all requests, and launch the server listening on port 3000.</p>

<p>It's worth pointing out that in Go the pattern <code>"/"</code> matches all request paths, rather than just the empty path.</p>

<p>Go ahead and run the application:</p>

<figure class="shell"><code><pre>
$ go run main.go
<samp>Listening on :3000...</samp>
</pre></code></figure>

<p>And open <a href="http://localhost:3000/example.html">localhost:3000/example.html</a> in your browser. You should see the HTML page we made with a big red heading.</p>

<p><img src="/static/images/static-1.png"></p>

<h2>Almost-Static Sites</h2>

<p>If you're creating a lot of static HTML files by hand, it can be tedious to keep repeating boilerplate content. Let's explore using Go's <a href="http://golang.org/pkg/html/template/"><code>html/template</code></a> package to put shared markup in a <em>layout</em> file.</p>

<p>At the moment <em>all</em> requests are being handled by our file server. Let's make a slight adjustment to our application so the file server only handles request paths that begin with the pattern <code>/static/</code> instead.</p>

<figure class="file"><figcaption>File: main.go</figcaption><code><pre>
...

func main() {
  fs := http.FileServer(http.Dir("./static"))
  http.Handle("/static/", http.StripPrefix("/static/", fs))

  log.Println("Listening on :3000...")
  err := http.ListenAndServe(":3000", nil)
  if err != nil {
    log.Fatal(err)
  }
}
</pre></code></figure>

<p>Notice that because our <code>static</code> directory is set as the root of the file system, we need to strip off the <code>/static/</code> prefix from the request path <em>before</em> searching the file system for the given file. We do this using the <a href="http://golang.org/pkg/net/http/#StripPrefix"><code>http.StripPrefix()</code></a> function.</p>

<p>If you restart the application, you should find the CSS file we made earlier available at <a href="http://localhost:3000/static/stylesheets/main.css">localhost:3000/static/stylesheets/main.css</a>.</p>

<p>Now let's create a <code>templates</code> directory, containing a <code>layout.html</code> file with shared markup, and an <code>example.html</code> file with some page-specific content.</p>

<figure class="shell"><code><pre>
$ mkdir templates
$ touch templates/layout.html templates/example.html
</pre></code></figure>

<figure class="file"><figcaption>File: templates/layout.html</figcaption><code><pre>
&#123;&#123;define "layout"&#125;&#125;
&lt;!doctype html&gt;
&lt;html&gt;
&lt;head&gt;
  &lt;meta charset="utf-8"&gt;
  &lt;title&gt;&#123;&#123;template "title"&#125;&#125;&lt;/title&gt;
  &lt;link rel="stylesheet" href="/static/stylesheets/main.css"&gt;
&lt;/head&gt;
&lt;body&gt;
  &#123;&#123;template "body"&#125;&#125;
  &lt;footer&gt;Made with Go&lt;/footer&gt;
&lt;/body&gt;
&lt;/html&gt;
&#123;&#123;end&#125;&#125;
</pre></code></figure>

<figure class="file"><figcaption>File: templates/example.html</figcaption><code><pre>
&#123;&#123;define "title"&#125;&#125;A templated page&#123;&#123;end&#125;&#125;

&#123;&#123;define "body"&#125;&#125;
&lt;h1&gt;Hello from a templated page&lt;/h1&gt;
&#123;&#123;end&#125;&#125;
</pre></code></figure>

<p>If you've used templating in other web frameworks or languages before, this should hopefully feel familiar.</p>

<p>Go templates &ndash; in the way we're using them here &ndash; are essentially just named text blocks surrounded by <code>&#123;&#123;define&#125;&#125;</code> and <code>&#123;&#123;end&#125;&#125;</code> tags. Templates can be embedded into each other using the <code>{{template}}</code> tag, like we do above where the <code>layout</code> template embeds both the <code>title</code> and <code>body</code> templates.</p>

<p>Let's update the application code to use these:</p>

<figure class="file"><figcaption>File: main.go</figcaption><code><pre>
package main

import (
  "html/template"
  "log"
  "net/http"
  "path/filepath"
)

func main() {
  fs := http.FileServer(http.Dir("./static"))
  http.Handle("/static/", http.StripPrefix("/static/", fs))

  http.HandleFunc("/", serveTemplate)

  log.Println("Listening on :3000...")
  err := http.ListenAndServe(":3000", nil)
  if err != nil {
    log.Fatal(err)
  }
}

func serveTemplate(w http.ResponseWriter, r *http.Request) {
  lp := filepath.Join("templates", "layout.html")
  fp := filepath.Join("templates", filepath.Clean(r.URL.Path))

  tmpl, _ := template.ParseFiles(lp, fp)
  tmpl.ExecuteTemplate(w, "layout", nil)
}
</pre></code></figure>

<p>So what's changed here?</p>

<p>First we've added the <code>html/template</code> and <code>path</code> packages to the import statement.</p>

<p>Then we've specified that all the requests <em>not</em> picked up by the static file server should be handled with a new <code>serveTemplate</code> function (if you were wondering, Go matches patterns based on length, with longer patterns take precedence over shorter ones).</p>

<p>In the <code>serveTemplate</code> function, we build paths to the layout file and the template file corresponding with the request. Rather than manual concatenation we use <a href="https://golang.org/pkg/path/filepath/#Join"><code>filepath.Join()</code></a>, which has the advantage joining paths using the correct separator for your OS.</p>

<p>Importantly, because the URL path is untrusted user input, we use <a href="https://golang.org/pkg/path/filepath/#Clean"><code>filepath.Clean()</code></a> to sanitise the URL path before using it.</p>

<p>(Note that even though <code>filepath.Join()</code> automatically runs the <em>joined path</em> through <code>filepath.Clean()</code>, to help prevent directory traversal attacks you need to manually sanitise any untrusted inputs <em>before</em> joining them.)</p>

<p>We then use the <a href="http://golang.org/pkg/text/template/#Template.ParseFiles"><code>template.ParseFiles()</code></a> function to bundle the requested template and layout into a <em>template set</em>. Finally, we use the <a href="http://golang.org/pkg/text/template/#Template.ExecuteTemplate"><code>template.ExecuteTemplate()</code></a> function to render a named template in the set, in our case the <code>layout</code> template.</p>

<p>Restart the application:</p>

<figure class="shell"><code><pre>
$ go run main.go
<samp>Listening on :3000...</samp>
</pre></code></figure>

<p>And open <a href="http://localhost:3000/example.html">localhost:3000/example.html</a> in your browser. You should see the markup from all the templates merged together like so:</p>
<p><img src="/static/images/static-2.png"></p>

<p>If you use web developer tools to inspect the HTTP response, you'll also see that Go automatically sets the correct <code>Content-Type</code> and <code>Content-Length</code> headers for us.</p>

<p>Lastly, let's make the code a bit more robust. We should:</p>

<ul>
  <li>Send a <code>404</code> response if the requested template doesn't exist.</li>
  <li>Send a <code>404</code> response if the requested template path is a directory.</li>
  <li>Send a <code>500</code> response if the <code>template.ParseFiles()</code> or <code>template.ExecuteTemplate()</code> functions throw an error, and log the detailed error message.</li>
</ul>

<figure class="file"><figcaption>File: main.go</figcaption><code><pre>
package main

import (
  "html/template"
  "log"
  "net/http"
  "os"
  "path/filepath"
)

func main() {
  fs := http.FileServer(http.Dir("./static"))
  http.Handle("/static/", http.StripPrefix("/static/", fs))
  http.HandleFunc("/", serveTemplate)

  log.Println("Listening on :3000...")
  err := http.ListenAndServe(":3000", nil)
  if err != nil {
    log.Fatal(err)
  }
}

func serveTemplate(w http.ResponseWriter, r *http.Request) {
  lp := filepath.Join("templates", "layout.html")
  fp := filepath.Join("templates", filepath.Clean(r.URL.Path))

  // Return a 404 if the template doesn't exist
  info, err := os.Stat(fp)
  if err != nil {
    if os.IsNotExist(err) {
      http.NotFound(w, r)
      return
    }
  }

  // Return a 404 if the request is for a directory
  if info.IsDir() {
    http.NotFound(w, r)
    return
  }

  tmpl, err := template.ParseFiles(lp, fp)
  if err != nil {
    // Log the detailed error
    log.Println(err.Error())
    // Return a generic "Internal Server Error" message
    http.Error(w, http.StatusText(500), 500)
    return
  }

  err = tmpl.ExecuteTemplate(w, "layout", nil)
  if err != nil {
    log.Println(err.Error())
    http.Error(w, http.StatusText(500), 500)
  }
}
</pre></code></figure>
    ]]></description>
  </item>
  <item>
    <pubDate>Sat, 17 Aug 2013 12:00:00 GMT</pubDate>
    <link>https://www.alexedwards.net/blog/cleaner-better-faster</link>
    <guid>https://www.alexedwards.net/blog/cleaner-better-faster</guid>
    <title>Cleaner, Better, Faster</title>
    <description><![CDATA[
    <p>I've never really known what to do with my personal site. Over the years it's been a dumping ground for links to different projects, and played host to various half-hearted attempts at blogging. But it's never really had much in the way of an actual purpose.</p>

    <p>I decided to start afresh and relaunch this site with more of a focus. After speaking to the guys from <a href="http://techzinglive.com/">Techzing</a>, I'm going to hunker down and focus my efforts on learning <a href="http://golang.org/">Go</a> really well, with the aim of possibly doing some consultancy work around it in the future. So over the coming months and maybe even years, I hope to create a lot of useful content for anyone else doing the same.</p>

    <p>Because it's also full redesign of the site, I'll do a little colophon.</p>

    <p>The site is now just static content, although I use <a href="http://sass-lang.com/">Sass</a> for stylesheets and <a href="http://daringfireball.net/projects/markdown/">Markdown</a> for writing blog posts (both of which are compiled on my local machine before publication). Some custom Go code handles the routing and templating, and it's all hosted on <a href="https://www.heroku.com">Heroku</a>.</p>

    <p>For development I used <a href="http://www.ubuntu.com/">Ubuntu</a> as my operating system, <a href="http://www.sublimetext.com/">Sublime Text</a> as my editor, <a href="http://git-scm.com/">Git</a> for version control, and <a href="https://www.dropbox.com/">Dropbox</a> for real-time backups.</p>

    <p>So with the mandatory first new post out of the way, I'm looking forward to doing a lot more with this site in the future!</p>
    ]]></description>
  </item>
</channel>
</rss>
